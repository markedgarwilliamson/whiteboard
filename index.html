<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, height=device-height initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="apple-mobile-web-app-capable" content="yes" /> 
    <style> 
     body::-webkit-scrollbar { 
       display: none;
     } 

     #wallpaperDiv {
       position: relative;
       z-index: 1;
     }
    </style> 
  </head>
  <body style="margin: 0; cursor: crosshair; position: absolute;">
    <div id="WALLPAPER"></div>
    <div id="OVERLAY" style="position: absolute; left: 0px; top: 0px; z-index: 2;"></div>
    <div id="GRID" style="position: absolute; left: 0px; top: 0px; z-index: 4;"></div>
    <div id="PROBLEM" style="position: absolute; left: 0px; top: 0px; z-index: 5;"></div>
    <canvas id="MARKS" style="position: absolute; left: 0px; top: 0px; z-index: 6;"></canvas>
    <canvas id="PALETTE" style="position: fixed; left: 0px; top: 0px; z-index: 7;"></canvas>
    <div id="TOOLS" style="position: absolute; left: 0px; top: 0px; z-index: 8;"></div>
    <div id="SENSOR" style="position: absolute; left: 0px; top: 0px; z-index: 9;"></div>
    
    <script>
      // CLASSES
      class Color {
	constructor(shade, alpha) {
	  const arrayToRgb = (arr) => {
	    this.red = arr[0]
	    this.green = arr[1]
	    this.blue = arr[2]
	  }

	  const rgbToHsl = (red, green, blue) => {
	    const cMax = Math.max(red, green, blue)
	    const cMin = Math.min(red, green, blue)
	    const delta = cMax - cMin

	    this.lum = (cMax + cMin) / 510
	    this.sat = delta === 0 ? 0 : delta / ((1 - Math.abs(2 * this.lum - 1)) * 255)	

	    switch (true) {
	    case (delta === 0):
	      this.hue = 0
	      break
	    case (cMax === red):
	      this.hue = 60 * (((green - blue) / delta) % 6)
	      break
	    case (cMax === green):
	      this.hue = 60 * (((blue - red) / delta) + 2)
	      break
	    case (cMax === blue):
	      this.hue = 60 * (((red - green) / delta) + 4)
	    }
	    this.hue = (this.hue + 360) % 360
	  }
	  
	  const hslToRgb = (hue, sat, lum) => {
	    const c = (1 - Math.abs(2 * lum - 1)) * sat
	    const x = c * (1 - Math.abs((hue / 60) % 2 - 1))
	    const m = lum - c / 2

	    let rgb
	    switch (true) {
	    case (hue >= 0 && hue < 60):
	      rgb = [c, x, 0]
	      break
	    case (hue >= 60 && hue < 120):
	      rgb = [x, c, 0]
	      break
	    case (hue >= 120 && hue < 180):
	      rgb = [0, c, x]
	      break
	    case (hue >= 180 && hue < 240):
	      rgb = [0, x, c]
	      break
	    case (hue >= 240 && hue < 300):
	      rgb = [x, 0, c]
	      break
	    case (hue >= 300 && hue <= 360):
	      rgb = [c, 0, x]
	      break
	    }
	    arrayToRgb(rgb.map((channel) => Math.round((channel + m) * 255)))
	  }

	  let colorArray = []
	  if (typeof shade === 'string') {
	    if (!/^#/.test(shade)) {
	      colorArray = mapStringToNumberArray(shade)
	    }
	    
	    if (/^hsl/.test(shade)) {
	      this.hue = parseInt(colorArray[0])
	      this.sat = parseInt(colorArray[1]) / 100
	      this.lum = parseInt(colorArray[2]) / 100
	
	      hslToRgb(this.hue, this.sat, this.lum)
	    } else {
	      if (/^#/.test(shade)) {
		this.red = parseInt(shade.slice(1, 3), 16)
		this.green = parseInt(shade.slice(3, 5), 16)
		this.blue = parseInt(shade.slice(5, 7), 16)
	      } else {
		arrayToRgb(colorArray)
	      }
	      
	      rgbToHsl(this.red, this.green, this.blue)
	    }
	  } else if (Array.isArray(shade)) {
	    colorArray = shade
	    arrayToRgb(colorArray)
	    rgbToHsl(this.red, this.green, this.blue)
	  } else if (typeof shade === 'object') {
	    Object.assign(this, shade)
	  }
	  if (colorArray[3] !== undefined) {
	    this.alpha = parseFloat(colorArray[3])
	  } else {
	    if (this.alpha === undefined) {
	      this.alpha = alpha || 1.0
	    }
	  }
	}

	getHexadecimal () {
	  return `#${this.red.toString(16).padStart(2,'0').toUpperCase()}${this.green.toString(16).padStart(2,'0').toUpperCase()}${this.blue.toString(16).padStart(2,'0').toUpperCase()}`
	}

	getRgb () {
	  return `rgba(${this.red}, ${this.green}, ${this.blue})`
	}

	getRgba () {
	  return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`
	}

	getHsl () {
	  return `hsl(${this.hue}, ${Math.round(this.sat * 100)}%, ${Math.round(this.lum * 100)}%)`
	}

	getHsla () {
	  return `hsla(${this.hue}, ${Math.round(this.sat * 100)}%, ${Math.round(this.lum * 100)}%, ${this.alpha})`
	}

	getPixelData () {
	  return [this.red, this.green, this.blue, Math.round(this.alpha * 255)]
	}

	modify (color) {
	  const temporaryShade = new Color(this)
	  if (color.hasOwnProperty('red') || color.hasOwnProperty('blue') || color.hasOwnProperty('green')) {
	    Object.assign(temporaryShade, color)
	    Object.assign(this, new Color(temporaryShade.getRgba()))
	  } if (color.hasOwnProperty('hue') || color.hasOwnProperty('sat') || color.hasOwnProperty('lum')) {
	    Object.assign(temporaryShade, color)
	    Object.assign(this, new Color(temporaryShade.getHsla()))
	  } else {
	    Object.assign(this, color)
	  }
	  return this
	}
      }

      class Vector2 {
	constructor(a, b) {
	  let x
	  let y
	  if (typeof a === 'object') {
	    if (a.hasOwnProperty('x') && a.hasOwnProperty('y')) {
	      [x, y] = [a.x, a.y]
	    } else if (a.hasOwnProperty('angle')) {
	      const magnitude = a.magnitude || 1
	      x = Math.cos(a.angle) * magnitude
	      y = Math.sin(a.angle) * magnitude
	    }
	  } else {
	    [x, y] = [a, b]
	  }
	  this.setCoordinates(x, y)
	}
	
	setCoordinates (x, y) {
	  if (typeof x === 'string') {
	    x = mapStringToNumberArray(x)
	  }
	  if (typeof x === 'object') {
	    if (Array.isArray(x)) {
	      Object.assign(this, {
		x: x[0],
		y: x[1]
	      })
	    } else {
	      Object.assign(this, x)
	    }
	  } else {
	    Object.assign(this, { x, y })
	  }
	}
	
	setSquareUnits (x, y) {
	  if (typeof x === 'string') {
	    x = mapStringToNumberArray(x)
	  }
	  if (typeof x === 'object') {
	    if (Array.isArray(x)) {
	      Object.assign(this, {
		x: x[0],
		y: x[1]
	      })
	    } else {
	      Object.assign(this, x.scale(whiteboardState[SQUARE_GRID_UNITS]))
	    }
	  } else {
	    Object.assign(this, { 
	      x: x * whiteboardState[SQUARE_GRID_UNITS].x,
	      y: y * whiteboardState[SQUARE_GRID_UNITS].y
	    })
	  }
	}
	
	setHexUnits (x, y) {
	  if (typeof x === 'string') {
	    x = mapStringToNumberArray(x)
	  }
	  if (typeof x === 'object') {
	    if (Array.isArray(x)) {
	      Object.assign(this, {
		x: x[0],
		y: x[1]
	      })
	    } else {
	      Object.assign(this, x.scale(whiteboardState[HEX_GRID_UNIT]))
	    }
	  } else {
	    Object.assign(this, { 
	      x: x * whiteboardState[HEX_GRID_UNIT],
	      y: y * whiteboardState[HEX_GRID_UNIT]
	    })
	  }
	}

	getSquareUnits () {
	  return new Vector2(
	    this.x / whiteboardState[SQUARE_GRID_UNITS].x,
	    this.y / whiteboardState[SQUARE_GRID_UNITS].y
	  )
	}

	getHexUnits () {
	  return new Vector2(
	    this.x / whiteboardState[HEX_GRID_UNIT],
	    this.y / whiteboardState[HEX_GRID_UNIT]
	  )
	}

	copy () {
	  return new Vector2(this.x, this.y);
	}

	add (v) {
	  return new Vector2(this.x + v.x, this.y + v.y);
	}

	scale (s) {
	  if (typeof s === 'number') {
	    s = new Vector2(s, s)
	  }
	  return new Vector2(this.x * s.x, this.y * s.y)
	}

	getMagnitude () {
	  return (this.x ** 2 + this.y ** 2) ** 0.5
	}

	getDistance (v) {
	  if (!v) {
	    v = new Vector2(0, 0)
	  }
	  return ((this.x - v.x)**2 + (this.y - v.y)**2)**0.5;
	}

	getAngle (v) {
	  if (!v) {
	    v = new Vector2(0, 0)
	  }
	  if (this.x === v.x) {
	    return this.y > v.y 
	      ? Math.PI / 2 
	      : Math.PI * 3 / 2
	  } else {
	    let a = Math.atan((this.y - v.y) / (this.x - v.x))
	    if (this.x < v.x) {
	      a += Math.PI
	    } else if (this.y < v.y) {
	      a += 2 * Math.PI
	    }
	    return a % (2 * Math.PI)
	  }
	}

	getPolarCoordinates () {
	  return {
	    angle: this.getAngle(),
	    magnitude: this.getDistance()
	  }
	}

	normalize (s) {
	  if (!s) {s = 1;}
	  return this.mult(1/this.mag()).mult(s)
	}

	transform (matrix) {
	  return new Vector2(this.x*matrix.a + this.y*matrix.b, this.x*matrix.c + this.y*matrix.d);
	}

	/* getSize () {
	   return this.transform(flipVert).scale(unit);
	   } */

	/* pix () {
	   return this.getSize().add(center);
	   } */

	/* units () {
	   return this.add(center.scale(-1)).scale(1/unit).transform(flipVert);
	   } */

	/* draw (ctx, fv, max) {
	   if (!max) {max = vectorSpacing;}
	   var sv = this.normalize(3); // used to draw the arrowhead.
	   var tv = this.normalize(vectorSpacing*this.mag()/max).size();
	   if (fv) {
	   fv = fv.pix();
	   } else {
	   fv = center;
	   }
	   tv = tv.add(fv);
	   drawLine(ctx, fv, tv, '#000000');
	   drawLine(ctx, tv, {'x': tv.x - sv.x + sv.y, 'y': tv.y + sv.x + sv.y}, '#000000');
	   drawLine(ctx, tv, {'x': tv.x - sv.x - sv.y, 'y': tv.y - sv.x + sv.y}, '#000000');
	   } */
      }

      // UTILITIES
      const bound = (value, min=0.0, max=1.0) => {
	return value < min 
	  ? min 
	  : value > max 
	    ? max 
	    : value
      }

      const parseFilename = (name) => name.split('/').pop().split('.').slice(0, -1).join('.')
      const tabTitle = (paths) => {
	let names = []
	for (path of paths) {
	  names.push(parseFilename(path))
	}
	return names.join(', ')
      }

      const mapStringToNumberArray = (s) => {
	return s.match(/[+-]?([0-9]*[.])?[0-9]+/g)
	  .map((element) => Number(element))
      }

      const parseQueryString = (url) => {
	const queryString = /\?/.test(url) && url.substring(url.search(/\?/) + 1)
	if (queryString) {
	  return queryString.split('&').reduce(
	    (query, pair) => {
	      const [param, input] = pair.split('=')
	      let value = input
	      if (param.includes('active')) {
		if (/(false|0)/.test(input)) {
		  value = false
		} else {
		  value = new Boolean(input)
		}
	      } else if (!param.includes('image') && /[+-]?([0-9]*[.])?[0-9]+/g.test(input)) {
		value = mapStringToNumberArray(value)
		value = value.length === 2 
		  ? { x: value[0], y: value[1] } 
		  : value.length === 1 
		  ? value[0] 
		  : value
	      }
	      query[param.replace(/-/g, '_').toUpperCase()] = value
	      return query
	    },
	    {}
	  )
	}
	return {}
      }

      const getCollection = (size, query) => {
	const collection = query ? query.collection : unsplashCollections[Math.floor((Math.random() * unsplashCollections.length))]
	return `https://source.unsplash.com/collection/${collection}/${size.x}x${size.y}`
      }

      const setWhiteboardState = (key, value) => { 
	if (value !== undefined) {
	  whiteboardState[key] = value
	}
	localStorage.setItem(
	  WHITEBOARD_STATE, 
	  JSON.stringify(whiteboardState)
	)
	return value
      }

      const applyState = (state) => {
	document.title = state[DOCUMENT_TITLE]

	for (element in dom) {	
	  if (dom[element].nodeName === 'DIV') {
	    [
	      dom[element].style.width, 
	      dom[element].style.height
	    ] = [
	      `${(state[BOARD_SIZE].x).toString()}px`, 
	      `${(state[BOARD_SIZE].y).toString()}px`
	    ]
	  } else {
	    [
	      dom[element].width, 
	      dom[element].height
	    ] = [
	      state[BOARD_SIZE].x, 
	      state[BOARD_SIZE].y
	    ]
	  }
	}
	// setImage(state[WALLPAPER_IMAGE], dom[WALLPAPER])
	dom[WALLPAPER].style.background = `url(${state[WALLPAPER_IMAGE]})`
	dom[WALLPAPER].style.backgroundAttachment = 'fixed'
	// dom[WALLPAPER].style.backgroundPosition = 'center'
	dom[WALLPAPER].style.backgroundRepeat = 'no-repeat'
	dom[WALLPAPER].style.backgroundSize = `${state[SCREEN_SIZE].x}px ${state[SCREEN_SIZE].y}px`
	setColor(state[OVERLAY_COLOR], dom[OVERLAY])
	setColor(state[GRID_COLOR], layers[GRID])
	setGrid(state[GRID_TYPE])
	for (let layer of [GRID, TOOLS]) {
	  layers[layer].setAttribute('width', state[BOARD_SIZE].x.toString())
	  layers[layer].setAttribute('height', (state[BOARD_SIZE].y).toString())
	  layers[layer].setAttribute('viewBox', `0 0 ${state[BOARD_SIZE].x} ${state[BOARD_SIZE].y}`)
	  layers[layer].setAttribute('xmlns', svgNameSpace)
	}
	setImage(state[PROBLEM_IMAGE], dom[PROBLEM], { margin: '2rem'})
	if (query[PROBLEM_ACTIVE]) {
	  dom[PROBLEM].style.display = 'initial'
	} else {
	  dom[PROBLEM].style.display = 'none'
	}
	setBrushWidth(state[BRUSHES][state[BRUSH]].width)
	setFontHeight(state[FONT_HEIGHT])
	setColor(state[BRUSHES][state[BRUSH]].color, layers[MARKS])
      }

      const readPalette = (pixelLocation, c, sideLength=colorWheelSideLength) => {
	const color = new Color(c)
	const prop = {}
	const wheelCenter = new Vector2(
	  sideLength * 7 / 16, 
	  sideLength * 7 / 16
	)
	const distance = pixelLocation.getDistance(wheelCenter)
	let { hue, sat, lum, alpha } = color
	if (distance <= sideLength * 7 / 16) {
	  if(distance > sideLength * 1 / 16) {
	    hue = pixelLocation.getAngle(wheelCenter) * 180 / Math.PI
	  }
	  prop.sat = sat = bound((distance - (sideLength * 1 / 16)) * 4 / sideLength)
	} else if (
	  (pixelLocation.x > wheelCenter.x || pixelLocation.y > wheelCenter.y) 
	    && distance > sideLength * 7 / 16
	) {
	  if (pixelLocation.x < pixelLocation.y) {
	    prop.alpha = alpha = bound((((pixelLocation.x - (sideLength * 3 / 16)) / 2) * 4 / sideLength))
	  } else {
	    prop.lum = lum = bound((((sideLength / 2) - (pixelLocation.y - (sideLength * 3 / 16))) / 2) * 4 / sideLength)
	  }
	}
	return {
	  color: new Color(`hsla(${hue}, ${sat * 100}%, ${lum * 100}%, ${alpha})`),
	  prop: prop
	}
      }

      const displayImg = (context, obj) => {
	if (!obj.complete){
	  setTimeout(() => {
	    displayImg(context, obj);
	  }, 50);
	  return;
	}
	/* if (whiteboardState[ZOOM] < 2) {
	   let scale;
	   let z = [
	   whiteboardState[SCREEN_SIZE].y / whiteboardState[SCREEN_SIZE].x > obj.naturalHeight / obj.naturalWidth,
	   whiteboardState[SCREEN_SIZE].y / whiteboardState[SCREEN_SIZE].x < obj.naturalHeight / obj.naturalWidth
	   ][whiteboardState[ZOOM]]
	   if (z) {
	   scale = whiteboardState[SCREEN_SIZE].x / obj.naturalWidth
	   } else {
	   scale = whiteboardState[SCREEN_SIZE].y / obj.naturalHeight
	   }
	   
	   context.drawImage(obj,
	   (whiteboardState[SCREEN_SIZE].x - obj.naturalWidth * scale) / 2,
	   (whiteboardState[SCREEN_SIZE].y - obj.naturalHeight * scale) / 2,
	   obj.naturalWidth * scale,
	   obj.naturalHeight * scale
	   )
	   } else {
	   let scale = whiteboardState[SCREEN_SIZE].y / whiteboardState[SCREEN_SIZE].x < obj.naturalHeight / obj.naturalWidth 
	   ? whiteboardState[SCREEN_SIZE].x / obj.naturalWidth 
	   : whiteboardState[SCREEN_SIZE].y / obj.naturalHeight
	   if (whiteboardState[ZOOM] > 2) {
	   scale = 1
	   }
	   for (let layer in canvas) {
	   canvas[layer].width = whiteboardState[SCREEN_SIZE].x = obj.naturalWidth * scale
	   canvas[layer].height = whiteboardState[SCREEN_SIZE].y = obj.naturalHeight * scale
	   } */
	  context.drawImage(obj, 0, 0, whiteboardState[BOARD_SIZE].x, whiteboardState[BOARD_SIZE].y)
      }

      const setImage = (src, layer, style) => {
	if (layer.nodeName === 'DIV') {
	  img = document.createElement('img')
	  img.src = src
	  if (style) {
	    Object.assign(img.style, style)
	  } else {
	    img.width = whiteboardState[SCREEN_SIZE].x
	  }
	  layer.appendChild(img)
	} else {
	  imageURL = src
	  if (typeof src === 'object' && src.data.includes('data:image/png;base64')) {
	    console.log(`marks-image: ${src.name}`)
	  } else if (src.includes('collection')) {
	    if (navigator.onLine) {
	      console.log(`collection: ${src.split('/')[4]}`)
	    } else {
	      setColor('#7F7F7F', dom[WALLPAPER])
	      console.log('currently offline')
	      return
	    }
	  }
	  clearLayer(layer)
	  let img = new Image()
	  img.src = src
	  displayImg(layer, img)
	  layer.drawImage(img, 0, 0, whiteboardState[BOARD_SIZE].x, whiteboardState[BOARD_SIZE].y)
	}
      }

      const clearLayer = (input) => {
	const layer = typeof input === 'string' ?  layers[input] : input
	if (layer.nodeName === 'svg') {
	  layer.innerHTML = ''
	} else if (layer.nodeName !== 'DIV') {
	  layer.clearRect(
	    0, 
	    0, 
	    whiteboardState[BOARD_SIZE].x, 
	    whiteboardState[BOARD_SIZE].y
	  )
	}
      }

      const logMarksData = () => {
	const names = []
	for (let name in whiteboardState[SAVED_MARKS_DATA]) {
	  names.push(name)
	}
	return names
      }
      
      const clearMarksData = (name) => {
	if (name) {
	  delete whiteboardState[SAVED_MARKS_DATA][name]
	  setWhiteboardState(SAVED_MARKS_DATA)
	} else {
	  setWhiteboardState(SAVED_MARKS_DATA, {})
	}
      }

      // STATIC VARIABLES
      // MAGIC STRINGS
      const WHITEBOARD_STATE = 'WHITEBOARD_STATE'
      const PAINT_BRUSH = 'PAINT_BRUSH' // p
      const ELLIPSE = 'ELLIPSE' // e
      const RECTANGLE = 'RECTANGLE' // r
      const LINE = 'LINE' // l
      const ARC = 'ARC' // a
      const TEXT = 'TEXT' // t
      const ERASER = 'ERASER' // spacebar (held)
      const BOX_ERASER = 'BOX_ERASER' // x
      const MEASURE = 'MEASURE' // m
      const PALETTE = 'PALETTE' // `, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 (held)
      
      const WALLPAPER = 'WALLPAPER'
      const OVERLAY = 'OVERLAY'
      const GRID = 'GRID'
      const PROBLEM = 'PROBLEM'
      const TOOLS = 'TOOLS'
      const MARKS = 'MARKS'
      const SENSOR = 'SENSOR'

      const DOCUMENT_TITLE = 'DOCUMENT_TITLE' // String
      const SCREEN_SIZE = 'SCREEN_SIZE' // Vector2 *
      const BOARD_SIZE = 'BOARD_SIZE' // Vector2 *
      const BOARD_SCALE = 'BOARD_SCALE' // Vector2 *
      const WALLPAPER_IMAGE = 'WALLPAPER_IMAGE' // String, not stored
      const ZOOM = 'ZOOM' // Number
      const OVERLAY_COLOR = 'OVERLAY_COLOR' // Color *
      const GRID_TYPE = 'GRID_TYPE'
      const SQUARE_GRID_UNITS = 'SQUARE_GRID_UNITS'
      const HEX_GRID_UNIT = 'HEX_GRID_UNIT'
      const GRID_COLOR = 'GRID_COLOR'
      const GRID_WIDTH = 'GRID_WIDTH'
      const PROBLEM_IMAGE = 'PROBLEM_IMAGE' // String
      const PROBLEM_ACTIVE = 'PROBLEM_ACTIVE' // Boolean
      const VANISHING_POINT = 'VANISHING_POINT' // Vector2 *
      const TOOL = 'TOOL' // String, not stored
      const MARKS_IMAGE = 'MARKS_IMAGE' // String, not stored
      const BRUSH = 'BRUSH' // Number
      const BRUSHES = 'BRUSHES' // Object { width: Number, color: Color * }
      const FONT = 'FONT' // string
      const FONT_HEIGHT = 'FONT_HEIGHT' // number
      const FONT_WIDTH = 'FONT_WIDTH' // number
      const LINE_SPACING = 'LINE_SPACING' // number
      const FILL_ACTIVE = 'FILL_ACTIVE' // Boolean
      const ANGLE = 'ANGLE' // Number
      const ERASE_RADIUS = 'ERASE_RADIUS' // Number
      const MOUSE_DOWN_LOCATION = 'MOUSE_DOWN_LOCATION' // Vector2 *
      const MOUSE_MOVE_LOCATION = 'MOUSE_MOVE_LOCATION' // Vector2 *
      const MOUSE_UP_LOCATION = 'MOUSE_UP_LOCATION' // Vector2 *
      const PRINT_HEAD_LOCATION = 'PRINT_HEAD_LOCATION' // Vector2 *
      const MEASUREMENT = 'MEASUREMENT' // Vector2 *
      const FUNCTIONS = 'FUNCTIONS' // temporary array
      const MARKS_DATA = 'MARKS_DATA' // String
      const SAVED_MARKS_DATA = 'SAVED_MARKS_DATA' // Object: { <name>: <dataURI> }

      const NONE = 'NONE'
      const VANISHING = 'VANISHING'
      const HORIZONTAL = 'HORIZONTAL'
      const VERTICAL = 'VERTICAL'
      const PARALLEL = 'PARALLEL'
      const DOZENAL = 'DOZENAL'
      const VERTICAL_HORIZONTAL  = 'VERTICAL_HORIZONTAL '
      const HEXAGONAL = 'HEXAGONAL'
      const DIAGONAL = 'DIAGONAL'
      const COMMITTED = 'COMMITTED'

      const dom = {}
      dom[WALLPAPER] = document.getElementById(WALLPAPER)
      dom[OVERLAY] = document.getElementById(OVERLAY)
      dom[GRID] = document.getElementById(GRID)
      dom[PROBLEM] = document.getElementById(PROBLEM)
      dom[PALETTE] = document.getElementById(PALETTE)
      dom[TOOLS] = document.getElementById(TOOLS)
      dom[MARKS] = document.getElementById(MARKS)
      dom[SENSOR] = document.getElementById(SENSOR)
      
      const layers = {}
      layers[PALETTE] = dom[PALETTE].getContext('2d')
      layers[MARKS] = dom[MARKS].getContext('2d')
      const svgNameSpace = 'http://www.w3.org/2000/svg'
      layers[GRID] = document.createElementNS(svgNameSpace, 'svg')
      dom[GRID].appendChild(layers[GRID])
      layers[TOOLS] = document.createElementNS(svgNameSpace, 'svg')
      dom[TOOLS].appendChild(layers[TOOLS])

      const constraints = {}
      constraints[COMMITTED] = constraints[NONE] = (toolLocation) => toolLocation
      constraints[VANISHING] = (toolLocation) => constrainLine(whiteboardState[VANISHING_POINT], whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
      constraints[ARC] = (toolLocation) => constrainArc(whiteboardState[VANISHING_POINT], whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
      constraints[HORIZONTAL] = (toolLocation) => new Vector2(toolLocation.x, whiteboardState[MOUSE_DOWN_LOCATION].y)
      constraints[VERTICAL] = (toolLocation) => new Vector2(whiteboardState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
      constraints[PARALLEL] = (toolLocation) => constrainLine(
	whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2(
	  Math.cos(whiteboardState[ANGLE]), 
	  Math.sin(whiteboardState[ANGLE])
	)),
	whiteboardState[MOUSE_DOWN_LOCATION],
	toolLocation
      )
      constraints[DOZENAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(whiteboardState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case (angle > Math.PI * 23 / 24) || (angle <= Math.PI / 24):
	  return new Vector2(toolLocation.x, whiteboardState[MOUSE_DOWN_LOCATION].y)
	  break
	case (angle > Math.PI / 24) && (angle <= Math.PI * 3 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 12 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 3 / 24) && (angle <= Math.PI * 5 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 6 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 5 / 24) && (angle <= Math.PI * 7 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 4 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 7 / 24) && (angle <= Math.PI * 9 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 3 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 9 / 24) && (angle <= Math.PI * 11 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 5 / 12 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 11 / 24) && (angle <= Math.PI * 13 / 24):
	  return new Vector2(whiteboardState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
	  break
	case (angle > Math.PI * 13 / 24) && (angle <= Math.PI * 15 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 7 / 12 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 15 / 24) && (angle <= Math.PI * 17 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 2 / 3 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 17 / 24) && (angle <= Math.PI * 19 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 3 / 4 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 19 / 24) && (angle <= Math.PI * 21 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 5 / 6 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 21 / 24) && (angle <= Math.PI * 23 / 24):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 11 / 12 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	}
      }

      constraints[VERTICAL_HORIZONTAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(whiteboardState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case (angle > Math.PI * 3 / 4) || (angle <= Math.PI / 4):
	  return new Vector2(toolLocation.x, whiteboardState[MOUSE_DOWN_LOCATION].y)
	  break
	case (angle > Math.PI / 4) && (angle <= Math.PI * 3 / 4):
	  return new Vector2(whiteboardState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
	  break
	}
      }

      constraints[HEXAGONAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(whiteboardState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case angle <= Math.PI / 3:
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 6 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI / 3) && (angle <= Math.PI * 2 / 3):
	  return new Vector2(whiteboardState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
	  break
	case (angle > Math.PI * 2 / 3) && (angle <= Math.PI):
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 5 / 6 })), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	}
      }

      constraints[DIAGONAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(whiteboardState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case angle < Math.PI / 2:
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2(-1, 1)), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case angle > Math.PI / 2:
	  return constrainLine(whiteboardState[MOUSE_DOWN_LOCATION].add(new Vector2(1, 1)), whiteboardState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	}
      }
      
      const tools = {}
      tools[PAINT_BRUSH] = {
	mouseDown: (toolLocation) => {},
	mouseMove: (toolLocation) => {
	  const offset = new Vector2(toolLocation.x, toolLocation.y)
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    if (spaceIsDown) {
	      layers[MARKS].save()
	      layers[MARKS].moveTo(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	      layers[MARKS].arc(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y, whiteboardState[ERASE_RADIUS], 0, Math.PI*2, 2)
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else {
	      layers[MARKS].lineJoin = layers[MARKS].lineCap = 'round';
	      layers[MARKS].beginPath();
	      layers[MARKS].moveTo(whiteboardState[PRINT_HEAD_LOCATION].x, whiteboardState[PRINT_HEAD_LOCATION].y);
	      layers[MARKS].lineTo(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	      layers[MARKS].stroke();
	    }
	    whiteboardState[PRINT_HEAD_LOCATION].setCoordinates(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	  }
	},
	mouseUp: (toolLocation) => {
	}
      }
      tools[COMMITTED] = {
	mouseDown: (toolLocation) => {
	  whiteboardState[ANGLE] = null
	},
	mouseMove: (toolLocation) => {
	  const offset = new Vector2(toolLocation.x, toolLocation.y)
	  if (mouseIsDown 
	    && toolLocation.getDistance(whiteboardState[MOUSE_DOWN_LOCATION]) > 10
	    && constraints[constraint](toolLocation)) {
	    if (whiteboardState[ANGLE] === null) {
	      setWhiteboardState(ANGLE, toolLocation.getAngle(whiteboardState[MOUSE_DOWN_LOCATION]))
	    }
	    const printHeadLocation = constrainLine(
	      whiteboardState[MOUSE_DOWN_LOCATION]
		.add(new Vector2({ angle: whiteboardState[ANGLE] })), 
	      whiteboardState[MOUSE_DOWN_LOCATION], 
	      toolLocation)
	    if (spaceIsDown) {
	      layers[MARKS].save()
	      layers[MARKS].moveTo(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	      layers[MARKS].arc(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y, whiteboardState[ERASE_RADIUS], 0, Math.PI*2, 2)
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else {
	      layers[MARKS].lineJoin = layers[MARKS].lineCap = 'round';
	      layers[MARKS].beginPath();
	      layers[MARKS].moveTo(whiteboardState[PRINT_HEAD_LOCATION].x, whiteboardState[PRINT_HEAD_LOCATION].y);
	      layers[MARKS].lineTo(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	      layers[MARKS].stroke();
	    }
	    whiteboardState[PRINT_HEAD_LOCATION].setCoordinates(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	  }
	},
	mouseUp: (toolLocation) => {
	}
      }
      tools[ELLIPSE] = {
	mouseDown: (toolLocation) => {
	  const horizontal = (toolLocation.x - whiteboardState[MOUSE_DOWN_LOCATION].x) / 2
	  const vertical = (toolLocation.y - whiteboardState[MOUSE_DOWN_LOCATION].y) / 2  
	  const ellipse = document.createElementNS(svgNameSpace, 'ellipse')
	  ellipse.setAttribute('id', 'ellipse')
	  ellipse.setAttribute('stroke', layers[TOOLS].strokeStyle)
	  ellipse.setAttribute('fill', whiteboardState[FILL_ACTIVE] ? layers[TOOLS].fillStyle : 'none')
	  ellipse.setAttribute('stroke-width', whiteboardState[BRUSHES][whiteboardState[BRUSH]].width)
	  ellipse.setAttribute('cx', whiteboardState[MOUSE_DOWN_LOCATION].x + horizontal)
	  ellipse.setAttribute('cy', whiteboardState[MOUSE_DOWN_LOCATION].y + vertical)
	  ellipse.setAttribute('rx', Math.abs(horizontal))
	  ellipse.setAttribute('ry', Math.abs(vertical))
	  layers[TOOLS].appendChild(ellipse)    
	},
	mouseMove: (toolLocation) => {  
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    const horizontal = (constraints[constraint](toolLocation).x - whiteboardState[MOUSE_DOWN_LOCATION].x) / 2
	    const vertical = (constraints[constraint](toolLocation).y - whiteboardState[MOUSE_DOWN_LOCATION].y) / 2  
	    const ellipse = layers[TOOLS].childNodes[0]
	    ellipse.setAttribute('cx', whiteboardState[MOUSE_DOWN_LOCATION].x + horizontal)
	    ellipse.setAttribute('cy', whiteboardState[MOUSE_DOWN_LOCATION].y + vertical)
	    ellipse.setAttribute('rx', Math.abs(horizontal))
	    ellipse.setAttribute('ry', Math.abs(vertical))
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    layers[TOOLS].innerHTML = ''
	    const horizontal = (constraints[constraint](toolLocation).x - whiteboardState[MOUSE_DOWN_LOCATION].x) / 2
	    const vertical = (constraints[constraint](toolLocation).y - whiteboardState[MOUSE_DOWN_LOCATION].y) / 2
	    if (spaceIsDown) {
	      layers[MARKS].save()
	    }
	    layers[MARKS].beginPath()
	    layers[MARKS].ellipse(
	      whiteboardState[MOUSE_DOWN_LOCATION].x + horizontal,
	      whiteboardState[MOUSE_DOWN_LOCATION].y + vertical,
	      Math.abs(horizontal),
	      Math.abs(vertical),
	      0,
	      0,
	      Math.PI * 2
	    )
	    if (spaceIsDown) {
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else if (whiteboardState[FILL_ACTIVE]) {
	      layers[MARKS].fill()
	    } else {
	      layers[MARKS].stroke()
	    }
	  }
	}
      }
      tools[RECTANGLE] = {
	mouseDown: (toolLocation) => {
	  const rectangle = document.createElementNS(svgNameSpace, 'rect')
	  rectangle.setAttribute('id', 'rectangle')
	  rectangle.setAttribute('stroke', layers[TOOLS].strokeStyle)
	  rectangle.setAttribute('fill', whiteboardState[FILL_ACTIVE] ? layers[TOOLS].fillStyle : 'none')
	  rectangle.setAttribute('stroke-width', whiteboardState[BRUSHES][whiteboardState[BRUSH]].width)
	  rectangle.setAttribute('x', Math.min(toolLocation.x, whiteboardState[MOUSE_DOWN_LOCATION].x))
	  rectangle.setAttribute('y', Math.min(toolLocation.y, whiteboardState[MOUSE_DOWN_LOCATION].y))
	  rectangle.setAttribute('width', Math.abs(toolLocation.x - whiteboardState[MOUSE_DOWN_LOCATION].x))
	  rectangle.setAttribute('height', Math.abs(toolLocation.y - whiteboardState[MOUSE_DOWN_LOCATION].y))
	  layers[TOOLS].appendChild(rectangle)
	},
	mouseMove: (toolLocation) => {  
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    const width = Math.abs(constraints[constraint](toolLocation).x - whiteboardState[MOUSE_MOVE_LOCATION].x)
	    const height = Math.abs(constraints[constraint](toolLocation).y - whiteboardState[MOUSE_MOVE_LOCATION].y)
	    const rectangle = layers[TOOLS].childNodes[0]
	    rectangle.setAttribute('x', Math.min(constraints[constraint](toolLocation).x, whiteboardState[MOUSE_DOWN_LOCATION].x))
	    rectangle.setAttribute('y', Math.min(constraints[constraint](toolLocation).y, whiteboardState[MOUSE_DOWN_LOCATION].y))
	    rectangle.setAttribute('width', Math.abs(constraints[constraint](toolLocation).x - whiteboardState[MOUSE_DOWN_LOCATION].x))
	    rectangle.setAttribute('height', Math.abs(constraints[constraint](toolLocation).y - whiteboardState[MOUSE_DOWN_LOCATION].y))
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    layers[TOOLS].innerHTML = ''
	    const rectangle = [
	      Math.min(constraints[constraint](toolLocation).x, whiteboardState[MOUSE_DOWN_LOCATION].x), 
	      Math.min(constraints[constraint](toolLocation).y, whiteboardState[MOUSE_DOWN_LOCATION].y), 
	      Math.abs(constraints[constraint](toolLocation).x - whiteboardState[MOUSE_DOWN_LOCATION].x),
	      Math.abs(constraints[constraint](toolLocation).y - whiteboardState[MOUSE_DOWN_LOCATION].y)
	    ]
	    if (spaceIsDown) {
	      layers[MARKS].clearRect(...rectangle)
	    } else if (whiteboardState[FILL_ACTIVE]) {
	      layers[MARKS].fillRect(...rectangle)
	    } else {
	      layers[MARKS].strokeRect(...rectangle)
	    }
	  }
	}
      }
      tools[LINE] = {
	mouseDown: (toolLocation) => {
	  drawLine(
	    TOOLS,
	    whiteboardState[MOUSE_DOWN_LOCATION],
	    toolLocation,
	    new Color(layers[TOOLS].strokeStyle),
	    whiteboardState[BRUSHES][whiteboardState[BRUSH]].width
	  )
	},
	mouseMove: (toolLocation) => {
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    layers[TOOLS].innerHTML = ''
	    drawLine(
	      TOOLS,
	      whiteboardState[MOUSE_DOWN_LOCATION],
	      constraints[constraint](toolLocation),
	      new Color(layers[TOOLS].strokeStyle),
	      whiteboardState[BRUSHES][whiteboardState[BRUSH]].width
	    )
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    layers[TOOLS].innerHTML = ''
	    drawLine(
	      MARKS,
	      whiteboardState[MOUSE_DOWN_LOCATION],
	      constraints[constraint](toolLocation),
	      whiteboardState[BRUSHES][whiteboardState[BRUSH]].color,
	      whiteboardState[BRUSHES][whiteboardState[BRUSH]].width
	    )
	  }
	}
      }
      tools[TEXT] = {
	mouseDown: (toolLocation) => {
	  drawTextCursor()
	},
	mouseMove: (toolLocation) => {},
	mouseUp: (toolLocation) => {}
      }
      tools[MEASURE] = {
	mouseDown: (toolLocation) => {
	  drawLine(
	    TOOLS,
	    whiteboardState[MOUSE_DOWN_LOCATION],
	    new Vector2(toolLocation.x, toolLocation.y),
	    new Color(layers[TOOLS].strokeStyle),
	    6
	  )
	},
	mouseMove: (toolLocation) => {
	  layers[TOOLS].innerHTML = ''
	  drawLine(
	    TOOLS,
	    whiteboardState[MOUSE_DOWN_LOCATION],
	    new Vector2(toolLocation.x, toolLocation.y),
	    new Color(layers[TOOLS].strokeStyle),
	    6
	  )
	},
	mouseUp: (toolLocation) => {
	  const mouseDownVector = new Vector2(whiteboardState[MOUSE_DOWN_LOCATION])
	  const mouseUpVector = new Vector2(whiteboardState[MOUSE_UP_LOCATION])
	  const angle = whiteboardState[MOUSE_UP_LOCATION].scale({ x: 1, y: -1}).getAngle(whiteboardState[MOUSE_DOWN_LOCATION].scale({ x: 1, y: -1}))
	  const upUnits = [
	    whiteboardState[MOUSE_UP_LOCATION],
	    whiteboardState[MOUSE_UP_LOCATION].getSquareUnits(),
	    whiteboardState[MOUSE_UP_LOCATION].getHexUnits()
	  ][whiteboardState[GRID_TYPE].x]
	  const downUnits = [
	    whiteboardState[MOUSE_DOWN_LOCATION],
	    whiteboardState[MOUSE_DOWN_LOCATION].getSquareUnits(),
	    whiteboardState[MOUSE_DOWN_LOCATION].getHexUnits()
	  ][whiteboardState[GRID_TYPE].x]

	  const distance = downUnits.getDistance(upUnits)

	  console.log(`measurements:\n  angle: ${(angle * 180 / Math.PI).toFixed(0)}Â°\n  distance: ${distance.toFixed(2)}`)
	  setWhiteboardState(MEASUREMENT, new Vector2(
	    whiteboardState[MOUSE_UP_LOCATION].x - whiteboardState[MOUSE_DOWN_LOCATION].x,
	    whiteboardState[MOUSE_UP_LOCATION].y - whiteboardState[MOUSE_DOWN_LOCATION].y
	  ))
	}
      }

      tools[PALETTE] = {
	mouseDown: (toolLocation) => {},
	mouseMove: (toolLocation) => {
	  toolLocation = toolLocation.add(new Vector2(-window.scrollX, -window.scrollY))
	  if (
	    mouseIsDown 
	      && toolLocation.x <= colorWheelSideLength * 3 
	      && toolLocation.y <= colorWheelSideLength
	  ) {
	    picked = readPalette(
	      new Vector2(
		toolLocation.x % colorWheelSideLength,
		toolLocation.y
	      ),
	      [
		whiteboardState[BRUSHES][whiteboardState[BRUSH]].color,
		whiteboardState[OVERLAY_COLOR],
		whiteboardState[GRID_COLOR]
	      ][Math.floor(toolLocation.x / colorWheelSideLength)],
	      colorWheelSideLength
	    )
	    /* if (shiftIsDown && toolLocation.x < colorWheelSideLength) {
	       let factor
	       for (let p in picked.prop) {
	       factor = picked.prop[p] / whiteboardState[BRUSHES][whiteboardState[BRUSH]].color[p]
	       let brush
	       while (brush < 11) {
	       if (brush !== whiteboardState[BRUSH]) {
	       whiteboardState[BRUSHES][brush].color[p] *= factor
	       whiteboardState[BRUSHES][brush].color = new Color(whiteboardState[BRUSHES][brush].getHsla())
	       }
	       }
	       }
	       } */
	    setColor(
	      picked.color, 
	      [layers[MARKS], dom[OVERLAY], layers[GRID]][Math.floor(toolLocation.x / colorWheelSideLength)]
	    )
	  }
	},
	mouseUp: (toolLocation) => {}
      }

      // CONFIGURATION
      const unsplashCollections = [
	1242150,
	1457745,
	289662,
	1976082,
	920773,
	1886495,
	1772170,
	416021,
	548245,
	923267,
	827751,
	145238,
	179297,
	869015,
	397119,
	562095,
	1240111,
	782123,
	827743,
	2254180,
	1424240,
	162468,
	1223439,
	357786,
	1538150,
	256443,
	1166960,
	1405010,
	463870,
	545337,
	1463948,
	1346770,
	410546,
	193055,
	1525589,
	332024,
	167880,
	181581,
	3178572,
	175083,
	540518,
	573009,
	225,
	2227966, 
	1136512, 
	256789, 
	770373, 
	1340426, 
	786426, 
	1093185, 
	2073541, 
	631014, 
	311432, 
	401930, 
	1558570, 
	634016, 
	1753486, 
	525374, 
	402648, 
	944309, 
	1223029, 
	1045960, 
	136192, 
	139523, 
	490159, 
	1319676, 
	603534, 
	1705422, 
	421702, 
	1201283, 
	1280629, 
	250310, 
	1079579, 
	159185, 
	357250, 
	461372, 
	222193, 
	981639, 
	389015, 
	427860, 
	1922955, 
	550831, 
	1566993, 
	228211, 
	637183, 
	1348126, 
	860813, 
	279087, 
	893395, 
	1445644, 
	1364697, 
	266986, 
	1130937, 
	1030539, 
	441643, 
	1301636, 
	1078224, 
	346831, 
	217461, 
	195845, 
	291422, 
	326234, 
	1301396, 
	159106, 
	2222015, 
	993107, 
	1661394, 
	1563872, 
	789653, 
	139449, 
	395791, 
	168902, 
	1363567, 
	774640, 
	668423, 
	1091443, 
	631110, 
	589982, 
	251528, 
	158665, 
	1281908, 
	1025599, 
	403132, 
	542909, 
	1695735, 
	345761, 
	2241198, 
	2213392, 
	303466, 
	1266354, 
	932809, 
	525557, 
	1111575, 
	1698281, 
	325867, 
	992061,  
	1394721, 
	1949, 
	220388, 
	343012, 
	151521, 
	137627,  
	335992, 
	1494572, 
	148642, 
	311958, 
	460827, 
	1179044, 
	320872, 
	345744, 
	151899, 
	345758, 
	1163715, 
	256466, 
	926827, 
	1725806, 
	1152757, 
	981639, 
	647, 
	138884, 
	1477100, 
	1301689, 
	1664497,  
	1677633, 
	2020767, 
	924999, 
	147383, 
	934875, 
	1708734, 
	1751890, 
	668443, 
	1137170, 
	1134892, 
	1004394, 
	1366113,  
	632964, 
	142371, 
	536034, 
	923414, 
	490, 
	630848, 
	241614, 
	1117100, 
	896618, 
	525483, 
	444531, 
	1896376,
	1515841, 
	1270392, 
	635672, 
	560743, 
	158642, 
	212915, 
	236531
      ]
    
      const colorWheelSideLength = 400

      const periodicTable = () => 'https://www.cmu.edu/news/stories/archives/2016/january/images/periodic_table_large.png'
      const randomImage = (size) => `https://source.unsplash.com/random/${size.x}x${size.y}`
      const slideshow = []
      const globalOrigin = new Vector2(0, 0)
      const hpScreenDimenstions = new Vector2(1366, 768)
      const fontSizes = [8, 9, 10, 11, 12, 14, 18, 24, 30, 36, 48, 60, 72, 96]

      const defaultState = {}
      defaultState[DOCUMENT_TITLE] = 'Whiteboard'
      defaultState[SCREEN_SIZE] = new Vector2(1366, 768)
      defaultState[BOARD_SCALE] = new Vector2(1, 2)
      defaultState[ZOOM] = 1
      defaultState[OVERLAY_COLOR] = new Color('rgba(255, 255, 255, 0.0)')
      defaultState[SQUARE_GRID_UNITS] = new Vector2(60, 60) // Grid separated to four variables, for easy query strings.
      defaultState[HEX_GRID_UNIT] = 60
      defaultState[GRID_TYPE] = new Vector2(0, 0)
      defaultState[GRID_WIDTH] = 2
      defaultState[GRID_COLOR] = new Color('rgba(0, 0, 0, 0.4)')
      defaultState[VANISHING_POINT] = new Vector2(0, 0)
      defaultState[PROBLEM_IMAGE] = 'problem.png'
      defaultState[PROBLEM_ACTIVE] = false
      defaultState[TOOL] = PAINT_BRUSH
      defaultState[BRUSH] = 0
      defaultState[BRUSHES] = [
	{ width: 2, color: new Color('hsla(0, 0%, 0%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(30, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(60, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(120, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(180, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(240, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(300, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(30, 100%, 30%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 0%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 0%, 100%, 1.0)') }
      ]
      defaultState[FILL_ACTIVE] = false
      defaultState[FONT] = 'Courier New'
      defaultState[FONT_HEIGHT] = 10
      defaultState[FONT_WIDTH] = 30
      defaultState[LINE_SPACING] = 60
      defaultState[ANGLE] = 1.2277723863741932
      defaultState[ERASE_RADIUS] = 12
      defaultState[MOUSE_DOWN_LOCATION] = globalOrigin.copy()
      defaultState[MOUSE_MOVE_LOCATION] = globalOrigin.copy()
      defaultState[MOUSE_UP_LOCATION] = globalOrigin.copy()
      defaultState[PRINT_HEAD_LOCATION] = globalOrigin.copy()
      defaultState[MEASUREMENT] = globalOrigin.copy()
      defaultState[SAVED_MARKS_DATA] = {}
      
      // Prepare Objects for Grid
      const drawLine = function(layer, fv, tv, color, width) {
	if (layers[layer].nodeName === 'svg') {
	  const line = document.createElementNS(svgNameSpace, 'line')
	  line.setAttribute('x1', fv.x.toString())
	  line.setAttribute('y1', fv.y.toString())
	  line.setAttribute('x2', tv.x.toString())
	  line.setAttribute('y2', tv.y.toString())
	  line.setAttribute('stroke', color ? color.getRgba() : whiteboardState[`${layer}_COLOR`].getRgba())
	  line.setAttribute('stroke-width', width || whiteboardState[`${layer}_WIDTH`])
	  layers[layer].appendChild(line)
	} else { // draw line on canvas
	  layers[layer].beginPath()
	  layers[layer].moveTo(fv.x, fv.y)
	  layers[layer].lineTo(tv.x, tv.y)
	  layers[layer].strokeStyle = color ? color.getRgba() : whiteboardState[`${layer}_COLOR`].getRgba()
	  layers[layer].stroke()
	}
      };
      
      const drawCircle = (center, radius, color, filled=false) => {
	const circle = document.createElementNS(svgNameSpace, 'circle')
	circle.setAttribute('cx', center.x.toString())
	circle.setAttribute('cy', center.y.toString())
	circle.setAttribute('r', radius.toString())
	circle.setAttribute('stroke', color.getRgba())
	circle.setAttribute('stroke-width', whiteboardState[GRID_WIDTH].toString())
	if (!filled) {
	  circle.setAttribute('fill', 'transparent')
	} else {
	  circle.setAttribute('fill', color.getRgba())
	}
	layers[GRID].appendChild(circle)
	return circle
      }
      

      // draw cursor for typing
      const drawTextCursor = () => {
	if (isTyping) {
	  clearLayer(TOOLS)
	  const rectangle = document.createElementNS(svgNameSpace, 'rect')
	  rectangle.setAttribute('id', 'rectangle')
	  rectangle.setAttribute('stroke', 'none')
	  rectangle.setAttribute('fill', layers[TOOLS].fillStyle)
	  rectangle.setAttribute('x', whiteboardState[PRINT_HEAD_LOCATION].x)
	  rectangle.setAttribute('y', whiteboardState[PRINT_HEAD_LOCATION].y - fontSizes[whiteboardState[FONT_HEIGHT]])
	  rectangle.setAttribute('width', whiteboardState[FONT_WIDTH])
	  rectangle.setAttribute('height', fontSizes[whiteboardState[FONT_HEIGHT]])
	  layers[TOOLS].appendChild(rectangle)
	}
      }

      // DRAW COLOR WHEEL
      const drawColorWheel = (c, offset, sideLength=colorWheelSideLength) => {
	color = new Color(c)
	// populate pixels array
	let pickerArray = []
	const pixelLocation = new Vector2(0, 0)
	while (pixelLocation.y < sideLength) {
	  pixelLocation.setCoordinates({ x: 0 })
	
	  while (pixelLocation.x < sideLength) {
	    const pixelData = readPalette(pixelLocation, color).color.getPixelData()
	    pickerArray.push(...pixelData)
	    pixelLocation.setCoordinates({ x: pixelLocation.x + 1 })
	  }
	  pixelLocation.setCoordinates({ y: pixelLocation.y + 1 })
	}
	pickerArray = new Uint8ClampedArray(pickerArray)
	const pickerData = new ImageData(pickerArray, sideLength)
	layers[PALETTE].putImageData(pickerData, offset.x, offset.y)
      }

      // DRAW GRIDS
      const drawSquareDotsGrid = () => {
	let head = new Vector2(
	  whiteboardState[VANISHING_POINT].x % whiteboardState[SQUARE_GRID_UNITS].x,
	  whiteboardState[VANISHING_POINT].y % whiteboardState[SQUARE_GRID_UNITS].y
	)
	while (head.y < whiteboardState[BOARD_SIZE].y) {
	  while (head.x < whiteboardState[BOARD_SIZE].x) {
	    drawCircle(
	      head, 
	      whiteboardState[GRID_WIDTH] / 2, 
	      whiteboardState[GRID_COLOR], 
	      true
	    )
	    head.x += whiteboardState[SQUARE_GRID_UNITS].x
	  }
	  head.x = whiteboardState[VANISHING_POINT].x % whiteboardState[SQUARE_GRID_UNITS].x
	  head.y += whiteboardState[SQUARE_GRID_UNITS].y
	}
      }
      
      const drawLinedGrid = () => {
	let head = whiteboardState[VANISHING_POINT].y % whiteboardState[SQUARE_GRID_UNITS].y
	while (head < whiteboardState[BOARD_SIZE].y) {
	  drawLine(
	    GRID, 
	    new Vector2(0, head), 
	    new Vector2(whiteboardState[BOARD_SIZE].x, head)
	  )
	  head += whiteboardState[SQUARE_GRID_UNITS].y
	}
      }

      const drawSquareGrid = () => {
	let head = new Vector2(
	  whiteboardState[VANISHING_POINT].x % whiteboardState[SQUARE_GRID_UNITS].x,
	  whiteboardState[VANISHING_POINT].y % whiteboardState[SQUARE_GRID_UNITS].y
	)
	while (head.x < whiteboardState[BOARD_SIZE].x) {
	  drawLine(
	    GRID, 
	    new Vector2(head.x, 0), 
	    new Vector2(head.x, whiteboardState[BOARD_SIZE].y)
	  )
	  head.x += whiteboardState[SQUARE_GRID_UNITS].x
	}
	while (head.y < whiteboardState[BOARD_SIZE].y) {
	  drawLine(
	    GRID, 
	    new Vector2(0, head.y), 
	    new Vector2(whiteboardState[BOARD_SIZE].x, head.y)
	  )
	  head.y += whiteboardState[SQUARE_GRID_UNITS].y
	}
      }
      
      const drawTriangleDotsGrid = () => {
	const headIntervals = new Vector2 (
	  whiteboardState[HEX_GRID_UNIT] * Math.sqrt(3),
	  whiteboardState[HEX_GRID_UNIT]
	)
	let head = new Vector2(
	  (whiteboardState[VANISHING_POINT].x % headIntervals.x) - headIntervals.x,
	  (whiteboardState[VANISHING_POINT].y % headIntervals.y) - headIntervals.y
	)
	while (head.y < whiteboardState[BOARD_SIZE].y + headIntervals.y) {
	  while (head.x < whiteboardState[BOARD_SIZE].x + headIntervals.x) {
	    drawCircle(
	      head, 
	      whiteboardState[GRID_WIDTH] / 2, 
	      whiteboardState[GRID_COLOR], 
	      true
	    )
	    drawCircle(
	      new Vector2(
		head.x + headIntervals.x / 2,
		head.y + headIntervals.y / 2
	      ),
	      whiteboardState[GRID_WIDTH] / 2, 
	      whiteboardState[GRID_COLOR], 
	      true
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (whiteboardState[VANISHING_POINT].x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      const drawHexGrid = () => {
	const headIntervals = new Vector2(
	  whiteboardState[HEX_GRID_UNIT] * Math.sqrt(3),
	  whiteboardState[HEX_GRID_UNIT] * 3
	)
	let head = new Vector2(
	  (whiteboardState[VANISHING_POINT].x % headIntervals.x) - headIntervals.x,
	  (whiteboardState[VANISHING_POINT].y % headIntervals.y) - headIntervals.y
	)
	while (head.y < whiteboardState[BOARD_SIZE].y + headIntervals.y * 2 / 3) {
	  while (head.x < whiteboardState[BOARD_SIZE].x + headIntervals.x / 2) {
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y * 2 / 3), 
	      new Vector2(head.x, head.y - headIntervals.y / 3)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y / 3),
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 6)
	    )
	    drawLine(
	      GRID,
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 6),
	      new Vector2(head.x, head.y - headIntervals.y / 3)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 6),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y + headIntervals.y / 3),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y + headIntervals.y / 3),
	      new Vector2(head.x + headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (whiteboardState[VANISHING_POINT].x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      const drawTriangleGrid = () => {
	const headIntervals = new Vector2(
	  whiteboardState[HEX_GRID_UNIT] * Math.sqrt(3),
	  whiteboardState[HEX_GRID_UNIT]
	)
	let head = new Vector2(
	  (whiteboardState[VANISHING_POINT].x % headIntervals.x) - headIntervals.x,
	  (whiteboardState[VANISHING_POINT].y % headIntervals.y) - headIntervals.y
	)
	while (head.y < whiteboardState[BOARD_SIZE].y + headIntervals.y * 2 / 3) {
	  while (head.x < whiteboardState[BOARD_SIZE].x + headIntervals.x / 2) {
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x, head.y - headIntervals.y)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y),
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 2),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 2)
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (whiteboardState[VANISHING_POINT].x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      /* const weekdays = [
	 'Sunday',
	 'Monday',
	 'Tuesday',
	 'Wednesday',
	 'Thursday',
	 'Friday',nn
	 'Saturday'
       * ]

       * const drawPlanner = () => {

	 // Draw lines for planner	
	 layers[MARKS].font = `16px ${whiteboardState[FONT]}`
	 layers[MARKS].lineWidth = 1
	 const border = Math.min(whiteboardState[SCREEN_SIZE].x, whiteboardState[SCREEN_SIZE].y) / 36
	 const cell = new Vector2(
	 (whiteboardState[SCREEN_SIZE].x - (2 * border)) / 7,
	 (whiteboardState[SCREEN_SIZE].y - (2* border)) / 18
	 )
	 const head = new Vector2(
	 border,
	 border
	 )
	 const drawHorizontal = () => {
	 drawLine(
	 layers[MARKS],
	 head,
	 new Vector2(
	 whiteboardState[SCREEN_SIZE].x - border, 
	 head.y
	 ),
	 layers[MARKS].strokeStyle
	 )
	 }
	 const drawVertical = () => {
	 drawLine(
	 layers[MARKS],
	 head,
	 new Vector2(
	 head.x, 
	 whiteboardState[SCREEN_SIZE].y - border
	 ),
	 layers[MARKS].strokeStyle
	 )
	 }
	 while (head.y < whiteboardState[SCREEN_SIZE].y) {
	 drawHorizontal()
	 head.y += cell.y
	 }
	 head.y = border
	 let hour
	 let weekday = 0
	 while (head.x <= whiteboardState[SCREEN_SIZE].x) {
	 drawVertical()
	 layers[MARKS].clearRect(
	 head.x + (border / 2),
	 0,
	 cell.x - border,
	 whiteboardState[SCREEN_SIZE].y
	 )
	 hour = 6
	 while (head.y <= whiteboardState[SCREEN_SIZE].y) {
	 layers[MARKS].clearRect(
	 head.x - 12, 
	 head.y - 10, 
	 24.8, 
	 20
	 )
	 layers[MARKS].fillText(
	 `${(hour < 10 ? '0' : '')}${hour}`, 
	 head.x - 10, 
	 head.y + 6
	 )
	 if (hour % 6 === 0) {
	 layers[MARKS].font = `12px ${whiteboardState[FONT]}`
	 layers[MARKS].fillText(
	 weekdays[weekday % 7], 
	 head.x + (cell.x / 2) - (weekdays[weekday % 7].length * 3.5), 
	 head.y + 4
	 )
	 layers[MARKS].font = `16px ${whiteboardState[FONT]}`
 	 }
	 hour += 2
	 head.y += cell.y * 2
	 }
	 head.x += cell.x
	 head.y = border
	 weekday += 1
	 }
	 
 	 layers[MARKS].font = `${fontSizes[whiteboardState[FONT_HEIGHT]]}px ${whiteboardState[FONT]}`
	 layers[MARKS].lineWidth = whiteboardState[BRUSHES][whiteboardState[BRUSH]].width
       * }

       * // Draw calendar for current month
       * const drawCalendar = () => {
	 const today = new Date()
	 const hasLeapDay = (dt) => {
	 if (dt.getMonth() === 1) {
	 const year = dt.getFullYear()
	 if (year % 400 === 0) {
	 return 1
	 } else if (year % 100 === 0) {
	 return 0
	 } else if (year % 4 === 0) {
	 return 1
	 } else {
	 return 0
	 }
	 } else {
	 return 0
	 }
	 } 
	 const months = [
	 { name: 'January', days: 31 },
	 { name: 'February', days: 28 },
	 { name: 'March', days: 31 },
	 { name: 'April', days: 30 },
	 { name: 'May', days: 31 },
	 { name: 'June', days: 30 },
	 { name: 'July', days: 31 },
	 { name: 'August', days: 31 },
	 { name: 'September', days: 30 },
	 { name: 'October', days: 31 },
	 { name: 'November', days: 30 },
	 { name: 'December', days: 31 }
	 ]
	 const theseDays = months[today.getMonth()].days + hasLeapDay(today)

	 // Draw lines for <calenda></calenda>r
	 layers[MARKS].lineWidth = 2
	 const border = Math.min(whiteboardState[SCREEN_SIZE].x, whiteboardState[SCREEN_SIZE].y) / 30
	 let dayNumber = (8 + today.getDay() - (today.getDate() % 7)) % 7
	 const rows = dayNumber + theseDays < 36 ? 5 : 6
	 const cell = new Vector2(
	 (whiteboardState[SCREEN_SIZE].x - (2 * border)) / 7,
	 (whiteboardState[SCREEN_SIZE].y - ( 110 + border)) / rows
	 )
	 const head = new Vector2(
	 border,
	 110
	 )
	 const drawHorizontal = () => {
	 drawLine(
	 layers[MARKS],
	 head,
	 new Vector2(
	 whiteboardState[SCREEN_SIZE].x - border, 
	 head.y
	 ),
	 layers[MARKS].strokeStyle
	 )
	 }
	 while (head.y < whiteboardState[SCREEN_SIZE].y) {
	 drawHorizontal()
	 head.y += cell.y
	 }  
	 head.y = 76
	 drawHorizontal()
	 while (head.x < whiteboardState[SCREEN_SIZE].x) {
	 drawLine(
	 layers[MARKS],
	 head,
	 new Vector2(
	 head.x, 
	 whiteboardState[SCREEN_SIZE].y - border
	 ),
	 layers[MARKS].strokeStyle
	 )
	 head.x += cell.x
	 }
	 
	 // Print text onto calendar
	 layers[MARKS].font = `40px ${whiteboardState[FONT]}`
	 layers[MARKS].fillText(`${months[today.getMonth()].name}, ${today.getFullYear()}`, 42, 50)
	 // day names
	 layers[MARKS].font = `20px ${whiteboardState[FONT]}`
	 head.setCoordinates(
	 border + (cell.x / 2), 
	 101
	 )
	 for (let dayName of weekdays) {
	 layers[MARKS].fillText(dayName, head.x - (dayName.length * 5.8), head.y)
	 head.x += cell.x
	 }
	 // date numbers
	 let thisDate = 1
	 head.setCoordinates(
	 36 + (dayNumber * cell.x), 
	 136
	 )
	 while (thisDate <= theseDays) {
	 let halfSpace = thisDate < 10 ? 6.2 : 0
	 layers[MARKS].fillText(thisDate, head.x + halfSpace, head.y)
	 thisDate += 1
	 dayNumber += 1
	 if (dayNumber % 7 === 0) {
	 head.setCoordinates(
	 36,
	 head.y + cell.y
	 )
	 } else {
	 head.x += cell.x
	 }
	 }
	 layers[MARKS].font = `${fontSizes[whiteboardState[FONT_HEIGHT]]}px ${whiteboardState[FONT]}`
	 layers[MARKS].lineWidth = whiteboardState[BRUSHES][whiteboardState[BRUSH]].width
       * } */
    
      // REDUNDANT BRUSH WIDTH
      const setBrushWidth = (newBrushWidth) => {
	whiteboardState[BRUSHES][whiteboardState[BRUSH]].width = newBrushWidth
	layers[MARKS].lineWidth = whiteboardState[BRUSHES][whiteboardState[BRUSH]].width	
	whiteboardState[ERASE_RADIUS] = 10 + layers[MARKS].lineWidth
      }

      const setColor = (c, layer=layers[MARKS]) => {
	color = new Color(c)
	switch (layer) {
	case dom[OVERLAY]:
	  dom[OVERLAY].style.background = color.getRgba()
	
	  setWhiteboardState(OVERLAY_COLOR, color)
	  drawColorWheel(color, new Vector2(colorWheelSideLength, 0))
	  break
	case layers[GRID]:
	  setWhiteboardState(GRID_COLOR, color)
	  setGrid(whiteboardState[GRID_TYPE])
	  drawColorWheel(color, new Vector2(colorWheelSideLength * 2, 0))
	  break
	case layers[MARKS]:
	  layers[MARKS].strokeStyle = color.getRgba()
	  layers[MARKS].fillStyle = color.getRgba()
	  layers[MARKS].globalAlpha = color.alpha
	  layers[TOOLS].strokeStyle = new Color(Object.assign({}, { ...color, alpha: 0.5 })).getRgba()
	  layers[TOOLS].fillStyle = new Color(Object.assign({}, { ...color, alpha: 0.5 })).getRgba()
	  const brushes = [...whiteboardState[BRUSHES]]
	  brushes[whiteboardState[BRUSH]].color = color
	  setWhiteboardState(BRUSHES, brushes)
	  drawColorWheel(color, new Vector2(0, 0))
	}
      }

      const setLightness = (factor) => {
	for (let brush of whiteboardState[BRUSHES]) {
	 brush.color.modify({ lum: bound(brush.color.lum * factor) })
	}
	setWhiteboardState(BRUSHES, whiteboardState[BRUSHES])
      }

      const setGrid = (settings) => {
	if (!isTyping) {
	  clearLayer(GRID)
	  if (settings.x === 0) {
	    whiteboardState[GRID_TYPE].setCoordinates(0, settings.y)
	    setWhiteboardState(GRID_TYPE)
	  } else {
	    [
	      [
		drawSquareDotsGrid,
		drawLinedGrid,
		drawSquareGrid,
	      ],
	      [
		drawTriangleDotsGrid,
		drawHexGrid,
		drawTriangleGrid
	      ]
	    ][settings.x - 1][settings.y]()
	    whiteboardState[GRID_TYPE].setCoordinates(settings)
	    setWhiteboardState(GRID_TYPE)
	    drawCircle(
	      whiteboardState[VANISHING_POINT], 
	      5, 
	      whiteboardState[GRID_COLOR]
	    )
	  }
	}
      }

      const setVanishingPoint = (x, y) => {
	clearLayer(GRID)
	whiteboardState[VANISHING_POINT].setCoordinates(x, y)
	setGrid(whiteboardState[GRID_TYPE])
	console.log(`vanish: (${whiteboardState[VANISHING_POINT].x}, ${whiteboardState[VANISHING_POINT].y})`)
	setWhiteboardState(VANISHING_POINT, whiteboardState[VANISHING_POINT])
	setGrid(whiteboardState[GRID_TYPE])
      }

      const addAngle = (degrees) => {
	setWhiteboardState(ANGLE, whiteboardState[ANGLE] + (degrees * Math.PI / 180))
      }

      const plotFunction = (cb, brush=whiteboardState[BRUSHES][whiteboardState[BRUSH]]) => {
	whiteboardState[FUNCTIONS].push(cb)
	let plotHeadLocation
	let previousPlotHeadLocation
	switch (whiteboardState[GRID_TYPE].x) {
	case 1:
	  let nextPlotHeadX
	  plotHeadLocation = new Vector2(
	    - whiteboardState[VANISHING_POINT].x / whiteboardState[SQUARE_GRID_UNITS].x,
	    cb(whiteboardState[VANISHING_POINT].x / whiteboardState[SQUARE_GRID_UNITS].x)
	  )
	  previousPlotHeadLocation = plotHeadLocation.copy()
	  while (plotHeadLocation.x <= whiteboardState[BOARD_SIZE].add(whiteboardState[VANISHING_POINT].scale(-1)).getSquareUnits().x) {
	    drawLine(
	      GRID,
	      previousPlotHeadLocation
		.scale({ x: whiteboardState[SQUARE_GRID_UNITS].x, y: -whiteboardState[SQUARE_GRID_UNITS].y })
		.add(whiteboardState[VANISHING_POINT]),
	      plotHeadLocation
		.scale({ x: whiteboardState[SQUARE_GRID_UNITS].x, y: -whiteboardState[SQUARE_GRID_UNITS].y })
		.add(whiteboardState[VANISHING_POINT]),
	      brush.color,
	      brush.width
	    )
	    previousPlotHeadLocation.setCoordinates(plotHeadLocation)
	    nextPlotHeadX = plotHeadLocation.x + (1 / whiteboardState[SQUARE_GRID_UNITS].x)
	    plotHeadLocation.setCoordinates({ 
	      x: nextPlotHeadX,
	      y: cb(nextPlotHeadX)
	    })
	  }
	  break
	case 2:
	  let radians = 0
	  plotHeadLocation = new Vector2({ 
	    angle: radians, 
	    magnitude: cb(radians)
	  })
	  while (radians < 2 * Math.PI) {
	    if (radians > Math.PI / 180) {
	      drawLine(
		GRID,
		previousPlotHeadLocation
		  .scale({ x: whiteboardState[HEX_GRID_UNIT], y: -whiteboardState[HEX_GRID_UNIT] })
		  .add(whiteboardState[VANISHING_POINT]),
		plotHeadLocation
		  .scale({ x: whiteboardState[HEX_GRID_UNIT], y: -whiteboardState[HEX_GRID_UNIT] })
		  .add(whiteboardState[VANISHING_POINT]),
		brush.color,
		brush.width
	      )
	    }
	    previousPlotHeadLocation = plotHeadLocation.copy()
	    radians += Math.PI / 180
	    plotHeadLocation = new Vector2({ 
	      angle: radians, 
	      magnitude: cb(radians)
	    })
	  }
	  break
	}
      }

      // Typing
      function typingFunction (e) {
	if (![
	  'Shift', 
	  'Enter', 
	  'Control', 
	  'Alt', 
	  'ArrowUp', 
	  'ArrowRight', 
	  'ArrowDown', 
	  'ArrowLeft',
	  'Backspace',
	  'CapsLock',
	  'Escape',
	  'Delete'
	].includes(e.key)) {
	  layers[MARKS].fillText(e.key, whiteboardState[PRINT_HEAD_LOCATION].x, whiteboardState[PRINT_HEAD_LOCATION].y)
	  whiteboardState[PRINT_HEAD_LOCATION].x += whiteboardState[FONT_WIDTH]
	  drawTextCursor()
	}
      }

      const setFontHeight = (heightIndex, font) => {
	setWhiteboardState(FONT_HEIGHT, heightIndex)
	if (font !== undefined) {
	  setWhiteboardState(FONT, font)
	}
	const heightInPixels = fontSizes[heightIndex]
	whiteboardState[FONT_WIDTH] = heightInPixels * 0.62
	whiteboardState[LINE_SPACING] = heightInPixels * 1.25
	layers[MARKS].font = `${heightInPixels}px ${whiteboardState[FONT]}`
      }
      
      const offset = globalOrigin.copy()

      const constrainLine = (a, b, c) => {
	if (a.x === b.x) {
	  return new Vector2(a.x, c.y)
	} else if (a.y === b.y) {
	  return new Vector2(c.x, a.y)
	}
	const slope = {
	  b: (b.y - a.y) / (b.x - a.x),
	  c: (b.x - a.x) / (b.y - a.y) // the slope of the second line is the negative inverse of the first, but this is left positive to simplify thewhiteboardState[MOUSE_DOWN_LOCATION] equation.
	}
	const xOffset = ((c.y - a.y) + ((c.x - a.x) * slope.c)) / (slope.b + slope.c)
	return new Vector2(
	  xOffset + a.x,
	  (xOffset * slope.b) + a.y
	)
      }

      const constrainArc = (a, b, c) => {
	const scale = a.getDistance(b)/a.getDistance(c)
	return new Vector2(
	  (c.x - a.x) * scale + a.x,
 	  (c.y - a.y) * scale + a.y
	)
      }
      
      // EVENT LISTENERS
      let mouseIsDown = false
      let keyIsDown = false
      let shiftIsDown = false
      let spaceIsDown = false

      dom[SENSOR].addEventListener('mousedown', (e) => {
	mouseIsDown = true
	const mouseLocation = new Vector2(e.offsetX, e.offsetY)
	whiteboardState[MOUSE_DOWN_LOCATION].setCoordinates(mouseLocation)
	setWhiteboardState(MOUSE_DOWN_LOCATION, whiteboardState[MOUSE_DOWN_LOCATION])
	whiteboardState[PRINT_HEAD_LOCATION].setCoordinates(mouseLocation)
	tools[whiteboardState[TOOL]].mouseDown(mouseLocation)
      })
      dom[SENSOR].addEventListener('mousemove', (e) => {
	const mouseLocation = new Vector2(e.offsetX, e.offsetY)
	whiteboardState[MOUSE_MOVE_LOCATION].setCoordinates(mouseLocation)
	if (mouseIsDown) {
	  tools[whiteboardState[TOOL]].mouseMove(mouseLocation)
	}
      })
      dom[SENSOR].addEventListener('mouseup', (e) => {
	const mouseLocation = new Vector2(e.offsetX, e.offsetY)
	mouseIsDown = false
	whiteboardState[MOUSE_UP_LOCATION].setCoordinates(mouseLocation)
	tools[whiteboardState[TOOL]].mouseUp(mouseLocation)
      })

      document.body.addEventListener("touchstart", function (e) {
	if (e.target.id === SENSOR) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  mouseIsDown = true
	  whiteboardState[MOUSE_DOWN_LOCATION].setCoordinates(touchLocation)
	  setWhiteboardState(MOUSE_DOWN_LOCATION, whiteboardState[MOUSE_DOWN_LOCATION])
	  whiteboardState[PRINT_HEAD_LOCATION].setCoordinates(touchLocation)
	  tools[whiteboardState[TOOL]].mouseDown(touchLocation)
	}
      }, { passive: false })
      document.body.addEventListener("touchmove", function (e) {
	if (e.target === dom[SENSOR]) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  whiteboardState[MOUSE_MOVE_LOCATION].setCoordinates(touchLocation)
	  if (mouseIsDown) {
	    tools[whiteboardState[TOOL]].mouseMove(touchLocation)
	  }
	}
      }, { passive: false });
      document.body.addEventListener("touchend", function (e) {
	if (e.target === dom[SENSOR]) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  mouseIsDown = false
	  whiteboardState[MOUSE_UP_LOCATION].setCoordinates(touchLocation)
	  tools[whiteboardState[TOOL]].mouseUp(touchLocation)
	}
      }, { passive: false })

      dom[SENSOR].addEventListener('mouseup', (event) => {
	mouseIsDown = false;
	isDrawing = false
	let mouse = new Vector2(whiteboardState[MOUSE_MOVE_LOCATION].x, whiteboardState[MOUSE_MOVE_LOCATION].y)
	let width = mouse.x -whiteboardState[MOUSE_DOWN_LOCATION].x
	let height = mouse.y -whiteboardState[MOUSE_DOWN_LOCATION].y
      })

      dom[SENSOR].addEventListener('mouseout', () => {
	isDrawing = false
	mouseIsDown = false
      })

      dom[SENSOR].addEventListener('contextmenu', (e) => {
	isDrawing = false
	mouseIsDown = false
      })

      document.addEventListener('keydown', (event) => {
	if (isTyping) {
	  typingFunction(event)
	}
	if (!keyIsDown) {
	  switch (event.key) {
	    /* case 'h':
	       if (!isTyping) {
	       alert('CONTROLS:\n\nShift: bold\nSpacebar: eraser\nz: box-eraser\nEscape: clear screen\ni: copy input\no: paste output\n\nCOLORS:\nr, g, b: red, green, blue\nc, m, y, k: cyan, magenta, yellow, black\nw: white\nf: color picker\n\nPEN SIZE:\n=: increase line-width\n-: decrease line-width\n\n')
	       alert('IMAGE:\np: reset image\n\nBACKGROUND OPACITY:\n`: clear background\n1 - 9: 0.1 - 0.9 opacity\n0: full opacity\n\nGRIDS:\nt: triangle grid\ns: square grid\nx: hexagonal grid\nd: square dots grid\n;: lined grid\n\nGRID COLOR:\nj: toggle white/black\nn: cycle through colors\n\nSLIDESHOW:\n(set theme to slideshow)\n.: forward one slide\n,: back one slide')
	       alert('CONSTRAINTS:\nUp: constrain to vertical line\nLeft: constrain to horizontal line\n/: constrain to parallel to line\nDown: constrain to vanishing point line\nRight: constrain to arc about vanishing point\nv: set vanishing point to mouse position\n\nTEXT:\na: enter text-mode\nesc: exit text-mode\n\nSHAPES\nq: draw rectangle\nl: draw line\ne: draw ellipse')
	       alert(`QUERY PARAMETERS: \ntitle: ${document.title}\ntheme: ${initialTheme}\nimage: ${imageURL}\nscreen: ${whiteboardState[SCREEN_SIZE].x} x ${whiteboardState[SCREEN_SIZE].y}\npens: ${query.pens || 'none'}\npenColor: ${pen.strokeStyle}\npenWidth: ${pen.lineWidth}\ngridColor: ${grid.strokeStyle}\ngridWidth: ${grid.lineWidth}\nbackgroundOpacity: ${currentBackgroundOpacity}\nbackground: ${background.fillStyle}\ncells: ${cells}\nzoom: ${zoom}\ngridtype: ${gridType}\neraseRadius: ${whiteboardState[ERASE_RADIUS]}`)
	       }
	       break; */
	  case 't':
	  case 'T':
	    if (!isTyping) {
	      lastTool = whiteboardState[TOOL]
	      setWhiteboardState(TOOL, TEXT)
	    
	      isTyping = true
	      drawTextCursor()
	    }
	    break;
	  case 'g':
	  case 'G':
	    whiteboardState[GRID_TYPE].setCoordinates((whiteboardState[GRID_TYPE].x + 1) % 3, whiteboardState[GRID_TYPE].y)
	    setGrid(whiteboardState[GRID_TYPE])
	    break;
	  case 'j':
	  case 'J':
	    whiteboardState[GRID_TYPE].setCoordinates(whiteboardState[GRID_TYPE].x, (whiteboardState[GRID_TYPE].y + 1) % 3)
	    setGrid(whiteboardState[GRID_TYPE])
	    break;
	  case 'i':
	  case 'I':
	    if (!isTyping) {
	      dom[WALLPAPER].style.background = `url(${getCollection(whiteboardState[SCREEN_SIZE])})`
	    }
	    break
	  case 's':
	  case 'S':
	    if (!isTyping) {
	      whiteboardState[
		SAVED_MARKS_DATA][query[MARKS_DATA] 
		  || prompt('Please name this data', 'untitled')
		] = dom[MARKS].toDataURL('image/png')
	      setWhiteboardState(SAVED_MARKS_DATA, whiteboardState[SAVED_MARKS_DATA])
	      console.log(`Saved ${query[MARKS_DATA]}`)
	    }
	    break
	  case '.':
	    if (!isTyping) {
	      slide++
		clearLayer(WALLPAPER)
	      setImage(slideshow[slide % slideshow.length], dom[WALLPAPER])
	      document.title = parseFilename(slideshow[slide % slideshow.length])
	    }
	    break
	  case ',':
	    if (!isTyping) {
	      slide--
		clearLayer(WALLPAPER)
	      setImage(slideshow[slide % slideshow.length], dom[WALLPAPER])
	      document.title = parseFilename(slideshow[slide % slideshow.length])
	    }
	    break
	  case '-':
	    if (!isTyping && layers[MARKS].lineWidth > 1) {
	      setBrushWidth(parseInt(whiteboardState[BRUSHES][whiteboardState[BRUSH]].width) - 1)
	      setWhiteboardState(BRUSHES, whiteboardState[BRUSHES])
	      setWhiteboardState(ERASE_RADIUS, whiteboardState[ERASE_RADIUS])
	    } 
	    break;
	  case '=':
	    if (!isTyping) {
	      setBrushWidth(parseInt(whiteboardState[BRUSHES][whiteboardState[BRUSH]].width) + 1)
	      setWhiteboardState(BRUSHES, whiteboardState[BRUSHES])
	      setWhiteboardState(ERASE_RADIUS, whiteboardState[ERASE_RADIUS])
	    }
	    break;
	  case '[':
	    if (!isTyping && whiteboardState[FONT_HEIGHT] > 0) {
	      setFontHeight(whiteboardState[FONT_HEIGHT] - 1)
	    }
	    break
	  case ']':
	    if (!isTyping && whiteboardState[FONT_HEIGHT] < 13) {
	      setFontHeight(whiteboardState[FONT_HEIGHT] + 1)
	    }
	    break
	  case '`':
	    if (!isTyping) {
	      lastTool = whiteboardState[TOOL]
	      whiteboardState[TOOL] = PALETTE
	      if (whiteboardState[BRUSH] !== 10) {
		setWhiteboardState(BRUSH, 10)
		layers[MARKS].lineWidth = whiteboardState[BRUSHES][whiteboardState[BRUSH]].width
		setColor(whiteboardState[BRUSHES][whiteboardState[BRUSH]].color, layers[MARKS])
	      }
	      [isPickingColor, dom[PALETTE].style.display] = [true, 'initial']
	    }
	    break
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    if (!isTyping) {
	      lastTool = whiteboardState[TOOL]
	      whiteboardState[TOOL] = PALETTE
	      if (parseInt(event.key) !== whiteboardState[BRUSH]) {
		setWhiteboardState(BRUSH, parseInt(event.key))
		layers[MARKS].lineWidth = whiteboardState[BRUSHES][whiteboardState[BRUSH]].width
		setColor(whiteboardState[BRUSHES][whiteboardState[BRUSH]].color, layers[MARKS])
	      }
	      [isPickingColor, dom[PALETTE].style.display] = [true, 'initial']
	    }
	    break
	  case 'v':
	  case 'V':
	    if (!isTyping) {
	      setVanishingPoint(whiteboardState[MOUSE_MOVE_LOCATION].x, whiteboardState[MOUSE_MOVE_LOCATION].y)
	    }
	    break
	  }
	
	}	
	keyIsDown = true
      })

      window.addEventListener("keydown", function (event) {
	if (event.defaultPrevented) {
	  return; // Do nothing if the event was already processed
	}
	switch (event.key) {
	case 'ArrowRight':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = ARC
	  } 
	  break
	case 'ArrowUp':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = VERTICAL
	  } else { 
	   whiteboardState[PRINT_HEAD_LOCATION].y -= whiteboardState[LINE_SPACING]
	    drawTextCursor()
	  }
	  break
	case 'ArrowLeft':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = HORIZONTAL
	  } else { 
	   whiteboardState[PRINT_HEAD_LOCATION].x -= whiteboardState[FONT_WIDTH]
	    drawTextCursor()
	  }
	  break
	case 'ArrowDown':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = VANISHING
	  } else { 
	   whiteboardState[PRINT_HEAD_LOCATION].y += whiteboardState[LINE_SPACING]
	    drawTextCursor()
	  }
	  break
	case 'Control':
	  if (!isTyping) {
	    constraint = [
	      COMMITTED, 
	      VERTICAL_HORIZONTAL, 
	      HEXAGONAL, 
	      DIAGONAL, 
	      DOZENAL
	    ][
	      [RECTANGLE, ELLIPSE].includes(whiteboardState[TOOL]) 
		? 3
		: whiteboardState[TOOL] === LINE 
		  ? 4
		  : whiteboardState[GRID_TYPE].x
	    ]
	    if (constraint === COMMITTED) {
	      whiteboardState[TOOL] = COMMITTED
	    }
	  }
	  break
	case 'Shift':
	  if (!isTyping) {
	    shiftIsDown = true
	  }
	  break
	case '/':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = PARALLEL
	  } else { 
	   whiteboardState[PRINT_HEAD_LOCATION].x += whiteboardState[FONT_WIDTH]
	    drawTextCursor()
	  }
	  break
	case 'p':
	case 'P':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, PAINT_BRUSH)
	    lastTool = PAINT_BRUSH
	  }
	  break
	case 'r':
	case 'R':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, RECTANGLE)
	    lastTool = RECTANGLE
	  }
	  break
	case 'e':
	case 'E':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, ELLIPSE)
	    lastTool = ELLIPSE
	  }
	  break
	case 'l':
	case 'L':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, LINE)
	    lastTool = LINE
	  }
	  break
	case 'm':
	case 'M':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, MEASURE)
	    lastTool = MEASURE
	  }
	  break
	case 'f':
	case 'F':
	  setWhiteboardState(FILL_ACTIVE, !whiteboardState[FILL_ACTIVE])
	  break
	case ' ':
	  event.preventDefault()
	  if (!isTyping) {
	    spaceIsDown = true;
	  }
	  break
	case 'Escape':
	  mouseIsDown = false
	  isDrawing = false
	  isDrawingRectangle = false
	  isDrawingEllipse = false
	  isDrawingLine = false
	  isErasing = false
	  isTyping = false
	  if (lastTool !== undefined) {
	    whiteboardState[TOOL] = lastTool
	  } else {
	    whiteboardState[TOOL] = defaultState[TOOL]
	  }
	  clearLayer(TOOLS)
	  break
	case 'Backspace':
	  if (!isTyping) {
	    clearLayer(MARKS)
	  } else {
	   whiteboardState[PRINT_HEAD_LOCATION].x -= whiteboardState[FONT_WIDTH]
	    layers[MARKS].clearRect(
	     whiteboardState[PRINT_HEAD_LOCATION].x, 
	     whiteboardState[PRINT_HEAD_LOCATION].y - fontSizes[whiteboardState[FONT_HEIGHT]], 
	      whiteboardState[FONT_WIDTH], 
	      fontSizes[whiteboardState[FONT_HEIGHT]] * 1.21
	    )
	    drawTextCursor()
	  }
	  break
	case 'Enter':
	  if (isTyping) {
	   whiteboardState[PRINT_HEAD_LOCATION].x = whiteboardState[MOUSE_DOWN_LOCATION].x
	   whiteboardState[PRINT_HEAD_LOCATION].y += whiteboardState[LINE_SPACING]
	    drawTextCursor()
	  }
	}
      });

      window.addEventListener("keyup", function (event) {
	if (event.defaultPrevented) {
	  return; // Do nothing if the event was already processed
	}

	switch (event.key) {
	case ' ':
	  spaceIsDown = false
	  break
	case 'ArrowRight':
	case 'ArrowUp':
	case 'ArrowLeft':
	case 'ArrowDown':
	case '/':
	case 'Control':
	  if (constraint === COMMITTED) {
	      whiteboardState[TOOL] = lastTool
	  }
	  constraint = NONE
	  break
	case '`':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  whiteboardState[TOOL] = lastTool
	  isPickingColor = false
	  dom[PALETTE].style.display = 'none'
	  break
	case 'Shift':
	  if (!isTyping) {
	    shiftIsDown = false
	  }
	  break
	}
	keyIsDown = false
      })

      // INITIALIZATION
      let isDrawing = false
      let isErasing = false
      let isBoxErasing = false
      let isCopying = false
      let isPickingColor = false
      let clipboard
      let isDrawingRectangle = false
      let isDrawingLine = false
      let isTyping = false
      let constraint = NONE
      let currentMouse

      const query = parseQueryString(window.location.href)
      const whiteboardState = {}
      whiteboardState[SCREEN_SIZE] = query[SCREEN_SIZE] 
	? new Vector2(query[SCREEN_SIZE]) 
	: new Vector2(window.screen.width, window.screen.height)
      whiteboardState[BOARD_SIZE] = query[BOARD_SIZE]
	? new Vector2(query[BOARD_SIZE]) 
	: new Vector2(
	  whiteboardState[SCREEN_SIZE].x * defaultState[BOARD_SCALE].x,
	  whiteboardState[SCREEN_SIZE].y * defaultState[BOARD_SCALE].y
	)
      whiteboardState[WALLPAPER_IMAGE] = query[WALLPAPER_IMAGE] || getCollection(whiteboardState[SCREEN_SIZE])
      Object.assign(
	whiteboardState, 
	{
	  ...defaultState,
	  ...JSON.parse(localStorage.getItem(WHITEBOARD_STATE)),
	  ...whiteboardState,
	  ...query
	}
      )

      whiteboardState[ANGLE] = Number(whiteboardState[ANGLE])
      whiteboardState[BRUSH] = Number(whiteboardState[BRUSH])
      whiteboardState[ERASE_RADIUS] = Number(whiteboardState[ERASE_RADIUS])
      whiteboardState[GRID_WIDTH] = Number(whiteboardState[GRID_WIDTH])
      whiteboardState[ZOOM] = Number(whiteboardState[ZOOM])
      whiteboardState[VANISHING_POINT] = new Vector2(whiteboardState[VANISHING_POINT])
      whiteboardState[MOUSE_DOWN_LOCATION] = new Vector2(whiteboardState[MOUSE_DOWN_LOCATION])
      whiteboardState[MOUSE_MOVE_LOCATION] = new Vector2(whiteboardState[MOUSE_MOVE_LOCATION])
      whiteboardState[MOUSE_UP_LOCATION] = new Vector2(whiteboardState[MOUSE_UP_LOCATION])
      whiteboardState[PRINT_HEAD_LOCATION] = new Vector2(whiteboardState[PRINT_HEAD_LOCATION])
      whiteboardState[MEASUREMENT] = new Vector2(whiteboardState[MEASUREMENT])
      whiteboardState[OVERLAY_COLOR] = new Color(whiteboardState[OVERLAY_COLOR])
      whiteboardState[GRID_COLOR] = new Color(whiteboardState[GRID_COLOR])
      whiteboardState[GRID_TYPE] = new Vector2(whiteboardState[GRID_TYPE])
      whiteboardState[SQUARE_GRID_UNITS] = new Vector2(whiteboardState[SQUARE_GRID_UNITS])
      whiteboardState[BRUSHES].forEach((brush) => {
	brush.color = new Color(brush.color)
      })
      whiteboardState[FUNCTIONS] = []
      let lastTool = whiteboardState[TOOL]

      dom[PROBLEM].style.display = 'none'
      dom[PALETTE].style.display = 'none'
      layers[MARKS].lineJoin = 'round'
      layers[MARKS].lineCap = 'round'
      applyState(whiteboardState)

      document.title = query[DOCUMENT_TITLE] || query[MARKS_DATA] || 'Whiteboard' 
      /* || query[MARKS_IMAGE] 
	 ? parseFilename(query[MARKS_IMAGE]) 
	 : query[WALLPAPER_IMAGE] 
	 ? parseFilename(query[WALLPAPER_IMAGE]) 
	 : 'Whiteboard' */
      query[MARKS_IMAGE] && setImage(query[MARKS_IMAGE], layers[MARKS])
      
      console.log(`Wallpaper Image: ${whiteboardState[WALLPAPER_IMAGE]}`)
      if (query[PROBLEM_IMAGE]) {
	const problemImg = document.createElement('img')
	problemImg.src = query[PROBLEM_IMAGE]
	  dom[PROBLEM].appendChild(problemImg)	
      }
      if (whiteboardState[TOOL] === TEXT) {
	drawTextCursor()
	isTyping = true
      } else if (whiteboardState[TOOL] === COMMITTED 
	|| whiteboardState[TOOL] === PALETTE) {
	whiteboardState[TOOL] = PAINT_BRUSH
      }
      if (whiteboardState[SAVED_MARKS_DATA][query[MARKS_DATA]]) {
	setImage(whiteboardState[SAVED_MARKS_DATA][query[MARKS_DATA]], layers[MARKS])
      }
    </script>
  </body>
</html>
