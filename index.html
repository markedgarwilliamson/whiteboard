<!DOCTYPE html>
<!-- Begin license text.
     Copyright 2019 DAVID WILLIAMSON
     Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     End license text. -->
<html lang="en">
  <head>
	  	<title>David's Great Whiteboard App</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, height=device-height initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="apple-mobile-web-app-capable" content="yes" /> 
    <style> 
     body {
       font-family: 'Courier New';
     }

     body::-webkit-scrollbar { 
       display: none;
     }

     .time {
       display: none;
       justify-content: space-around;
       align-items: center;
       position: fixed;
     }

     #DAYS {
       height: 40px;
       left: 80px;
     }

     #HOURS {
       flex-direction: column;
       width: 80px;
       top: 40px;
     }

     #HOURS p {
       margin: 0;
     }
    </style> 
  </head>
  <body style="margin: 0; cursor: crosshair; position: absolute;">
    <div id="WALLPAPER"></div>
    <div id="OVERLAY" style="position: absolute; left: 0px; top: 0px; z-index: 2;"></div>
    <div id="GRID" style="position: absolute; left: 0px; top: 0px; z-index: 4;"></div>
    <div id="PROBLEM" style="position: absolute; left: 0px; top: 0px; z-index: 5;"></div>
    <canvas id="MARKS" style="position: absolute; left: 0px; top: 0px; z-index: 6;"></canvas>
    <canvas id="PALETTE" style="position: fixed; left: 0px; top: 0px; z-index: 7;"></canvas>
    <div id="TOOLS" style="position: absolute; left: 0px; top: 0px; z-index: 8;">
      <div id="HOURS" class="time"></div>
      <div id="DAYS" class="time"></div>
    </div>
    <div id="SENSOR" style="position: absolute; left: 0px; top: 0px; z-index: 9;"></div>
    
    <script>
      // CLASSES
      class Color {
	constructor(shade, alpha) {
	  const arrayToRgb = (arr) => {
	    this.red = arr[0]
	    this.green = arr[1]
	    this.blue = arr[2]
	  }

	  const rgbToHsl = (red, green, blue) => {
	    const cMax = Math.max(red, green, blue)
	    const cMin = Math.min(red, green, blue)
	    const delta = cMax - cMin

	    this.lum = (cMax + cMin) / 510
	    this.sat = delta === 0 ? 0 : delta / ((1 - Math.abs(2 * this.lum - 1)) * 255)	

	    switch (true) {
	    case (delta === 0):
	      this.hue = 0
	      break
	    case (cMax === red):
	      this.hue = 60 * (((green - blue) / delta) % 6)
	      break
	    case (cMax === green):
	      this.hue = 60 * (((blue - red) / delta) + 2)
	      break
	    case (cMax === blue):
	      this.hue = 60 * (((red - green) / delta) + 4)
	    }
	    this.hue = (this.hue + 360) % 360
	  }
	  
	  const hslToRgb = (hue, sat, lum) => {
	    const c = (1 - Math.abs(2 * lum - 1)) * sat
	    const x = c * (1 - Math.abs((hue / 60) % 2 - 1))
	    const m = lum - c / 2

	    let rgb
	    switch (true) {
	    case (hue >= 0 && hue < 60):
	      rgb = [c, x, 0]
	      break
	    case (hue >= 60 && hue < 120):
	      rgb = [x, c, 0]
	      break
	    case (hue >= 120 && hue < 180):
	      rgb = [0, c, x]
	      break
	    case (hue >= 180 && hue < 240):
	      rgb = [0, x, c]
	      break
	    case (hue >= 240 && hue < 300):
	      rgb = [x, 0, c]
	      break
	    case (hue >= 300 && hue <= 360):
	      rgb = [c, 0, x]
	      break
	    }
	    arrayToRgb(rgb.map((channel) => Math.round((channel + m) * 255)))
	  }

	  let colorArray = []
	  if (typeof shade === 'string') {
	    if (!/^#/.test(shade)) {
	      colorArray = mapStringToNumberArray(shade)
	    }
	    
	    if (/^hsl/.test(shade)) {
	      this.hue = parseInt(colorArray[0])
	      this.sat = parseInt(colorArray[1]) / 100
	      this.lum = parseInt(colorArray[2]) / 100
	
	      hslToRgb(this.hue, this.sat, this.lum)
	    } else {
	      if (/^#/.test(shade)) {
		this.red = parseInt(shade.slice(1, 3), 16)
		this.green = parseInt(shade.slice(3, 5), 16)
		this.blue = parseInt(shade.slice(5, 7), 16)
	      } else {
		arrayToRgb(colorArray)
	      }
	      
	      rgbToHsl(this.red, this.green, this.blue)
	    }
	  } else if (Array.isArray(shade)) {
	    colorArray = shade
	    arrayToRgb(colorArray)
	    rgbToHsl(this.red, this.green, this.blue)
	  } else if (typeof shade === 'object') {
	    Object.assign(this, shade)
	  }
	  if (colorArray[3] !== undefined) {
	    this.alpha = parseFloat(colorArray[3])
	  } else {
	    if (this.alpha === undefined) {
	      this.alpha = alpha || 1.0
	    }
	  }
	}

	getHexadecimal () {
	  return `#${this.red.toString(16).padStart(2,'0').toUpperCase()}${this.green.toString(16).padStart(2,'0').toUpperCase()}${this.blue.toString(16).padStart(2,'0').toUpperCase()}`
	}

	getRgb () {
	  return `rgba(${this.red}, ${this.green}, ${this.blue})`
	}

	getRgba () {
	  return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`
	}

	getHsl () {
	  return `hsl(${this.hue}, ${Math.round(this.sat * 100)}%, ${Math.round(this.lum * 100)}%)`
	}

	getHsla () {
	  return `hsla(${this.hue}, ${Math.round(this.sat * 100)}%, ${Math.round(this.lum * 100)}%, ${this.alpha})`
	}

	getPixelData () {
	  return [this.red, this.green, this.blue, Math.round(this.alpha * 255)]
	}

	modify (color) {
	  const temporaryShade = new Color(this)
	  if (color.hasOwnProperty('red') || color.hasOwnProperty('blue') || color.hasOwnProperty('green')) {
	    Object.assign(temporaryShade, color)
	    Object.assign(this, new Color(temporaryShade.getRgba()))
	  } if (color.hasOwnProperty('hue') || color.hasOwnProperty('sat') || color.hasOwnProperty('lum')) {
	    Object.assign(temporaryShade, color)
	    Object.assign(this, new Color(temporaryShade.getHsla()))
	  } else {
	    Object.assign(this, color)
	  }
	  return this
	}
      }

      class Vector2 {
	constructor(a, b) {
	  let x
	  let y
	  if (typeof a === 'object') {
	    if (a.hasOwnProperty('x') && a.hasOwnProperty('y')) {
	      [x, y] = [a.x, a.y]
	    } else if (a.hasOwnProperty('angle')) {
	      const magnitude = a.magnitude || 1
	      x = Math.cos(a.angle) * magnitude
	      y = Math.sin(a.angle) * magnitude
	    }
	  } else {
	    [x, y] = [a, b]
	  }
	  this.setCoordinates(x, y)
	}
	
	setCoordinates (x, y) {
	  if (typeof x === 'string') {
	    x = mapStringToNumberArray(x)
	  }
	  if (typeof x === 'object') {
	    if (Array.isArray(x)) {
	      Object.assign(this, {
		x: x[0],
		y: x[1]
	      })
	    } else {
	      Object.assign(this, x)
	    }
	  } else {
	    Object.assign(this, { x, y })
	  }
	}
	
	setSquareUnits (x, y) {
	  if (typeof x === 'string') {
	    x = mapStringToNumberArray(x)
	  }
	  if (typeof x === 'object') {
	    if (Array.isArray(x)) {
	      Object.assign(this, {
		x: x[0],
		y: x[1]
	      })
	    } else {
	      Object.assign(this, x.scale(wState[SQUARE_GRID_UNITS]))
	    }
	  } else {
	    Object.assign(this, { 
	      x: x * wState[SQUARE_GRID_UNITS].x,
	      y: y * wState[SQUARE_GRID_UNITS].y
	    })
	  }
	}
	
	setHexUnits (x, y) {
	  if (typeof x === 'string') {
	    x = mapStringToNumberArray(x)
	  }
	  if (typeof x === 'object') {
	    if (Array.isArray(x)) {
	      Object.assign(this, {
		x: x[0],
		y: x[1]
	      })
	    } else {
	      Object.assign(this, x.scale(wState[HEX_GRID_UNIT]))
	    }
	  } else {
	    Object.assign(this, { 
	      x: x * wState[HEX_GRID_UNIT],
	      y: y * wState[HEX_GRID_UNIT]
	    })
	  }
	}

	getSquareUnits () {
	  return new Vector2(
	    this.x / wState[SQUARE_GRID_UNITS].x,
	    this.y / wState[SQUARE_GRID_UNITS].y
	  )
	}

	getHexUnits () {
	  return new Vector2(
	    this.x / wState[HEX_GRID_UNIT],
	    this.y / wState[HEX_GRID_UNIT]
	  )
	}

	copy () {
	  return new Vector2(this.x, this.y);
	}

	add (v) {
	  return new Vector2(this.x + v.x, this.y + v.y);
	}

	scale (s) {
	  if (typeof s === 'number') {
	    s = new Vector2(s, s)
	  }
	  return new Vector2(this.x * s.x, this.y * s.y)
	}

	getMagnitude () {
	  return (this.x ** 2 + this.y ** 2) ** 0.5
	}

	getDistance (v) {
	  if (!v) {
	    v = new Vector2(0, 0)
	  }
	  return ((this.x - v.x)**2 + (this.y - v.y)**2)**0.5;
	}

	getAngle (v) {
	  if (!v) {
	    v = new Vector2(0, 0)
	  }
	  if (this.x === v.x) {
	    return this.y > v.y 
	      ? Math.PI / 2 
	      : Math.PI * 3 / 2
	  } else {
	    let a = Math.atan((this.y - v.y) / (this.x - v.x))
	    if (this.x < v.x) {
	      a += Math.PI
	    } else if (this.y < v.y) {
	      a += 2 * Math.PI
	    }
	    return a % (2 * Math.PI)
	  }
	}

	getPolarCoordinates () {
	  return {
	    angle: this.getAngle(),
	    magnitude: this.getDistance()
	  }
	}

	normalize (s) {
	  if (!s) {s = 1;}
	  return this.mult(1/this.mag()).mult(s)
	}

	transform (matrix) {
	  return new Vector2(this.x*matrix.a + this.y*matrix.b, this.x*matrix.c + this.y*matrix.d);
	}

	/* getSize () {
	   return this.transform(flipVert).scale(unit);
	   } */

	/* pix () {
	   return this.getSize().add(center);
	   } */

	/* units () {
	   return this.add(center.scale(-1)).scale(1/unit).transform(flipVert);
	   } */

	/* draw (ctx, fv, max) {
	   if (!max) {max = vectorSpacing;}
	   var sv = this.normalize(3); // used to draw the arrowhead.
	   var tv = this.normalize(vectorSpacing*this.mag()/max).size();
	   if (fv) {
	   fv = fv.pix();
	   } else {
	   fv = center;
	   }
	   tv = tv.add(fv);
	   drawLine(ctx, fv, tv, '#000000');
	   drawLine(ctx, tv, {'x': tv.x - sv.x + sv.y, 'y': tv.y + sv.x + sv.y}, '#000000');
	   drawLine(ctx, tv, {'x': tv.x - sv.x - sv.y, 'y': tv.y - sv.x + sv.y}, '#000000');
	   } */
      }

      // UTILITIES
      const bound = (value, min=0.0, max=1.0) => {
	return value < min 
	  ? min 
	  : value > max 
	    ? max 
	    : value
      }

      const parseFilename = (name) => name.split('/').pop().split('.').slice(0, -1).join('.')
      const tabTitle = (paths) => {
	let names = []
	for (path of paths) {
	  names.push(parseFilename(path))
	}
	return names.join(', ')
      }

      const mapStringToNumberArray = (s) => {
	return s.match(/[+-]?([0-9]*[.])?[0-9]+/g)
	  .map((element) => Number(element))
      }

      const parseQueryString = (url) => {
	const queryString = /\?/.test(url) && url.substring(url.search(/\?/) + 1)
	if (queryString) {
	  return queryString.split('&').reduce(
	    (query, pair) => {
	      const [param, input] = pair.split('=')
	      let value = input
	      if (param.includes('active')) {
		if (/(false|0)/.test(input)) {
		  value = false
		} else {
		  value = new Boolean(input)
		}
	      } else if (!param.includes('image') && /[+-]?([0-9]*[.])?[0-9]+/g.test(input)) {
		value = mapStringToNumberArray(value)
		value = value.length === 2 
		  ? { x: value[0], y: value[1] } 
		  : value.length === 1 
		  ? value[0] 
		  : value
	      }
	      query[param.replace(/-/g, '_').toUpperCase()] = value
	      return query
	    },
	    {}
	  )
	}
	return {}
      }

      const getCollection = (size, query) => {
	const collection = query ? query.collection : unsplashCollections[Math.floor((Math.random() * unsplashCollections.length))]
	return `https://source.unsplash.com/collection/${collection}/${size.x}x${size.y}`
      }

      const setWhiteboardState = (key, value) => { 
	if (value !== undefined) {
	  wState[key] = value
	}
	localStorage.setItem(
	  WHITEBOARD_STATE, 
	  JSON.stringify(wState)
	)
	return value
      }

      const applyState = (state) => {
	document.title = state[DOCUMENT_TITLE]

	for (element in dom) {	
	  if (dom[element].nodeName === 'DIV') {
	    [
	      dom[element].style.width, 
	      dom[element].style.height
	    ] = [
	      `${(state[BOARD_SIZE].x).toString()}px`, 
	      `${(state[BOARD_SIZE].y).toString()}px`
	    ]
	  } else {
	    [
	      dom[element].width, 
	      dom[element].height
	    ] = [
	      state[BOARD_SIZE].x, 
	      state[BOARD_SIZE].y
	    ]
	  }
	}
	setImage(WALLPAPER, state[WALLPAPER_IMAGE])
	setColor(state[OVERLAY_COLOR], dom[OVERLAY])
	setColor(state[GRID_COLOR], layers[GRID])
	setGrid(state[GRID_TYPE])
	for (let layer of [GRID, TOOLS]) {
	  layers[layer].setAttribute('width', state[BOARD_SIZE].x.toString())
	  layers[layer].setAttribute('height', (state[BOARD_SIZE].y).toString())
	  layers[layer].setAttribute('viewBox', `0 0 ${state[BOARD_SIZE].x} ${state[BOARD_SIZE].y}`)
	  layers[layer].setAttribute('xmlns', svgNameSpace)
	}
	setImage(PROBLEM, state[PROBLEM_IMAGE], { margin: '2rem'})
	if (query[PROBLEM_ACTIVE]) {
	  dom[PROBLEM].style.display = 'initial'
	} else {
	  dom[PROBLEM].style.display = 'none'
	}
	
	// initialize planner headers
	Object.assign(daysElement.style, {
	  color: state[GRID_COLOR].getRgba(),
	  background: state[TOOLS_COLOR].getRgba()
	})
	Object.assign(hoursElement.style, {
	  color: state[GRID_COLOR].getRgba(),
	  background: state[TOOLS_COLOR].getRgba(),
	  height: `${wState[BOARD_SIZE].y  - 40}px`
	})
	for (let day of weekdays) {
	  const span = document.createElement('span')
	  span.innerHTML = day
	  daysElement.appendChild(span)
	}
	for (let hour = 0; hour < 24; hour ++) {
	  const p1 = document.createElement('p')
	  const p2 = document.createElement('p')
	  p1.innerHTML = `${((hour + 6) % 24).toString().padStart(2, '0')}:00`
	  p2.innerHTML = `${((hour + 6) % 24).toString().padStart(2, '0')}:30`
	  hoursElement.appendChild(p1)
	  hoursElement.appendChild(p2)
	}
	setGrid()
	setBrushWidth(state[BRUSHES][state[BRUSH]].width)
	setFontHeight(state[FONT_HEIGHT])
	setColor(state[BRUSHES][state[BRUSH]].color, layers[MARKS])
      }

      const readPalette = (pixelLocation, c, sideLength=colorWheelSideLength) => {
	const color = new Color(c)
	const prop = {}
	const wheelCenter = new Vector2(
	  sideLength * 7 / 16, 
	  sideLength * 7 / 16
	)
	const distance = pixelLocation.getDistance(wheelCenter)
	let { hue, sat, lum, alpha } = color
	if (distance <= sideLength * 7 / 16) {
	  if(distance > sideLength * 1 / 16) {
	    hue = 360 - (pixelLocation.getAngle(wheelCenter) * 180 / Math.PI)
	  }
	  prop.sat = sat = bound((distance - (sideLength * 1 / 16)) * 4 / sideLength)
	} else if (
	  (pixelLocation.x > wheelCenter.x || pixelLocation.y > wheelCenter.y) 
	    && distance > sideLength * 7 / 16
	) {
	  if (pixelLocation.x < pixelLocation.y) {
	    prop.alpha = alpha = bound((((pixelLocation.x - (sideLength * 3 / 16)) / 2) * 4 / sideLength))
	  } else {
	    prop.lum = lum = bound((((sideLength / 2) - (pixelLocation.y - (sideLength * 3 / 16))) / 2) * 4 / sideLength)
	  }
	}
	return {
	  color: new Color(`hsla(${hue}, ${sat * 100}%, ${lum * 100}%, ${alpha})`),
	  prop: prop
	}
      }

      const displayImg = (context, obj) => {
	if (!obj.complete){
	  setTimeout(() => {
	    displayImg(context, obj);
	  }, 50);
	  return;
	}

	/* if (wState[ZOOM] < 2) {
	   let scale;
	   let z = [
	   wState[SCREEN_SIZE].y / wState[SCREEN_SIZE].x > obj.naturalHeight / obj.naturalWidth,
	   wState[SCREEN_SIZE].y / wState[SCREEN_SIZE].x < obj.naturalHeight / obj.naturalWidth
	   ][wState[ZOOM]]
	   if (z) {
	   scale = wState[SCREEN_SIZE].x / obj.naturalWidth
	   } else {
	   scale = wState[SCREEN_SIZE].y / obj.naturalHeight
	   }
	   
	   context.drawImage(obj,
	   (wState[SCREEN_SIZE].x - obj.naturalWidth * scale) / 2,
	   (wState[SCREEN_SIZE].y - obj.naturalHeight * scale) / 2,
	   obj.naturalWidth * scale,
	   obj.naturalHeight * scale
	   )
	   } else {
	   let scale = wState[SCREEN_SIZE].y / wState[SCREEN_SIZE].x < obj.naturalHeight / obj.naturalWidth 
	   ? wState[SCREEN_SIZE].x / obj.naturalWidth 
	   : wState[SCREEN_SIZE].y / obj.naturalHeight
	   if (wState[ZOOM] > 2) {
	   scale = 1
	   }
	   for (let layer in canvas) {
	   canvas[layer].width = wState[SCREEN_SIZE].x = obj.naturalWidth * scale
	   canvas[layer].height = wState[SCREEN_SIZE].y = obj.naturalHeight * scale
	   } */
	  context.drawImage(obj, 0, 0, wState[BOARD_SIZE].x, wState[BOARD_SIZE].y)
      }

      const setImage = (layer, src, style) => {
	if (dom[layer].nodeName === 'DIV') {
	  if (layer === WALLPAPER) {
	    dom[WALLPAPER].style.background = `url(${src})`
	    dom[WALLPAPER].style.backgroundAttachment = 'fixed'
	    dom[WALLPAPER].style.backgroundRepeat = 'no-repeat'
	    dom[WALLPAPER].style.backgroundSize = `${wState[SCREEN_SIZE].x}px ${wState[SCREEN_SIZE].y}px`
	  } else {
	    img = document.createElement('img')
	    img.src = src
	    if (style) {
	      Object.assign(img.style, style)
	    } else {
	      img.width = wState[SCREEN_SIZE].x
	    }
	    dom[layer].appendChild(img)
	  }
	} else {
	  imageURL = src
	  if (typeof src === 'object' && src.data.includes('data:image/png;base64')) {
	    console.log(`marks-image: ${src.name}`)
	  } else if (src.includes('collection')) {
	    if (navigator.onLine) {
	      console.log(`collection: ${src.split('/')[4]}`)
	    } else {
	      setColor('#7F7F7F', dom[WALLPAPER])
	      console.log('currently offline')
	      return
	    }
	  }
	  clearLayer(layer)
	  let img = new Image()
	  img.src = src
	  displayImg(layers[layer], img)
	  layers[layer].drawImage(img, 0, 0, wState[BOARD_SIZE].x, wState[BOARD_SIZE].y)
	}
      }

      const clearLayer = (input) => {
	const layer = typeof input === 'string' ?  layers[input] : input
	if (layer.nodeName === 'svg') {
	  layer.innerHTML = ''
	} else if (layer.nodeName !== 'DIV') {
	  layer.clearRect(
	    0, 
	    0, 
	    wState[BOARD_SIZE].x, 
	    wState[BOARD_SIZE].y
	  )
	}
      }

      const logMarksData = () => {
	const names = []
	for (let name in wState[SAVED_MARKS_DATA]) {
	  names.push(name)
	}
	return names
      }
      
      const clearMarksData = (name) => {
	if (name) {
	  delete wState[SAVED_MARKS_DATA][name]
	  setWhiteboardState(SAVED_MARKS_DATA)
	} else {
	  setWhiteboardState(SAVED_MARKS_DATA, {})
	}
      }

      // STATIC VARIABLES
      // MAGIC STRINGS
      const WHITEBOARD_STATE = 'WHITEBOARD_STATE'
      const PAINT_BRUSH = 'PAINT_BRUSH' // p
      const ELLIPSE = 'ELLIPSE' // e
      const RECTANGLE = 'RECTANGLE' // r
      const LINE = 'LINE' // l
      const ARC = 'ARC' // a
      const TEXT = 'TEXT' // t
      const ERASER = 'ERASER' // spacebar (held)
      const BOX_ERASER = 'BOX_ERASER' // x
      const MEASURE = 'MEASURE' // m
      const PALETTE = 'PALETTE' // `, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 (held)
      
      const WALLPAPER = 'WALLPAPER'
      const OVERLAY = 'OVERLAY'
      const GRID = 'GRID'
      const PROBLEM = 'PROBLEM'
      const TOOLS = 'TOOLS'
      const DAYS = 'DAYS'
      const HOURS = 'HOURS'
      const TIME_PADDING = 'TIME_PADDING'
      const TIME_UNITS = 'TIME_UNITS'
      const MARKS = 'MARKS'
      const SENSOR = 'SENSOR'

      const DOCUMENT_TITLE = 'DOCUMENT_TITLE' // String
      const SCREEN_SIZE = 'SCREEN_SIZE' // Vector2 *
      const BOARD_SIZE = 'BOARD_SIZE' // Vector2 *
      const BOARD_SCALE = 'BOARD_SCALE' // Vector2 *
      const WALLPAPER_IMAGE = 'WALLPAPER_IMAGE' // String, not stored
      const ZOOM = 'ZOOM' // Number
      const OVERLAY_COLOR = 'OVERLAY_COLOR' // Color *
      const GRID_TYPE = 'GRID_TYPE'
      const SQUARE_GRID_UNITS = 'SQUARE_GRID_UNITS'
      const HEX_GRID_UNIT = 'HEX_GRID_UNIT'
      const GRID_COLOR = 'GRID_COLOR'
      const GRID_WIDTH = 'GRID_WIDTH'
      const PROBLEM_IMAGE = 'PROBLEM_IMAGE' // String
      const PROBLEM_ACTIVE = 'PROBLEM_ACTIVE' // Boolean
      const VANISHING_POINT = 'VANISHING_POINT' // Vector2 *
      const TOOL = 'TOOL' // String, not stored
      const TOOLS_COLOR = 'TOOLS_COLOR'
      const MARKS_IMAGE = 'MARKS_IMAGE' // String, not stored
      const BRUSH = 'BRUSH' // Number
      const BRUSHES = 'BRUSHES' // Object { width: Number, color: Color * }
      const FONT = 'FONT' // string
      const FONT_HEIGHT = 'FONT_HEIGHT' // number
      const FONT_WIDTH = 'FONT_WIDTH' // number
      const LINE_SPACING = 'LINE_SPACING' // number
      const FILL_ACTIVE = 'FILL_ACTIVE' // Boolean
      const ANGLE = 'ANGLE' // Number
      const ERASE_RADIUS = 'ERASE_RADIUS' // Number
      const MOUSE_DOWN_LOCATION = 'MOUSE_DOWN_LOCATION' // Vector2 *
      const MOUSE_MOVE_LOCATION = 'MOUSE_MOVE_LOCATION' // Vector2 *
      const MOUSE_UP_LOCATION = 'MOUSE_UP_LOCATION' // Vector2 *
      const PRINT_HEAD_LOCATION = 'PRINT_HEAD_LOCATION' // Vector2 *
      const MEASUREMENT = 'MEASUREMENT' // Vector2 *
      const FUNCTIONS = 'FUNCTIONS' // temporary array
      const MARKS_DATA = 'MARKS_DATA' // String
      const SAVED_MARKS_DATA = 'SAVED_MARKS_DATA' // Object: { <name>: <dataURI> }
      const SAVE_PROMPT_ACTIVE = 'SAVE_PROMPT_ACTIVE' // Boolean

      const NONE = 'NONE'
      const VANISHING = 'VANISHING'
      const HORIZONTAL = 'HORIZONTAL'
      const VERTICAL = 'VERTICAL'
      const PARALLEL = 'PARALLEL'
      const DOZENAL = 'DOZENAL'
      const VERTICAL_HORIZONTAL  = 'VERTICAL_HORIZONTAL '
      const HEXAGONAL = 'HEXAGONAL'
      const DIAGONAL = 'DIAGONAL'
      const COMMITTED = 'COMMITTED'
      const COMMIT_RADIUS = 'COMMIT_RADIUS'

      const dom = {}
      dom[WALLPAPER] = document.getElementById(WALLPAPER)
      dom[OVERLAY] = document.getElementById(OVERLAY)
      dom[GRID] = document.getElementById(GRID)
      dom[PROBLEM] = document.getElementById(PROBLEM)
      dom[PALETTE] = document.getElementById(PALETTE)
      dom[TOOLS] = document.getElementById(TOOLS)
      daysElement = document.getElementById(DAYS)
      hoursElement = document.getElementById(HOURS)
      dom[MARKS] = document.getElementById(MARKS)
      dom[SENSOR] = document.getElementById(SENSOR)
      
      const layers = {}
      layers[PALETTE] = dom[PALETTE].getContext('2d')
      layers[MARKS] = dom[MARKS].getContext('2d')
      const svgNameSpace = 'http://www.w3.org/2000/svg'
      layers[GRID] = document.createElementNS(svgNameSpace, 'svg')
      dom[GRID].appendChild(layers[GRID])
      layers[TOOLS] = document.createElementNS(svgNameSpace, 'svg')
      dom[TOOLS].appendChild(layers[TOOLS])

      const constraints = {}
      constraints[COMMITTED] = constraints[NONE] = (toolLocation) => toolLocation
      constraints[VANISHING] = (toolLocation) => constrainLine(wState[VANISHING_POINT], wState[MOUSE_DOWN_LOCATION], toolLocation)
      constraints[ARC] = (toolLocation) => constrainArc(wState[VANISHING_POINT], wState[MOUSE_DOWN_LOCATION], toolLocation)
      constraints[HORIZONTAL] = (toolLocation) => new Vector2(toolLocation.x, wState[MOUSE_DOWN_LOCATION].y)
      constraints[VERTICAL] = (toolLocation) => new Vector2(wState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
      constraints[PARALLEL] = (toolLocation) => constrainLine(
	wState[MOUSE_DOWN_LOCATION].add(new Vector2(
	  Math.cos(wState[ANGLE]), 
	  Math.sin(wState[ANGLE])
	)),
	wState[MOUSE_DOWN_LOCATION],
	toolLocation
      )
      constraints[DOZENAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case (angle > Math.PI * 23 / 24) || (angle <= Math.PI / 24):
	  return new Vector2(toolLocation.x, wState[MOUSE_DOWN_LOCATION].y)
	  break
	case (angle > Math.PI / 24) && (angle <= Math.PI * 3 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 12 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 3 / 24) && (angle <= Math.PI * 5 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 6 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 5 / 24) && (angle <= Math.PI * 7 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 4 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 7 / 24) && (angle <= Math.PI * 9 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 3 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 9 / 24) && (angle <= Math.PI * 11 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 5 / 12 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 11 / 24) && (angle <= Math.PI * 13 / 24):
	  return new Vector2(wState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
	  break
	case (angle > Math.PI * 13 / 24) && (angle <= Math.PI * 15 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 7 / 12 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 15 / 24) && (angle <= Math.PI * 17 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 2 / 3 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 17 / 24) && (angle <= Math.PI * 19 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 3 / 4 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 19 / 24) && (angle <= Math.PI * 21 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 5 / 6 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 21 / 24) && (angle <= Math.PI * 23 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 11 / 12 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	}
      }

      constraints[VERTICAL_HORIZONTAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case (angle > Math.PI * 3 / 4) || (angle <= Math.PI / 4):
	  return new Vector2(toolLocation.x, wState[MOUSE_DOWN_LOCATION].y)
	  break
	case (angle > Math.PI / 4) && (angle <= Math.PI * 3 / 4):
	  return new Vector2(wState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
	  break
	}
      }

      constraints[HEXAGONAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case angle <= Math.PI / 3:
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 6 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI / 3) && (angle <= Math.PI * 2 / 3):
	  return new Vector2(wState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
	  break
	case (angle > Math.PI * 2 / 3) && (angle <= Math.PI):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 5 / 6 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	}
      }

      constraints[DIAGONAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case angle < Math.PI / 2:
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2(1, 1)), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case angle > Math.PI / 2:
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2(-1, 1)), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	}
      }
      
      const tools = {}
      tools[PAINT_BRUSH] = {
	mouseDown: (toolLocation) => {},
	mouseMove: (toolLocation) => {
	  const offset = new Vector2(toolLocation.x, toolLocation.y)
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    if (spaceIsDown) {
	      layers[MARKS].save()
	      layers[MARKS].moveTo(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	      layers[MARKS].arc(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y, wState[ERASE_RADIUS], 0, Math.PI*2, 2)
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else {
	      layers[MARKS].lineJoin = layers[MARKS].lineCap = 'round';
	      layers[MARKS].beginPath();
	      layers[MARKS].moveTo(wState[PRINT_HEAD_LOCATION].x, wState[PRINT_HEAD_LOCATION].y);
	      layers[MARKS].lineTo(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	      layers[MARKS].stroke();
	    }
	    wState[PRINT_HEAD_LOCATION].setCoordinates(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	  }
	},
	mouseUp: (toolLocation) => {}
      }
      tools[COMMITTED] = {
	mouseDown: (toolLocation) => {
	  wState[ANGLE] = null
	},
	mouseMove: (toolLocation) => {
	  const offset = new Vector2(toolLocation.x, toolLocation.y)
	  if (mouseIsDown 
	    && toolLocation.getDistance(wState[MOUSE_DOWN_LOCATION]) > wState[COMMIT_RADIUS]
	    && constraints[constraint](toolLocation)) {
	    if (wState[ANGLE] === null) {
	      setWhiteboardState(ANGLE, toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]))
	    }
	    const printHeadLocation = constrainLine(
	      wState[MOUSE_DOWN_LOCATION]
		.add(new Vector2({ angle: wState[ANGLE] })), 
	      wState[MOUSE_DOWN_LOCATION], 
	      toolLocation)
	    if (spaceIsDown) {
	      layers[MARKS].save()
	      layers[MARKS].moveTo(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	      layers[MARKS].arc(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y, wState[ERASE_RADIUS], 0, Math.PI*2, 2)
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else {
	      layers[MARKS].lineJoin = layers[MARKS].lineCap = 'round';
	      layers[MARKS].beginPath();
	      layers[MARKS].moveTo(wState[PRINT_HEAD_LOCATION].x, wState[PRINT_HEAD_LOCATION].y);
	      layers[MARKS].lineTo(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	      layers[MARKS].stroke();
	    }
	    wState[PRINT_HEAD_LOCATION].setCoordinates(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	  }
	},
	mouseUp: (toolLocation) => {}
      }
      tools[ELLIPSE] = {
	mouseDown: (toolLocation) => {
	  const horizontal = (toolLocation.x - wState[MOUSE_DOWN_LOCATION].x) / 2
	  const vertical = (toolLocation.y - wState[MOUSE_DOWN_LOCATION].y) / 2  
	  const ellipse = document.createElementNS(svgNameSpace, 'ellipse')
	  ellipse.setAttribute('id', 'ellipse')
	  ellipse.setAttribute('stroke', layers[TOOLS].strokeStyle)
	  ellipse.setAttribute('fill', wState[FILL_ACTIVE] ? layers[TOOLS].fillStyle : 'none')
	  ellipse.setAttribute('stroke-width', wState[BRUSHES][wState[BRUSH]].width)
	  ellipse.setAttribute('cx', wState[MOUSE_DOWN_LOCATION].x + horizontal)
	  ellipse.setAttribute('cy', wState[MOUSE_DOWN_LOCATION].y + vertical)
	  ellipse.setAttribute('rx', Math.abs(horizontal))
	  ellipse.setAttribute('ry', Math.abs(vertical))
	  layers[TOOLS].appendChild(ellipse)    
	},
	mouseMove: (toolLocation) => {  
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    const horizontal = (constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x) / 2
	    const vertical = (constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y) / 2  
	    const ellipse = layers[TOOLS].childNodes[0]
	    ellipse.setAttribute('cx', wState[MOUSE_DOWN_LOCATION].x + horizontal)
	    ellipse.setAttribute('cy', wState[MOUSE_DOWN_LOCATION].y + vertical)
	    ellipse.setAttribute('rx', Math.abs(horizontal))
	    ellipse.setAttribute('ry', Math.abs(vertical))
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    layers[TOOLS].innerHTML = ''
	    const horizontal = (constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x) / 2
	    const vertical = (constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y) / 2
	    if (spaceIsDown) {
	      layers[MARKS].save()
	    }
	    layers[MARKS].beginPath()
	    layers[MARKS].ellipse(
	      wState[MOUSE_DOWN_LOCATION].x + horizontal,
	      wState[MOUSE_DOWN_LOCATION].y + vertical,
	      Math.abs(horizontal),
	      Math.abs(vertical),
	      0,
	      0,
	      Math.PI * 2
	    )
	    if (spaceIsDown) {
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else if (wState[FILL_ACTIVE]) {
	      layers[MARKS].fill()
	    } else {
	      layers[MARKS].stroke()
	    }
	  }
	}
      }
      tools[RECTANGLE] = {
	mouseDown: (toolLocation) => {
	  const rectangle = document.createElementNS(svgNameSpace, 'rect')
	  rectangle.setAttribute('id', 'rectangle')
	  rectangle.setAttribute('stroke', layers[TOOLS].strokeStyle)
	  rectangle.setAttribute('fill', wState[FILL_ACTIVE] ? layers[TOOLS].fillStyle : 'none')
	  rectangle.setAttribute('stroke-width', wState[BRUSHES][wState[BRUSH]].width)
	  rectangle.setAttribute('x', Math.min(toolLocation.x, wState[MOUSE_DOWN_LOCATION].x))
	  rectangle.setAttribute('y', Math.min(toolLocation.y, wState[MOUSE_DOWN_LOCATION].y))
	  rectangle.setAttribute('width', Math.abs(toolLocation.x - wState[MOUSE_DOWN_LOCATION].x))
	  rectangle.setAttribute('height', Math.abs(toolLocation.y - wState[MOUSE_DOWN_LOCATION].y))
	  layers[TOOLS].appendChild(rectangle)
	},
	mouseMove: (toolLocation) => {  
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    const width = Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_MOVE_LOCATION].x)
	    const height = Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_MOVE_LOCATION].y)
	    const rectangle = layers[TOOLS].childNodes[0]
	    rectangle.setAttribute('x', Math.min(constraints[constraint](toolLocation).x, wState[MOUSE_DOWN_LOCATION].x))
	    rectangle.setAttribute('y', Math.min(constraints[constraint](toolLocation).y, wState[MOUSE_DOWN_LOCATION].y))
	    rectangle.setAttribute('width', Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x))
	    rectangle.setAttribute('height', Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y))
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    layers[TOOLS].innerHTML = ''
	    const rectangle = [
	      Math.min(constraints[constraint](toolLocation).x, wState[MOUSE_DOWN_LOCATION].x), 
	      Math.min(constraints[constraint](toolLocation).y, wState[MOUSE_DOWN_LOCATION].y), 
	      Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x),
	      Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y)
	    ]
	    if (spaceIsDown) {
	      layers[MARKS].clearRect(...rectangle)
	    } else if (wState[FILL_ACTIVE]) {
	      layers[MARKS].fillRect(...rectangle)
	    } else {
	      layers[MARKS].strokeRect(...rectangle)
	    }
	  }
	}
      }
      tools[LINE] = {
	mouseDown: (toolLocation) => {
	  drawLine(
	    TOOLS,
	    wState[MOUSE_DOWN_LOCATION],
	    toolLocation,
	    new Color(layers[TOOLS].strokeStyle),
	    wState[BRUSHES][wState[BRUSH]].width
	  )
	},
	mouseMove: (toolLocation) => {
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    layers[TOOLS].innerHTML = ''
	    drawLine(
	      TOOLS,
	      wState[MOUSE_DOWN_LOCATION],
	      constraints[constraint](toolLocation),
	      new Color(layers[TOOLS].strokeStyle),
	      wState[BRUSHES][wState[BRUSH]].width
	    )
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    layers[TOOLS].innerHTML = ''
	    drawLine(
	      MARKS,
	      wState[MOUSE_DOWN_LOCATION],
	      constraints[constraint](toolLocation),
	      wState[BRUSHES][wState[BRUSH]].color,
	      wState[BRUSHES][wState[BRUSH]].width
	    )
	    setWhiteboardState(ANGLE, constraints[constraint](toolLocation).getAngle(wState[MOUSE_DOWN_LOCATION]))
	  }
	}
      }
      tools[TEXT] = {
	mouseDown: (toolLocation) => {
	  drawTextCursor()
	},
	mouseMove: (toolLocation) => {},
	mouseUp: (toolLocation) => {}
      }
      tools[MEASURE] = {
	mouseDown: (toolLocation) => {
	  drawLine(
	    TOOLS,
	    wState[MOUSE_DOWN_LOCATION],
	    new Vector2(toolLocation.x, toolLocation.y),
	    new Color(layers[TOOLS].strokeStyle),
	    6
	  )
	},
	mouseMove: (toolLocation) => {
	  layers[TOOLS].innerHTML = ''
	  drawLine(
	    TOOLS,
	    wState[MOUSE_DOWN_LOCATION],
	    new Vector2(toolLocation.x, toolLocation.y),
	    new Color(layers[TOOLS].strokeStyle),
	    6
	  )
	},
	mouseUp: (toolLocation) => {
	  const mouseDownVector = new Vector2(wState[MOUSE_DOWN_LOCATION])
	  const mouseUpVector = new Vector2(wState[MOUSE_UP_LOCATION])
	  const angle = wState[MOUSE_UP_LOCATION].scale({ x: 1, y: -1}).getAngle(wState[MOUSE_DOWN_LOCATION].scale({ x: 1, y: -1}))
	  const upUnits = [
	    wState[MOUSE_UP_LOCATION],
	    wState[MOUSE_UP_LOCATION].getSquareUnits(),
	    wState[MOUSE_UP_LOCATION].getHexUnits(),
	    wState[MOUSE_UP_LOCATION]
	  ][wState[GRID_TYPE].x]
	  const downUnits = [
	    wState[MOUSE_DOWN_LOCATION],
	    wState[MOUSE_DOWN_LOCATION].getSquareUnits(),
	    wState[MOUSE_DOWN_LOCATION].getHexUnits(),
	    wState[MOUSE_DOWN_LOCATION]
	  ][wState[GRID_TYPE].x]

	  const distance = downUnits.getDistance(upUnits)

	  console.log(`measurements:\n  angle: ${(angle * 180 / Math.PI).toFixed(0)}°\n  distance: ${distance.toFixed(2)}`)
	  setWhiteboardState(MEASUREMENT, new Vector2(
	    wState[MOUSE_UP_LOCATION].x - wState[MOUSE_DOWN_LOCATION].x,
	    wState[MOUSE_UP_LOCATION].y - wState[MOUSE_DOWN_LOCATION].y
	  ))
	}
      }

      tools[PALETTE] = {}
      tools[PALETTE].mouseDown = tools[PALETTE].mouseMove = (toolLocation) => {
	toolLocation = toolLocation.add(new Vector2(-window.scrollX, -window.scrollY))
	if (
	  mouseIsDown 
	    && toolLocation.x <= colorWheelSideLength * 3 
	    && toolLocation.y <= colorWheelSideLength
	) {
	  picked = readPalette(
	    new Vector2(
	      toolLocation.x % colorWheelSideLength,
	      toolLocation.y
	    ),
	    [
	      wState[BRUSHES][wState[BRUSH]].color,
	      wState[OVERLAY_COLOR],
	      wState[GRID_COLOR]
	    ][Math.floor(toolLocation.x / colorWheelSideLength)],
	    colorWheelSideLength
	  )
	  /* if (shiftIsDown && toolLocation.x < colorWheelSideLength) {
	     let factor
	     for (let p in picked.prop) {
	     factor = picked.prop[p] / wState[BRUSHES][wState[BRUSH]].color[p]
	     let brush
	     while (brush < 11) {
	     if (brush !== wState[BRUSH]) {
	     wState[BRUSHES][brush].color[p] *= factor
	     wState[BRUSHES][brush].color = new Color(wState[BRUSHES][brush].getHsla())
	     }
	     }
	     }
	     } */
	  setColor(
	    picked.color, 
	    [layers[MARKS], dom[OVERLAY], layers[GRID]][Math.floor(toolLocation.x / colorWheelSideLength)]
	  )
	}
      }
      tools[PALETTE].mouseUp = (toolLocation) => {}

      tools[GRID] = {
	mouseDown: (toolLocation) => {},
	mouseMove: (toolLocation) => {
	  const units = {
	    square: new Vector2(
	      (toolLocation.x - wState[VANISHING_POINT].x) / (wState[MOUSE_DOWN_LOCATION].x - wState[VANISHING_POINT].x),
	      (toolLocation.y - wState[VANISHING_POINT].y) / (wState[MOUSE_DOWN_LOCATION].y - wState[VANISHING_POINT].y)
	    ),
	    hex: toolLocation.getDistance(wState[VANISHING_POINT]) / wState[MOUSE_DOWN_LOCATION].getDistance(wState[VANISHING_POINT])
	  }
	  clearLayer(GRID)
	  drawGrid(wState[GRID_TYPE], {
	    square: wState[SQUARE_GRID_UNITS].scale(units.square),
	    hex: wState[HEX_GRID_UNIT] * units.hex
	  })
	  drawCircle(
	    wState[VANISHING_POINT], 
	    5, 
	    wState[GRID_COLOR]
	  )
	},
	mouseUp: (toolLocation) => {
	  const units = {
	    square: new Vector2(
	      (toolLocation.x - wState[VANISHING_POINT].x) / (wState[MOUSE_DOWN_LOCATION].x - wState[VANISHING_POINT].x),
	      (toolLocation.y - wState[VANISHING_POINT].y) / (wState[MOUSE_DOWN_LOCATION].y - wState[VANISHING_POINT].y)
	    ),
	    hex: toolLocation.getDistance(wState[VANISHING_POINT]) / wState[MOUSE_DOWN_LOCATION].getDistance(wState[VANISHING_POINT])
	  }
	  if (wState[GRID_TYPE].x === 1) {
	    setWhiteboardState(SQUARE_GRID_UNITS, wState[SQUARE_GRID_UNITS].scale(units.square))
	  } else if (wState[GRID_TYPE].x === 2) {
	    setWhiteboardState(HEX_GRID_UNIT, wState[HEX_GRID_UNIT] * units.hex)
	  }
	  setGrid()
	}
      }

      // CONFIGURATION
      const unsplashCollections = [
	1242150,
	1457745,
	289662,
	1976082,
	920773,
	1886495,
	1772170,
	416021,
	548245,
	923267,
	827751,
	145238,
	179297,
	869015,
	397119,
	562095,
	1240111,
	782123,
	827743,
	2254180,
	1424240,
	162468,
	1223439,
	357786,
	1538150,
	256443,
	1166960,
	1405010,
	463870,
	545337,
	1463948,
	1346770,
	410546,
	193055,
	1525589,
	332024,
	167880,
	181581,
	3178572,
	175083,
	540518,
	573009,
	225,
	2227966, 
	1136512, 
	256789, 
	770373, 
	1340426, 
	786426, 
	1093185, 
	2073541, 
	631014, 
	311432, 
	401930, 
	1558570, 
	634016, 
	1753486, 
	525374, 
	402648, 
	944309, 
	1223029, 
	1045960, 
	136192, 
	139523, 
	490159, 
	1319676, 
	603534, 
	1705422, 
	421702, 
	1201283, 
	1280629, 
	250310, 
	1079579, 
	159185, 
	357250, 
	461372, 
	222193, 
	981639, 
	389015, 
	427860, 
	1922955, 
	550831, 
	1566993, 
	228211, 
	637183, 
	1348126, 
	860813, 
	279087, 
	893395, 
	1445644, 
	1364697, 
	266986, 
	1130937, 
	1030539, 
	441643, 
	1301636, 
	1078224, 
	346831, 
	217461, 
	195845, 
	291422, 
	326234, 
	1301396, 
	159106, 
	2222015, 
	993107, 
	1661394, 
	1563872, 
	789653, 
	139449, 
	395791, 
	168902, 
	1363567, 
	774640, 
	668423, 
	1091443, 
	631110, 
	589982, 
	251528, 
	158665, 
	1281908, 
	1025599, 
	403132, 
	542909, 
	1695735, 
	345761, 
	2241198, 
	2213392, 
	303466, 
	1266354, 
	932809, 
	525557, 
	1111575, 
	1698281, 
	325867, 
	992061,  
	1394721, 
	1949, 
	220388, 
	343012, 
	151521, 
	137627,  
	335992, 
	1494572, 
	148642, 
	311958, 
	460827, 
	1179044, 
	320872, 
	345744, 
	151899, 
	345758, 
	1163715, 
	256466, 
	926827, 
	1725806, 
	1152757, 
	981639, 
	647, 
	138884, 
	1477100, 
	1301689, 
	1664497,  
	1677633, 
	2020767, 
	924999, 
	147383, 
	934875, 
	1708734, 
	1751890, 
	668443, 
	1137170, 
	1134892, 
	1004394, 
	1366113,  
	632964, 
	142371, 
	536034, 
	923414, 
	490, 
	630848, 
	241614, 
	1117100, 
	896618, 
	525483, 
	444531, 
	1896376,
	1515841, 
	1270392, 
	635672, 
	560743, 
	158642, 
	212915, 
	236531
      ]
    
      const colorWheelSideLength = 400

      const periodicTable = () => 'https://www.cmu.edu/news/stories/archives/2016/january/images/periodic_table_large.png'
      const randomImage = (size) => `https://source.unsplash.com/random/${size.x}x${size.y}`
      const slideshow = []
      const globalOrigin = new Vector2(0, 0)
      const hpScreenDimenstions = new Vector2(1366, 768)
      const fontSizes = [8, 9, 10, 11, 12, 14, 18, 24, 30, 36, 48, 60, 72, 96]

      const defaultState = {}
      defaultState[DOCUMENT_TITLE] = 'Whiteboard'
      defaultState[SCREEN_SIZE] = new Vector2(1366, 768)
      defaultState[BOARD_SCALE] = new Vector2(1, 2)
      defaultState[ZOOM] = 1
      defaultState[OVERLAY_COLOR] = new Color('rgba(255, 255, 255, 0.0)')
      defaultState[SQUARE_GRID_UNITS] = new Vector2(60, 60) // Grid separated to four variables, for easy query strings.
      defaultState[HEX_GRID_UNIT] = 60
      defaultState[GRID_TYPE] = new Vector2(0, 0)
      defaultState[GRID_WIDTH] = 2
      defaultState[GRID_COLOR] = new Color('rgba(0, 0, 0, 0.4)')
      defaultState[TIME_PADDING] = new Vector2(80, 40)
      defaultState[PROBLEM_IMAGE] = 'problem.png'
      defaultState[PROBLEM_ACTIVE] = false
      defaultState[TOOL] = PAINT_BRUSH
      defaultState[TOOLS_COLOR] = new Color('rgba(128, 128, 128, 0.6)')
      defaultState[BRUSH] = 0
      defaultState[BRUSHES] = [
	{ width: 2, color: new Color('hsla(0, 0%, 0%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(30, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(60, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(120, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(180, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(240, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(300, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(30, 100%, 30%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 0%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 0%, 100%, 1.0)') }
      ]
      defaultState[FILL_ACTIVE] = false
      defaultState[FONT] = 'Courier New'
      defaultState[FONT_HEIGHT] = 10
      defaultState[FONT_WIDTH] = 30
      defaultState[LINE_SPACING] = 60
      defaultState[ANGLE] = 1.2277723863741932
      defaultState[COMMIT_RADIUS] = 120
      defaultState[ERASE_RADIUS] = 12
      defaultState[MOUSE_DOWN_LOCATION] = globalOrigin.copy()
      defaultState[MOUSE_MOVE_LOCATION] = globalOrigin.copy()
      defaultState[MOUSE_UP_LOCATION] = globalOrigin.copy()
      defaultState[PRINT_HEAD_LOCATION] = globalOrigin.copy()
      defaultState[MEASUREMENT] = globalOrigin.copy()
      defaultState[MARKS_DATA] = 'untitled'
      defaultState[SAVED_MARKS_DATA] = {}
      defaultState[SAVE_PROMPT_ACTIVE] = true
      
      // Prepare Objects for Grid
      const drawLine = function(layer, fv, tv, color, width) {
	if (layers[layer].nodeName === 'svg') {
	  const line = document.createElementNS(svgNameSpace, 'line')
	  line.setAttribute('x1', fv.x.toString())
	  line.setAttribute('y1', fv.y.toString())
	  line.setAttribute('x2', tv.x.toString())
	  line.setAttribute('y2', tv.y.toString())
	  line.setAttribute('stroke', color ? color.getRgba() : wState[`${layer}_COLOR`].getRgba())
	  line.setAttribute('stroke-width', width || wState[`${layer}_WIDTH`])
	  layers[layer].appendChild(line)
	} else { // draw line on canvas
	  layers[layer].beginPath()
	  layers[layer].moveTo(fv.x, fv.y)
	  layers[layer].lineTo(tv.x, tv.y)
	  layers[layer].strokeStyle = color ? color.getRgba() : wState[`${layer}_COLOR`].getRgba()
	  layers[layer].stroke()
	}
      }

      const drawText = function(layer, content, position, color, size) {
	if (layers[layer].nodeName === 'svg') { 
	  const text = document.createElementNS(svgNameSpace, 'text')
	  text.setAttribute('x', position.x.toString())
	  text.setAttribute('y', position.y.toString())
	  text.setAttribute('fill', color.getRgba() || wState[`${layer}_COLOR`])
	  text.setAttribute('font-family', wState[FONT])
	  text.setAttribute('font-size', `${size || fontSizes[wState[FONT_HEIGHT]]}px`)
	  text.innerHTML = content
	  layers[layer].appendChild(text)
	} else { // draw text on canvas
	  if (color !== undefined) {
	    layers[layer].fillStyle = color.getRgba()
	  }
	  if (size !== undefined) {
	    layers[layer].font = `${size}px ${wState[FONT]}`
	  }
	  layers[layer].fillText(content, position.x, position.y)
	  layers[layer].fillStyle = wState[BRUSHES][wState[BRUSH]].color.getRgba()
	  layers[layer].font = `${fontSizes[wState[FONT_HEIGHT]]}px ${wState[FONT]}`
	}
      }
      
      const drawCircle = (center, radius, color, filled=false) => {
	const circle = document.createElementNS(svgNameSpace, 'circle')
	circle.setAttribute('cx', center.x.toString())
	circle.setAttribute('cy', center.y.toString())
	circle.setAttribute('r', radius.toString())
	circle.setAttribute('stroke', color.getRgba())
	circle.setAttribute('stroke-width', wState[GRID_WIDTH].toString())
	if (!filled) {
	  circle.setAttribute('fill', 'transparent')
	} else {
	  circle.setAttribute('fill', color.getRgba())
	}
	layers[GRID].appendChild(circle)
	return circle
      }
      

      // draw cursor for typing
      const drawTextCursor = () => {
	if (isTyping) {
	  clearLayer(TOOLS)
	  const rectangle = document.createElementNS(svgNameSpace, 'rect')
	  rectangle.setAttribute('id', 'rectangle')
	  rectangle.setAttribute('stroke', 'none')
	  rectangle.setAttribute('fill', layers[TOOLS].fillStyle)
	  rectangle.setAttribute('x', wState[PRINT_HEAD_LOCATION].x)
	  rectangle.setAttribute('y', wState[PRINT_HEAD_LOCATION].y - fontSizes[wState[FONT_HEIGHT]])
	  rectangle.setAttribute('width', wState[FONT_WIDTH])
	  rectangle.setAttribute('height', fontSizes[wState[FONT_HEIGHT]])
	  layers[TOOLS].appendChild(rectangle)
	}
      }

      // DRAW COLOR WHEEL
      const drawColorWheel = (c, offset, sideLength=colorWheelSideLength) => {
	color = new Color(c)
	// populate pixels array
	let pickerArray = []
	const pixelLocation = new Vector2(0, 0)
	while (pixelLocation.y < sideLength) {
	  pixelLocation.setCoordinates({ x: 0 })
	
	  while (pixelLocation.x < sideLength) {
	    const pixelData = readPalette(pixelLocation, color).color.getPixelData()
	    pickerArray.push(...pixelData)
	    pixelLocation.setCoordinates({ x: pixelLocation.x + 1 })
	  }
	  pixelLocation.setCoordinates({ y: pixelLocation.y + 1 })
	}
	pickerArray = new Uint8ClampedArray(pickerArray)
	const pickerData = new ImageData(pickerArray, sideLength)
	layers[PALETTE].putImageData(pickerData, offset.x, offset.y)
      }

      // DRAW GRIDS
      const drawSquareDotsGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[SQUARE_GRID_UNITS]
	} = options
	let head = new Vector2(
	  origin.x % offset.x,
	  origin.y % offset.y
	)
	while (head.y < wState[BOARD_SIZE].y) {
	  while (head.x < wState[BOARD_SIZE].x) {
	    drawCircle(
	      head, 
	      wState[GRID_WIDTH] / 2, 
	      wState[GRID_COLOR], 
	      true
	    )
	    head.x += offset.x
	  }
	  head.x = origin.x % offset.x
	  head.y += offset.y
	}
      }
      
      const drawLinedGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[SQUARE_GRID_UNITS]
	} = options
      
	let head = origin.y % offset.y
	while (head < wState[BOARD_SIZE].y) {
	  drawLine(
	    GRID, 
	    new Vector2(0, head), 
	    new Vector2(wState[BOARD_SIZE].x, head)
	  )
	  head += offset.y
	}
      }

      const drawSquareGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[SQUARE_GRID_UNITS]
	} = options
      
	let head = new Vector2(
	  origin.x % offset.x,
	  origin.y % offset.y
	)
	while (head.x < wState[BOARD_SIZE].x) {
	  drawLine(
	    GRID, 
	    new Vector2(head.x, 0), 
	    new Vector2(head.x, wState[BOARD_SIZE].y)
	  )
	  head.x += offset.x
	}
	while (head.y < wState[BOARD_SIZE].y) {
	  drawLine(
	    GRID, 
	    new Vector2(0, head.y), 
	    new Vector2(wState[BOARD_SIZE].x, head.y)
	  )
	  head.y += offset.y
	}
      }
      
      const drawTriangleDotsGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[HEX_GRID_UNIT]
	} = options
      
	const headIntervals = new Vector2 (
	  offset * Math.sqrt(3),
	  offset
	)
	let head = new Vector2(
	  (origin.x % headIntervals.x) - headIntervals.x,
	  (origin.y % headIntervals.y) - headIntervals.y
	)
	while (head.y < wState[BOARD_SIZE].y + headIntervals.y) {
	  while (head.x < wState[BOARD_SIZE].x + headIntervals.x) {
	    drawCircle(
	      head, 
	      wState[GRID_WIDTH] / 2, 
	      wState[GRID_COLOR], 
	      true
	    )
	    drawCircle(
	      new Vector2(
		head.x + headIntervals.x / 2,
		head.y + headIntervals.y / 2
	      ),
	      wState[GRID_WIDTH] / 2, 
	      wState[GRID_COLOR], 
	      true
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (origin.x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      const drawHexGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[HEX_GRID_UNIT]
	} = options
      
	const headIntervals = new Vector2(
	  offset * Math.sqrt(3),
	  offset * 3
	)
	let head = new Vector2(
	  (origin.x % headIntervals.x) - headIntervals.x,
	  (origin.y % headIntervals.y) - headIntervals.y
	)
	while (head.y < wState[BOARD_SIZE].y + headIntervals.y * 2 / 3) {
	  while (head.x < wState[BOARD_SIZE].x + headIntervals.x / 2) {
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y * 2 / 3), 
	      new Vector2(head.x, head.y - headIntervals.y / 3)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y / 3),
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 6)
	    )
	    drawLine(
	      GRID,
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 6),
	      new Vector2(head.x, head.y - headIntervals.y / 3)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 6),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y + headIntervals.y / 3),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y + headIntervals.y / 3),
	      new Vector2(head.x + headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (origin.x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      const drawTriangleGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[HEX_GRID_UNIT]
	} = options
      
	const headIntervals = new Vector2(
	  offset * Math.sqrt(3),
	  offset
	)
	let head = new Vector2(
	  (origin.x % headIntervals.x) - headIntervals.x,
	  (origin.y % headIntervals.y) - headIntervals.y
	)
	while (head.y < wState[BOARD_SIZE].y + headIntervals.y * 2 / 3) {
	  while (head.x < wState[BOARD_SIZE].x + headIntervals.x / 2) {
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x, head.y - headIntervals.y)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y),
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 2),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 2)
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (origin.x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      const weekdays = [
	'Sunday',
	'Monday',
	'Tuesday',
	'Wednesday',
	'Thursday',
	'Friday',
	'Saturday'
      ]

      const drawPlanner = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=new Vector2(
	      (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 2) / 7,
	      (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 48
	    )
	} = options
	Object.assign(daysElement.style, {
	  width: `${wState[BOARD_SIZE].x - wState[TIME_PADDING].x}px`,
	  top: '0px',
	  left: `${wState[TIME_PADDING].x}px`,
	  display: 'flex'
	})
	hoursElement.style.display = 'flex'
	head = new Vector2(0, 0)
	let pixels = origin.copy()
	while (head.y < (wState[BOARD_SIZE].y / offset.y)) {
	  pixels.y = head.y * offset.y + origin.y
	  drawLine(
	    GRID, 
	    new Vector2(0, pixels.y), 
	    new Vector2(wState[BOARD_SIZE].x, pixels.y),
	    wState[GRID_COLOR],
	    head.y % 12 === 0 
	      ? 6 
	      : head.y % 2 === 0
	      ? 2
	      : 0.5
	  )
	  head.y += 1
	}
	while (head.x < (wState[BOARD_SIZE].x / offset.x)) {
	  pixels.x = head.x * offset.x + origin.x
	  drawLine(
	    GRID, 
	    new Vector2(pixels.x, 0), 
	    new Vector2(pixels.x, wState[BOARD_SIZE].y),
	    wState[GRID_COLOR],
	    2
	  )
	  head.x += 1
	}
      }

      drawCalendar = () => {
	const today = new Date()
	const hasLeapDay = (dt) => {
	  if (dt.getMonth() === 1) {
	    const year = dt.getFullYear()
	    switch (true) {
	    case (year % 400 === 0):
	      return 1
	      break
	    case (year % 100 === 0):
	      return 0
	      break
	    case (year % 4 === 0):
	      return 1
	      break
	    default:
	      return 0
	    }
	  } else {
	    return 0
	  }
	} 
	const months = [
	  { name: 'January', days: 31 },
	  { name: 'February', days: 28 },
	  { name: 'March', days: 31 },
	  { name: 'April', days: 30 },
	  { name: 'May', days: 31 },
	  { name: 'June', days: 30 },
	  { name: 'July', days: 31 },
	  { name: 'August', days: 31 },
	  { name: 'September', days: 30 },
	  { name: 'October', days: 31 },
	  { name: 'November', days: 30 },
	  { name: 'December', days: 31 }
	]
	const theseDays = months[today.getMonth()].days + hasLeapDay(today)
	let daysOffset = (8 + today.getDay() - (today.getDate() % 7)) % 7
	const rows = Math.ceil((daysOffset + theseDays) / 7)
	const printOffset = new Vector2(
	  (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 2) / 7,
	  (wState[SCREEN_SIZE].y - wState[TIME_PADDING].y * 5) / rows
	)
	const printHead = new Vector2(
	  wState[TIME_PADDING].x,
	  wState[TIME_PADDING].y * 3
	)
	
	drawLine(
	  GRID,
	  new Vector2(
	    wState[TIME_PADDING].x,
	    printHead.y
	  ),
	  new Vector2(
	    wState[BOARD_SIZE].x - wState[TIME_PADDING].x,
	    printHead.y
	  ),
	  wState[GRID_COLOR],
	  6
	)
	printHead.y += wState[TIME_PADDING].y
	while (printHead.y < wState[SCREEN_SIZE].y) {
	  drawLine(
	    GRID,
	    new Vector2(
	      wState[TIME_PADDING].x,
	      printHead.y
	    ),
	    new Vector2(
	      wState[BOARD_SIZE].x - wState[TIME_PADDING].x,
	      printHead.y
	    ),
	    wState[GRID_COLOR],
	    2
	  )
	  printHead.y += printOffset.y
	}
	
	while (printHead.x < wState[BOARD_SIZE].x) {
	  drawLine(
	    GRID,
	    new Vector2(
	      printHead.x,
	      wState[TIME_PADDING].y * 3
	    ),
	    new Vector2(
	      printHead.x,
	      wState[SCREEN_SIZE].y - wState[TIME_PADDING].y
	    ),
	    wState[GRID_COLOR],
	    2
	  )
	  printHead.x += printOffset.x
	}
	
	drawText(
	  GRID, 
	  `${months[today.getMonth()].name}, ${today.getFullYear()}`,
	  new Vector2(
	    wState[TIME_PADDING].x + 5,
	    wState[TIME_PADDING].y + 50
	  ),
	  wState[GRID_COLOR],
	  50
	)
	
	weekdays.forEach((weekday, index) => {
	  drawText(
	    GRID, 
	    weekday,
	    new Vector2(
	      wState[TIME_PADDING].x + (index * printOffset.x) + (printOffset.x / 2) - (weekday.length * 10 * 0.59),
	      wState[TIME_PADDING].y * 4 - 10
	    ),
	    wState[GRID_COLOR],
	    20
	  )  
	})
	
	printHead.setCoordinates(
	  wState[TIME_PADDING].x + (printOffset.x * daysOffset),
	  wState[TIME_PADDING].y * 4
	)
	let thisDate = 1
	let halfSpace
	while (thisDate <= theseDays) {
	  halfSpace = thisDate < 10 ? 5.5 : 0
	  drawText(
	    GRID, 
	    thisDate,
	    new Vector2(
	      printHead.x + halfSpace + 10,
	      printHead.y + 24
	    ),
	    wState[GRID_COLOR],
	    16
	  )
	  if ((thisDate + daysOffset) % 7 === 0) {
	    printHead.setCoordinates(
	      wState[TIME_PADDING].x,
	      printHead.y + printOffset.y
	    )
	  } else {
	    printHead.x += printOffset.x
	  }
	  thisDate ++
	}
      }

      drawClock = () => {
	daysElement.style.display = hoursElement.style.display = 'none'
	const clockCenter = wState[SCREEN_SIZE].scale(1 / 2)
	const clockRadius = (wState[SCREEN_SIZE].y - wState[TIME_PADDING].y * 2) / 2
	setInterval(() => {
	  if (wState[GRID_TYPE].x === 3 && wState[GRID_TYPE].y === 2) {
	    clearLayer(GRID)
	    drawCircle(
	      wState[VANISHING_POINT], 
	      5, 
	      wState[GRID_COLOR]
	    )
	    drawCircle(
	      clockCenter,
	      clockRadius,
	      wState[GRID_COLOR],
	      false
	    )
	    date = new Date
	    const hourAngle = (Math.PI * (((date.getHours() % 12) / 6) + (date.getMinutes() / 360))) - Math.PI / 2
	    const minuteAngle = (Math.PI * (((date.getMinutes()) / 30) + (date.getSeconds() / 1800))) - Math.PI / 2
	    const secondAngle = (Math.PI * date.getSeconds() / 30) - Math.PI / 2
	    drawLine(
	      GRID,
	      new Vector2({ magnitude: 30, angle: hourAngle + Math.PI }).add(clockCenter),
	      new Vector2({ magnitude: clockRadius / 2, angle: hourAngle }).add(clockCenter),
	      wState[GRID_COLOR],
	      8
	    )
	    drawLine(
	      GRID,
	      new Vector2({ magnitude: 30, angle: minuteAngle + Math.PI }).add(clockCenter),
	      new Vector2({ magnitude: clockRadius * 4 / 5, angle: minuteAngle }).add(clockCenter),
	      wState[GRID_COLOR],
	      8
	    )
	    drawLine(
	      GRID,
	      new Vector2({ magnitude: 40, angle: secondAngle + Math.PI }).add(clockCenter),
	      new Vector2({ magnitude: clockRadius * 4 / 6, angle: secondAngle }).add(clockCenter),
	      wState[GRID_COLOR],
	      2
	    )
	  }


	}, 1000);
      }
    
      // REDUNDANT BRUSH WIDTH
      const setBrushWidth = (newBrushWidth) => {
	wState[BRUSHES][wState[BRUSH]].width = newBrushWidth
	layers[MARKS].lineWidth = wState[BRUSHES][wState[BRUSH]].width	
	wState[ERASE_RADIUS] = 10 + layers[MARKS].lineWidth
      }

      const setColor = (c, layer=layers[MARKS]) => {
	color = new Color(c)
	switch (layer) {
	case dom[OVERLAY]:
	  dom[OVERLAY].style.background = color.getRgba()
	
	  setWhiteboardState(OVERLAY_COLOR, color)
	  drawColorWheel(color, new Vector2(colorWheelSideLength, 0))
	  break
	case layers[GRID]:
	  setWhiteboardState(GRID_COLOR, color)
	  setGrid()
	  drawColorWheel(color, new Vector2(colorWheelSideLength * 2, 0))
	  break
	case layers[MARKS]:
	  layers[MARKS].strokeStyle = color.getRgba()
	  layers[MARKS].fillStyle = color.getRgba()
	  layers[MARKS].globalAlpha = color.alpha
	  layers[TOOLS].strokeStyle = new Color(Object.assign({}, { ...color, alpha: 0.5 })).getRgba()
	  layers[TOOLS].fillStyle = new Color(Object.assign({}, { ...color, alpha: 0.5 })).getRgba()
	  const brushes = [...wState[BRUSHES]]
	  brushes[wState[BRUSH]].color = color
	  setWhiteboardState(BRUSHES, brushes)
	  drawColorWheel(color, new Vector2(0, 0))
	}
      }

      const setLightness = (factor) => {
	for (let brush of wState[BRUSHES]) {
	 brush.color.modify({ lum: bound(brush.color.lum * factor) })
	}
	setWhiteboardState(BRUSHES, wState[BRUSHES])
      }

      const drawGrid = (type, units) => {
	const getCoefficient = (pixels, factor) => Math.pow(10, 1 - Math.floor(Math.log10(pixels / factor)))
	if (storedFunctions.length > 0) {
	  for (let storedFunction of storedFunctions) {
	    plotFunction(storedFunction.f, storedFunction.style, units, true)
	  }
	}
	return [
	  [
	    drawSquareDotsGrid,
	    drawLinedGrid,
	    drawSquareGrid,
	  ],
	  [
	    drawTriangleDotsGrid,
	    drawHexGrid,
	    drawTriangleGrid
	  ],
	  [
	    drawCalendar,
	    drawPlanner,
	    drawClock
	  ]
	][type.x - 1][type.y]([
	  {
	    origin: wState[VANISHING_POINT],
	    offset: new Vector2(
	      units.square.x * getCoefficient(units.square.x, 3), 
	      units.square.y * getCoefficient(units.square.y, 3)
	    )},
	  { 
	    origin: wState[VANISHING_POINT],
	    offset: units.hex * getCoefficient(units.hex, 4)
	  },
	  {
	    origin: new Vector2(
	      wState[TIME_PADDING].x,
	      wState[TIME_PADDING].y
	    ),
	    offset: new Vector2(
	      (wState[BOARD_SIZE].x - wState[TIME_PADDING].x) / 7,
	      (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 48
	    )
	  }
	][type.x - 1])
      }

      const setGrid = (type=wState[GRID_TYPE]) => {
	clearLayer(GRID)	
	if (!isTyping) {
	  if (type.x === 0) {
	    hoursElement.style.display = daysElement.style.display = 'none'
	    wState[GRID_TYPE].setCoordinates(0, type.y)
	    setWhiteboardState(GRID_TYPE)
	  } else {
	    drawGrid(type, {
	      square: wState[SQUARE_GRID_UNITS],
	      hex: wState[HEX_GRID_UNIT],
	      time: [
		// getCalendarCell(),
		new Vector2(
		  (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 3) / 7,
		  (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 24,
		),
		new Vector2(
		  (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 3) / 7,
		  (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 24,
		),
		new Vector2(
		  (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 3) / 7,
		  (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 24,
		)
		// wState[HEX_GRID_UNIT]
	      ][type.y]
	    })
	    wState[GRID_TYPE].setCoordinates(type)
	    setWhiteboardState(GRID_TYPE)
	    drawCircle(
	      wState[VANISHING_POINT], 
	      5, 
	      wState[GRID_COLOR]
	    )
	  }
	}
      }
      
      const setSquareGridUnits = (xUnit=wState[SQUARE_GRID_UNITS].getDistance() / Math.sqrt(2), yUnit) => {
	setWhiteboardState(
	  SQUARE_GRID_UNITS,
	  new Vector2(xUnit, yUnit || xUnit)
	)
	setGrid()
      }

      const setVanishingPoint = (x, y) => {
	clearLayer(GRID)
	wState[VANISHING_POINT].setCoordinates(x, y)
	setGrid()
	console.log(`vanish: (${wState[VANISHING_POINT].x}, ${wState[VANISHING_POINT].y})`)
	setWhiteboardState(VANISHING_POINT, wState[VANISHING_POINT])
	setGrid()
      }

      const addAngle = (degrees) => {
	setWhiteboardState(ANGLE, wState[ANGLE] + (degrees * Math.PI / 180))
      }

      const plotFunction = (
	cb, 
	brush=wState[BRUSHES][wState[BRUSH]], 
	units={
	  square: wState[SQUARE_GRID_UNITS],
	  hex: wState[HEX_GRID_UNIT]
	},
	fromStoredFunctions=false
      ) => {
	if (!fromStoredFunctions) {
	  storedFunctions.push({ f:cb, style: { ...brush } })
	}
	let plotHeadLocation
	let previousPlotHeadLocation
	switch (wState[GRID_TYPE].x) {
	case 1:
	  let nextPlotHeadX
	  plotHeadLocation = new Vector2(
	    - wState[VANISHING_POINT].x / units.square.x,
	    cb(wState[VANISHING_POINT].x / units.square.x)
	  )
	  previousPlotHeadLocation = plotHeadLocation.copy()
	  while (plotHeadLocation.x <= wState[BOARD_SIZE].add(wState[VANISHING_POINT].scale(-1)).getSquareUnits().x) {
	    drawLine(
	      GRID,
	      previousPlotHeadLocation
		.scale({ x: units.square.x, y: -units.square.y })
		.add(wState[VANISHING_POINT]),
	      plotHeadLocation
		.scale({ x: units.square.x, y: -units.square.y })
		.add(wState[VANISHING_POINT]),
	      brush.color,
	      brush.width
	    )
	    previousPlotHeadLocation.setCoordinates(plotHeadLocation)
	    nextPlotHeadX = plotHeadLocation.x + (1 / units.square.x)
	    plotHeadLocation.setCoordinates({ 
	      x: nextPlotHeadX,
	      y: cb(nextPlotHeadX)
	    })
	  }
	  break
	case 2:
	  let radians = 0
	  plotHeadLocation = new Vector2({ 
	    angle: radians, 
	    magnitude: cb(radians)
	  })
	  while (radians < 2 * Math.PI) {
	    if (radians > Math.PI / 180) {
	      drawLine(
		GRID,
		previousPlotHeadLocation
		  .scale({ x: units.hex, y: -units.hex })
		  .add(wState[VANISHING_POINT]),
		plotHeadLocation
		  .scale({ x: units.hex, y: -units.hex })
		  .add(wState[VANISHING_POINT]),
		brush.color,
		brush.width
	      )
	    }
	    previousPlotHeadLocation = plotHeadLocation.copy()
	    radians += Math.PI / 180
	    plotHeadLocation = new Vector2({ 
	      angle: radians, 
	      magnitude: cb(radians)
	    })
	  }
	  break
	}
      }
      const clearFunctions = () => {
	storedFunctions = []
	setGrid()
      }

      // Typing
      function typingFunction (e) {
	if (![
	  'Shift', 
	  'Enter', 
	  'Control', 
	  'Alt', 
	  'ArrowUp', 
	  'ArrowRight', 
	  'ArrowDown', 
	  'ArrowLeft',
	  'Backspace',
	  'CapsLock',
	  'Escape',
	  'Delete'
	].includes(e.key)) {
	  layers[MARKS].fillText(e.key, wState[PRINT_HEAD_LOCATION].x, wState[PRINT_HEAD_LOCATION].y)
	  wState[PRINT_HEAD_LOCATION].x += wState[FONT_WIDTH]
	  drawTextCursor()
	}
      }

      const setFontHeight = (heightIndex, font) => {
	setWhiteboardState(FONT_HEIGHT, heightIndex)
	if (font !== undefined) {
	  setWhiteboardState(FONT, font)
	}
	const heightInPixels = fontSizes[heightIndex]
	wState[FONT_WIDTH] = heightInPixels * 0.62
	wState[LINE_SPACING] = heightInPixels * 1.25
	layers[MARKS].font = `${heightInPixels}px ${wState[FONT]}`
      }
      
      const offset = globalOrigin.copy()

      const constrainLine = (a, b, c) => {
	if (a.x === b.x) {
	  return new Vector2(a.x, c.y)
	} else if (a.y === b.y) {
	  return new Vector2(c.x, a.y)
	}
	const slope = {
	  b: (b.y - a.y) / (b.x - a.x),
	  c: (b.x - a.x) / (b.y - a.y) // the slope of the second line is the negative inverse of the first, but this is left positive to simplify thewState[MOUSE_DOWN_LOCATION] equation.
	}
	const xOffset = ((c.y - a.y) + ((c.x - a.x) * slope.c)) / (slope.b + slope.c)
	return new Vector2(
	  xOffset + a.x,
	  (xOffset * slope.b) + a.y
	)
      }

      const constrainArc = (a, b, c) => {
	const scale = a.getDistance(b)/a.getDistance(c)
	return new Vector2(
	  (c.x - a.x) * scale + a.x,
 	  (c.y - a.y) * scale + a.y
	)
      }
      
      // EVENT LISTENERS
      let mouseIsDown = false
      let keyIsDown = false
      let shiftIsDown = false
      let spaceIsDown = false

      dom[SENSOR].addEventListener('mousedown', (e) => {
	mouseIsDown = true
	const mouseLocation = new Vector2(e.offsetX, e.offsetY)
	wState[MOUSE_DOWN_LOCATION].setCoordinates(mouseLocation)
	setWhiteboardState(MOUSE_DOWN_LOCATION, wState[MOUSE_DOWN_LOCATION])
	wState[PRINT_HEAD_LOCATION].setCoordinates(mouseLocation)
	tools[wState[TOOL]].mouseDown(mouseLocation)
      })
      dom[SENSOR].addEventListener('mousemove', (e) => {
	const mouseLocation = new Vector2(e.offsetX, e.offsetY)
	wState[MOUSE_MOVE_LOCATION].setCoordinates(mouseLocation)
	if (mouseIsDown) {
	  tools[wState[TOOL]].mouseMove(mouseLocation)
	}
      })
      dom[SENSOR].addEventListener('mouseup', (e) => {
	const mouseLocation = new Vector2(e.offsetX, e.offsetY)
	mouseIsDown = false
	wState[MOUSE_UP_LOCATION].setCoordinates(mouseLocation)
	tools[wState[TOOL]].mouseUp(mouseLocation)
      })

      document.body.addEventListener("touchstart", function (e) {
	if (e.target.id === SENSOR) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  mouseIsDown = true
	  wState[MOUSE_DOWN_LOCATION].setCoordinates(touchLocation)
	  setWhiteboardState(MOUSE_DOWN_LOCATION, wState[MOUSE_DOWN_LOCATION])
	  wState[PRINT_HEAD_LOCATION].setCoordinates(touchLocation)
	  tools[wState[TOOL]].mouseDown(touchLocation)
	}
      }, { passive: false })
      document.body.addEventListener("touchmove", function (e) {
	if (e.target === dom[SENSOR]) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  wState[MOUSE_MOVE_LOCATION].setCoordinates(touchLocation)
	  if (mouseIsDown) {
	    tools[wState[TOOL]].mouseMove(touchLocation)
	  }
	}
      }, { passive: false });
      document.body.addEventListener("touchend", function (e) {
	if (e.target === dom[SENSOR]) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  mouseIsDown = false
	  wState[MOUSE_UP_LOCATION].setCoordinates(touchLocation)
	  tools[wState[TOOL]].mouseUp(touchLocation)
	}
      }, { passive: false })

      dom[SENSOR].addEventListener('mouseup', (event) => {
	mouseIsDown = false;
	isDrawing = false
	let mouse = new Vector2(wState[MOUSE_MOVE_LOCATION].x, wState[MOUSE_MOVE_LOCATION].y)
	let width = mouse.x -wState[MOUSE_DOWN_LOCATION].x
	let height = mouse.y -wState[MOUSE_DOWN_LOCATION].y
      })

      

      dom[SENSOR].addEventListener('mouseout', () => {
	isDrawing = false
	mouseIsDown = false
      })

      dom[SENSOR].addEventListener('contextmenu', (e) => {
	isDrawing = false
	mouseIsDown = false
      })

      window.addEventListener('scroll', (e) => {
	hoursElement.style.top = `${-window.pageYOffset + 40}px`
	daysElement.style.left = `${-window.pageXOffset + 80}px`
      })

      document.addEventListener('keydown', (event) => {
	if (isTyping) {
	  typingFunction(event)
	}
	if (!keyIsDown) {
	  switch (event.key) {
	    /* case 'h':
	       if (!isTyping) {
	       alert('CONTROLS:\n\nShift: bold\nSpacebar: eraser\nz: box-eraser\nEscape: clear screen\ni: copy input\no: paste output\n\nCOLORS:\nr, g, b: red, green, blue\nc, m, y, k: cyan, magenta, yellow, black\nw: white\nf: color picker\n\nPEN SIZE:\n=: increase line-width\n-: decrease line-width\n\n')
	       alert('IMAGE:\np: reset image\n\nBACKGROUND OPACITY:\n`: clear background\n1 - 9: 0.1 - 0.9 opacity\n0: full opacity\n\nGRIDS:\nt: triangle grid\ns: square grid\nx: hexagonal grid\nd: square dots grid\n;: lined grid\n\nGRID COLOR:\nj: toggle white/black\nn: cycle through colors\n\nSLIDESHOW:\n(set theme to slideshow)\n.: forward one slide\n,: back one slide')
	       alert('CONSTRAINTS:\nUp: constrain to vertical line\nLeft: constrain to horizontal line\n/: constrain to parallel to line\nDown: constrain to vanishing point line\nRight: constrain to arc about vanishing point\nv: set vanishing point to mouse position\n\nTEXT:\na: enter text-mode\nesc: exit text-mode\n\nSHAPES\nq: draw rectangle\nl: draw line\ne: draw ellipse')
	       alert(`QUERY PARAMETERS: \ntitle: ${document.title}\ntheme: ${initialTheme}\nimage: ${imageURL}\nscreen: ${wState[SCREEN_SIZE].x} x ${wState[SCREEN_SIZE].y}\npens: ${query.pens || 'none'}\npenColor: ${pen.strokeStyle}\npenWidth: ${pen.lineWidth}\ngridColor: ${grid.strokeStyle}\ngridWidth: ${grid.lineWidth}\nbackgroundOpacity: ${currentBackgroundOpacity}\nbackground: ${background.fillStyle}\ncells: ${cells}\nzoom: ${zoom}\ngridtype: ${gridType}\neraseRadius: ${wState[ERASE_RADIUS]}`)
	       }
	       break; */
	  case 't':
	  case 'T':
	    if (!isTyping) {
	      lastTool = wState[TOOL]
	      setWhiteboardState(TOOL, TEXT)
	    
	      isTyping = true
	      drawTextCursor()
	    }
	    break;
	  case 'g':
	  case 'G':
	    wState[GRID_TYPE].setCoordinates((wState[GRID_TYPE].x + 1) % 4, wState[GRID_TYPE].y)
	    setGrid()
	    break
	  case 'j':
	  case 'J':
	    wState[GRID_TYPE].setCoordinates(wState[GRID_TYPE].x, (wState[GRID_TYPE].y + 1) % 3)
	    setGrid()
	    break;
	  case 'i':
	  case 'I':
	    if (!isTyping) {
	      wState[WALLPAPER_IMAGE] = getCollection(wState[SCREEN_SIZE])
	      setImage(WALLPAPER, wState[WALLPAPER_IMAGE])
	    }
	    break
	  case 's':
	  case 'S':
	    if (!isTyping) {
	      let name
	      if (wState[SAVE_PROMPT_ACTIVE]) {
		name = prompt('Please name this data', wState[MARKS_DATA])
	      } else {
		name = wState[MARKS_DATA]
	      }
	      if (name !== null) {
		wState[SAVED_MARKS_DATA][name] = dom[MARKS].toDataURL('image/png')
		setWhiteboardState(SAVED_MARKS_DATA, wState[SAVED_MARKS_DATA])
		console.log(`Saved ${name}`)
	      }
	      dom[MARKS].style.zIndex = "10";
	    }
	    break
	  case '.':
	    if (!isTyping) {
	      slide++
		clearLayer(WALLPAPER)
	      setImage(WALLPAPER, slideshow[slide % slideshow.length])
	      document.title = parseFilename(slideshow[slide % slideshow.length])
	    }
	    break
	  case ',':
	    if (!isTyping) {
	      slide--
		clearLayer(WALLPAPER)
	      setImage(WALLPAPER, slideshow[slide % slideshow.length])
	      document.title = parseFilename(slideshow[slide % slideshow.length])
	    }
	    break
	  case '-':
	    if (!isTyping && layers[MARKS].lineWidth > 1) {
	      setBrushWidth(parseInt(wState[BRUSHES][wState[BRUSH]].width) - 1)
	      setWhiteboardState(BRUSHES, wState[BRUSHES])
	      setWhiteboardState(ERASE_RADIUS, wState[ERASE_RADIUS])
	    } 
	    break;
	  case '=':
	    if (!isTyping) {
	      setBrushWidth(parseInt(wState[BRUSHES][wState[BRUSH]].width) + 1)
	      setWhiteboardState(BRUSHES, wState[BRUSHES])
	      setWhiteboardState(ERASE_RADIUS, wState[ERASE_RADIUS])
	    }
	    break;
	  case '[':
	    if (!isTyping && wState[FONT_HEIGHT] > 0) {
	      setFontHeight(wState[FONT_HEIGHT] - 1)
	    }
	    break
	  case ']':
	    if (!isTyping && wState[FONT_HEIGHT] < 13) {
	      setFontHeight(wState[FONT_HEIGHT] + 1)
	    }
	    break
	  case '`':
	    if (!isTyping) {
	      lastTool = wState[TOOL]
	      wState[TOOL] = PALETTE
	      if (wState[BRUSH] !== 10) {
		setWhiteboardState(BRUSH, 10)
		layers[MARKS].lineWidth = wState[BRUSHES][wState[BRUSH]].width
		setColor(wState[BRUSHES][wState[BRUSH]].color, layers[MARKS])
	      }
	      [isPickingColor, dom[PALETTE].style.display] = [true, 'initial']
	    }
	    break
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    if (!isTyping) {
	      lastTool = wState[TOOL]
	      wState[TOOL] = PALETTE
	      if (parseInt(event.key) !== wState[BRUSH]) {
		setWhiteboardState(BRUSH, parseInt(event.key))
		layers[MARKS].lineWidth = wState[BRUSHES][wState[BRUSH]].width
		setColor(wState[BRUSHES][wState[BRUSH]].color, layers[MARKS])
	      }
	      [isPickingColor, dom[PALETTE].style.display] = [true, 'initial']
	    }
	    break
	  case 'v':
	  case 'V':
	    if (!isTyping) {
	      setVanishingPoint(wState[MOUSE_MOVE_LOCATION].x, wState[MOUSE_MOVE_LOCATION].y)
	      wState[TOOL] = GRID
	    }
	    break
	  }
	
	}	
	keyIsDown = true
      })

      window.addEventListener("keydown", function (event) {
	if (event.defaultPrevented) {
	  return; // Do nothing if the event was already processed
	}
	switch (event.key) {
	case 'ArrowRight':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = ARC
	  } 
	  break
	case 'ArrowUp':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = VERTICAL
	  } else { 
	   wState[PRINT_HEAD_LOCATION].y -= wState[LINE_SPACING]
	    drawTextCursor()
	  }
	  break
	case 'ArrowLeft':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = HORIZONTAL
	  } else { 
	   wState[PRINT_HEAD_LOCATION].x -= wState[FONT_WIDTH]
	    drawTextCursor()
	  }
	  break
	case 'ArrowDown':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = VANISHING
	  } else { 
	   wState[PRINT_HEAD_LOCATION].y += wState[LINE_SPACING]
	    drawTextCursor()
	  }
	  break
	case 'Control':
	  if (!isTyping) {
	    constraint = [
	      COMMITTED, 
	      VERTICAL_HORIZONTAL,
	      HEXAGONAL,
	      VERTICAL_HORIZONTAL,
	      DIAGONAL, 
	      DOZENAL
	    ][
	      [RECTANGLE, ELLIPSE].includes(wState[TOOL]) 
		? 4
		: wState[TOOL] === LINE 
		  ? 5
		  : wState[GRID_TYPE].x
	    ]
	    if (constraint === COMMITTED) {
	      wState[TOOL] = COMMITTED
	    }
	  }
	  break
	case 'Shift':
	  if (!isTyping) {
	    shiftIsDown = true
	  }
	  break
	case '/':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = PARALLEL
	  } else { 
	   wState[PRINT_HEAD_LOCATION].x += wState[FONT_WIDTH]
	    drawTextCursor()
	  }
	  break
	case 'p':
	case 'P':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, PAINT_BRUSH)
	    lastTool = PAINT_BRUSH
	  }
	  break
	case 'r':
	case 'R':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, RECTANGLE)
	    lastTool = RECTANGLE
	  }
	  break
	case 'e':
	case 'E':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, ELLIPSE)
	    lastTool = ELLIPSE
	  }
	  break
	case 'l':
	case 'L':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, LINE)
	    lastTool = LINE
	  }
	  break
	case 'm':
	case 'M':
	  if (!isTyping) {
	    setWhiteboardState(TOOL, MEASURE)
	    lastTool = MEASURE
	  }
	  break
	case 'f':
	case 'F':
	  setWhiteboardState(FILL_ACTIVE, !wState[FILL_ACTIVE])
	  break
	case ' ':
	  event.preventDefault()
	  if (!isTyping) {
	    spaceIsDown = true;
	  }
	  break
	case 'Escape':
	  mouseIsDown = false
	  isDrawing = false
	  isDrawingRectangle = false
	  isDrawingEllipse = false
	  isDrawingLine = false
	  isErasing = false
	  isTyping = false
	  if (lastTool !== undefined) {
	    wState[TOOL] = lastTool
	  } else {
	    wState[TOOL] = defaultState[TOOL]
	  }
	  clearLayer(TOOLS)
	  break
	case 'Backspace':
	  if (!isTyping) {
	    clearLayer(MARKS)
	  } else {
	   wState[PRINT_HEAD_LOCATION].x -= wState[FONT_WIDTH]
	    layers[MARKS].clearRect(
	     wState[PRINT_HEAD_LOCATION].x, 
	     wState[PRINT_HEAD_LOCATION].y - fontSizes[wState[FONT_HEIGHT]], 
	      wState[FONT_WIDTH], 
	      fontSizes[wState[FONT_HEIGHT]] * 1.21
	    )
	    drawTextCursor()
	  }
	  break
	case 'Enter':
	  if (isTyping) {
	   wState[PRINT_HEAD_LOCATION].x = wState[MOUSE_DOWN_LOCATION].x
	   wState[PRINT_HEAD_LOCATION].y += wState[LINE_SPACING]
	    drawTextCursor()
	  }
	}
      });

      window.addEventListener("keyup", function (event) {
	if (event.defaultPrevented) {
	  return; // Do nothing if the event was already processed
	}

	switch (event.key) {
	case ' ':
	  if (!isTyping) {
	    spaceIsDown = false
	    break
	  }
	case 'ArrowRight':
	case 'ArrowUp':
	case 'ArrowLeft':
	case 'ArrowDown':
	case '/':
	case 'Control':
	  if (!isTyping) {
	    if (constraint === COMMITTED) {
	      wState[TOOL] = lastTool
	    }
	    constraint = NONE
	  }
	  break
	case '`':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (!isTyping) {
	    wState[TOOL] = lastTool
	    isPickingColor = false
	    dom[PALETTE].style.display = 'none'
	    break
	  }
	case 'Shift':
	  if (!isTyping) {
	    shiftIsDown = false
	  }
	  break
	case 's':
	case 'S':
	  if (!isTyping) {
	    dom[MARKS].style.zIndex = "6";
	  }
	  break
	case 'v':
	case 'V':
	  if (!isTyping) {
	    wState[TOOL] = lastTool
	    break
	  }
	}
	keyIsDown = false
      })

      // INITIALIZATION
      let isDrawing = false
      let isErasing = false
      let isBoxErasing = false
      let isCopying = false
      let isPickingColor = false
      let clipboard
      let isDrawingRectangle = false
      let isDrawingLine = false
      let isTyping = false
      let constraint = NONE
      let storedFunctions = []
      let currentMouse

      const query = parseQueryString(window.location.href)
      const wState = {}
      Object.assign(
	wState, 
	{
	  ...defaultState,
	  ...JSON.parse(localStorage.getItem(WHITEBOARD_STATE)),
	  ...wState,
	  ...query
	}
      )
      wState[SCREEN_SIZE] = query[SCREEN_SIZE] 
	? new Vector2(query[SCREEN_SIZE]) 
	: new Vector2(window.screen.width, window.screen.height)
      wState[BOARD_SIZE] = query[BOARD_SIZE]
	? new Vector2(query[BOARD_SIZE]) 
	: new Vector2(
	  wState[SCREEN_SIZE].x * defaultState[BOARD_SCALE].x,
	  wState[SCREEN_SIZE].y * defaultState[BOARD_SCALE].y
	)
      wState[WALLPAPER_IMAGE] = query[WALLPAPER_IMAGE] || getCollection(wState[SCREEN_SIZE])
      wState[ANGLE] = Number(wState[ANGLE])
      wState[BRUSH] = Number(wState[BRUSH])
      wState[ERASE_RADIUS] = Number(wState[ERASE_RADIUS])
      wState[GRID_WIDTH] = Number(wState[GRID_WIDTH])
      wState[ZOOM] = Number(wState[ZOOM])
      if (wState.hasOwnProperty(VANISHING_POINT)) {
	wState[VANISHING_POINT] = new Vector2(wState[VANISHING_POINT])
      } else {
	wState[VANISHING_POINT] = new Vector2(
	  wState[SCREEN_SIZE].x / 2,
	  wState[SCREEN_SIZE].y / 2
	)
      }
      wState[MOUSE_DOWN_LOCATION] = new Vector2(wState[MOUSE_DOWN_LOCATION])
      wState[MOUSE_MOVE_LOCATION] = new Vector2(wState[MOUSE_MOVE_LOCATION])
      wState[MOUSE_UP_LOCATION] = new Vector2(wState[MOUSE_UP_LOCATION])
      wState[PRINT_HEAD_LOCATION] = new Vector2(wState[PRINT_HEAD_LOCATION])
      wState[MEASUREMENT] = new Vector2(wState[MEASUREMENT])
      wState[OVERLAY_COLOR] = new Color(wState[OVERLAY_COLOR])
      wState[GRID_COLOR] = new Color(wState[GRID_COLOR])
      wState[GRID_TYPE] = new Vector2(wState[GRID_TYPE])
      wState[SQUARE_GRID_UNITS] = new Vector2(wState[SQUARE_GRID_UNITS])
      wState[TIME_PADDING] = new Vector2(wState[TIME_PADDING])
      wState[BRUSHES].forEach((brush) => {
	brush.color = new Color(brush.color)
      })
      wState[TOOLS_COLOR] = new Color(wState[TOOLS_COLOR])
      wState[SAVE_PROMPT_ACTIVE] = query.hasOwnProperty(SAVE_PROMPT_ACTIVE)
	? query[SAVE_PROMPT_ACTIVE] 
	: defaultState[SAVE_PROMPT_ACTIVE]
      let lastTool 
      if (wState[TOOL] === PALETTE
	|| wState[TOOL] === GRID
	|| wState[TOOL] === COMMITTED) {
	setWhiteboardState(TOOL, PAINT_BRUSH)
      }
      lastTool= wState[TOOL]

      dom[PROBLEM].style.display = 'none'
      dom[PALETTE].style.display = 'none'
      layers[MARKS].lineJoin = 'round'
      layers[MARKS].lineCap = 'round'

      applyState(wState)

      document.title = query[DOCUMENT_TITLE] || query[MARKS_DATA] || 'Whiteboard' 
      /* || query[MARKS_IMAGE] 
	 ? parseFilename(query[MARKS_IMAGE]) 
	 : query[WALLPAPER_IMAGE] 
	 ? parseFilename(query[WALLPAPER_IMAGE]) 
	 : 'Whiteboard' */
      query[MARKS_IMAGE] && setImage(MARKS, query[MARKS_IMAGE])
      
      console.log(`Wallpaper Image: ${wState[WALLPAPER_IMAGE]}`)
      if (query[PROBLEM_IMAGE]) {
	const problemImg = document.createElement('img')
	problemImg.src = query[PROBLEM_IMAGE]
	  dom[PROBLEM].appendChild(problemImg)	
      }
      if (wState[TOOL] === TEXT) {
	drawTextCursor()
	isTyping = true
      }
      if (wState[SAVED_MARKS_DATA][query[MARKS_DATA]]) {
	setImage(MARKS, wState[SAVED_MARKS_DATA][query[MARKS_DATA]])
      }
    </script>
  </body>
</html>
