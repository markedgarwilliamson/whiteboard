<!DOCTYPE html>
<!-- Begin license text.
     Copyright 2019 DAVID WILLIAMSON
     Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     End license text. -->
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, height=device-height initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="apple-mobile-web-app-capable" content="yes" /> 
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style> 
     body {
       font-family: 'Courier New';
     }

     body::-webkit-scrollbar { 
       display: none;
     }

     .time {
       display: none;
       justify-content: space-around;
       align-items: center;
       position: fixed;
     }

     #DAYS {
       height: 40px;
       left: 80px;
     }

     #HOURS {
       flex-direction: column;
       width: 80px;
       top: 40px;
     }

     #HOURS p {
       margin: 0;
     }
    </style> 
  </head>
  <body style="margin: 0; cursor: crosshair; position: absolute;">
    <div id="WALLPAPER"></div>
    <div id="OVERLAY" style="position: absolute; left: 0px; top: 0px; z-index: 2;"></div>
    <div id="GRID" style="position: absolute; left: 0px; top: 0px; z-index: 4;"></div>
    <div id="PROBLEM" style="position: absolute; left: 0px; top: 0px; z-index: 5;"></div>
    <canvas id="MARKS" style="position: absolute; left: 0px; top: 0px; z-index: 6;"></canvas>
    <canvas id="PALETTE" style="position: fixed; left: 0px; top: 0px; z-index: 7;"></canvas>
    <div id="TOOLS" style="position: absolute; left: 0px; top: 0px; z-index: 8;">
      <div id="HOURS" class="time"></div>
      <div id="DAYS" class="time"></div>
    </div>
    <div id="SENSOR" style="position: absolute; left: 0px; top: 0px; z-index: 9;"></div>
    
    <script>
      // CLASSES
      class Color {
	constructor(shade, alpha) {
	  const arrayToRgb = (arr) => {
	    this.red = arr[0]
	    this.green = arr[1]
	    this.blue = arr[2]
	  }

	  const rgbToHsl = (red, green, blue) => {
	    const cMax = Math.max(red, green, blue)
	    const cMin = Math.min(red, green, blue)
	    const delta = cMax - cMin

	    this.lum = (cMax + cMin) / 510
	    this.sat = delta === 0 ? 0 : delta / ((1 - Math.abs(2 * this.lum - 1)) * 255)	

	    switch (true) {
	    case (delta === 0):
	      this.hue = 0
	      break
	    case (cMax === red):
	      this.hue = 60 * (((green - blue) / delta) % 6)
	      break
	    case (cMax === green):
	      this.hue = 60 * (((blue - red) / delta) + 2)
	      break
	    case (cMax === blue):
	      this.hue = 60 * (((red - green) / delta) + 4)
	    }
	    this.hue = (this.hue + 360) % 360
	  }
	  
	  const hslToRgb = (hue, sat, lum) => {
	    const c = (1 - Math.abs(2 * lum - 1)) * sat
	    const x = c * (1 - Math.abs((hue / 60) % 2 - 1))
	    const m = lum - c / 2

	    let rgb
	    switch (true) {
	    case (hue >= 0 && hue < 60):
	      rgb = [c, x, 0]
	      break
	    case (hue >= 60 && hue < 120):
	      rgb = [x, c, 0]
	      break
	    case (hue >= 120 && hue < 180):
	      rgb = [0, c, x]
	      break
	    case (hue >= 180 && hue < 240):
	      rgb = [0, x, c]
	      break
	    case (hue >= 240 && hue < 300):
	      rgb = [x, 0, c]
	      break
	    case (hue >= 300 && hue <= 360):
	      rgb = [c, 0, x]
	      break
	    }
	    arrayToRgb(rgb.map((channel) => Math.round((channel + m) * 255)))
	  }

	  let colorArray = []
	  if (typeof shade === 'string') {
	    if (!/^#/.test(shade)) {
	      colorArray = mapStringToNumberArray(shade)
	    }
	    
	    if (/^hsl/.test(shade)) {
	      this.hue = parseInt(colorArray[0])
	      this.sat = parseInt(colorArray[1]) / 100
	      this.lum = parseInt(colorArray[2]) / 100
	
	      hslToRgb(this.hue, this.sat, this.lum)
	    } else {
	      if (/^#/.test(shade)) {
		this.red = parseInt(shade.slice(1, 3), 16)
		this.green = parseInt(shade.slice(3, 5), 16)
		this.blue = parseInt(shade.slice(5, 7), 16)
	      } else {
		arrayToRgb(colorArray)
	      }
	      
	      rgbToHsl(this.red, this.green, this.blue)
	    }
	  } else if (Array.isArray(shade)) {
	    colorArray = shade
	    arrayToRgb(colorArray)
	    rgbToHsl(this.red, this.green, this.blue)
	  } else if (typeof shade === 'object') {
	    Object.assign(this, shade)
	  }
	  if (colorArray[3] !== undefined) {
	    this.alpha = parseFloat(colorArray[3])
	  } else {
	    if (this.alpha === undefined) {
	      this.alpha = alpha || 1.0
	    }
	  }
	}

	getHexadecimal () {
	  return `#${this.red.toString(16).padStart(2,'0').toUpperCase()}${this.green.toString(16).padStart(2,'0').toUpperCase()}${this.blue.toString(16).padStart(2,'0').toUpperCase()}`
	}

	getRgb () {
	  return `rgba(${this.red}, ${this.green}, ${this.blue})`
	}

	getRgba () {
	  return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`
	}

	getHsl () {
	  return `hsl(${this.hue}, ${Math.round(this.sat * 100)}%, ${Math.round(this.lum * 100)}%)`
	}

	getHsla () {
	  return `hsla(${this.hue}, ${Math.round(this.sat * 100)}%, ${Math.round(this.lum * 100)}%, ${this.alpha})`
	}

	getPixelData () {
	  return [this.red, this.green, this.blue, Math.round(this.alpha * 255)]
	}

	modify (color) {
	  const temporaryShade = new Color(this)
	  if (color.hasOwnProperty('red') || color.hasOwnProperty('blue') || color.hasOwnProperty('green')) {
	    Object.assign(temporaryShade, color)
	    Object.assign(this, new Color(temporaryShade.getRgba()))
	  } if (color.hasOwnProperty('hue') || color.hasOwnProperty('sat') || color.hasOwnProperty('lum')) {
	    Object.assign(temporaryShade, color)
	    Object.assign(this, new Color(temporaryShade.getHsla()))
	  } else {
	    Object.assign(this, color)
	  }
	  return this
	}
      }

      class Vector2 {
	constructor(a, b) {
	  let x
	  let y
	  if (typeof a === 'object') {
	    if (a.hasOwnProperty('x') && a.hasOwnProperty('y')) {
	      [x, y] = [a.x, a.y]
	    } else if (a.hasOwnProperty('angle')) {
	      const magnitude = a.magnitude || 1
	      x = Math.cos(a.angle) * magnitude
	      y = Math.sin(a.angle) * magnitude
	    }
	  } else {
	    [x, y] = [a, b]
	  }
	  this.setCoordinates(x, y)
	}
	
	setCoordinates (x, y) {
	  if (typeof x === 'string') {
	    x = mapStringToNumberArray(x)
	  }
	  if (typeof x === 'object') {
	    if (Array.isArray(x)) {
	      Object.assign(this, {
		x: x[0],
		y: x[1]
	      })
	    } else {
	      Object.assign(this, x)
	    }
	  } else {
	    Object.assign(this, { x, y })
	  }
	}
	
	setRectangularOffset (x, y) {
	  if (typeof x === 'string') {
	    x = mapStringToNumberArray(x)
	  }
	  if (typeof x === 'object') {
	    if (Array.isArray(x)) {
	      Object.assign(this, {
		x: x[0],
		y: x[1]
	      })
	    } else {
	      Object.assign(this, x.scale(wState[RECTANGULAR_OFFSET]))
	    }
	  } else {
	    Object.assign(this, { 
	      x: x * wState[RECTANGULAR_OFFSET].x,
	      y: y * wState[RECTANGULAR_OFFSET].y
	    })
	  }
	}
	
	setHexOffset (magnitude, angle) {
	  if (typeof magnitude === 'string') {
	    magnitude = mapStringToNumberArray(magnitude)
	  }
	  if (typeof magnitude === 'object') {
	    if (Array.isArray(magnitude)) {
	      Object.assign(this, new Vector2({
		magnitude: magnitude[0] * wState[HEX_MAGNITUDE],
		angle: magnitude[1]
	      }))
	    } else {
	      Object.assign(this, new Vector2({ 
		magnitude: magnitude.getMagnitude() * wState[HEX_MAGNITUDE],
		angle: magnitude.getAngle()
	      }))
	    }
	  } else {
	    Object.assign(this, new Vector2({ 
	      magnitude: magnitude * wState[HEX_MAGNITUDE], 
	      angle
	    }))
	  }
	}

	getRectangularOffset () {
	  return new Vector2(
	    this.x / wState[RECTANGULAR_OFFSET].x,
	    this.y / wState[RECTANGULAR_OFFSET].y
	  )
	}

	getHexOffset () {
	  return new Vector2(
	    this.x / wState[HEX_MAGNITUDE],
	    this.y / wState[HEX_MAGNITUDE]
	  )
	}

	getCircumference () {
	  return this.getAngle() * this.getMagnitude()
	}

	getCalendarDays () {
	  if (
	    this.x > wState[TIME_PADDING].x
	      && this.x < (wState[SCREEN_SIZE].x - wState[TIME_PADDING].x)
	      && this.y > (wState[TIME_PADDING].y * 4)
	      && this.y < (wState[SCREEN_SIZE].y - wState[TIME_PADDING].y)
	  ) {
	    return new Vector2(
	      Math.floor((this.x - wState[TIME_PADDING].x) / wState[CALENDAR_OFFSET].x),
	      Math.floor((this.y - wState[TIME_PADDING].y * 4) / wState[CALENDAR_OFFSET].y)
	    )	    
	  }
	}
	
	getPlannerHours () {
	  if (this.x > wState[TIME_PADDING].x && this.y > wState[TIME_PADDING].y) {
	    return new Vector2(
	      Math.floor((this.x - wState[TIME_PADDING].x) / wState[PLANNER_OFFSET].x),
	      (this.y - wState[TIME_PADDING].y) / (wState[PLANNER_OFFSET].y * 2)
	    )
	  }
	}
	
	getClockTime () {
	  return ((this.getAngle(getCenter()) + (Math.PI / 2)) * 30 / Math.PI) % 60
	}

	copy () {
	  return new Vector2(this.x, this.y);
	}

	add (v) {
	  return new Vector2(this.x + v.x, this.y + v.y);
	}

	scale (s) {
	  if (typeof s === 'number') {
	    s = new Vector2(s, s)
	  }
	  return new Vector2(this.x * s.x, this.y * s.y)
	}

	getMagnitude (v) {
	  if (!v) {
	    v = new Vector2(0, 0)
	  }
	  return Math.sqrt((this.x - v.x) ** 2 + (this.y - v.y) ** 2);
	}

	dot (v) {
	  return this.x * v.x + this.y * v.y
	}

	project (lineAngle=0, linePoint=globalOrigin) {
	  if (typeof linePoint === 'number') {
	    linePoint = new Vector2(0, linePoint)
	  }
	  const lineSlope = Math.tan(lineAngle)
	  const lineYIntercept = linePoint.y - lineSlope * linePoint.x
	  const thisSlope = -(lineSlope ** -1)
	  const thisYIntercept = this.y - thisSlope * this.x
	  const thisX = (thisYIntercept - lineYIntercept) / (lineSlope - thisSlope)
	  return new Vector2(
	    thisX,
	    lineSlope * thisX + lineYIntercept
	  )
	}

	getSlope (v=globalOrigin) {
	  (this.y - v.y) / (this.x - v.x)
	}

	getAngle (v=globalOrigin) {
	  if (this.x === v.x) {
	    return this.y > v.y 
	      ? Math.PI / 2 
	      : Math.PI * 3 / 2
	  } else {
	    let a = Math.atan((this.y - v.y) / (this.x - v.x))
	    if (this.x < v.x) {
	      a += Math.PI
	    } else if (this.y < v.y) {
	      a += 2 * Math.PI
	    }
	    return a % (2 * Math.PI)
	  }
	}

	getPolarCoordinates () {
	  return {
	    angle: this.getAngle(),
	    magnitude: this.getMagnitude()
	  }
	}

	setMagnitude (scale=1) {
	  return this.scale(1/this.getMagnitude()).scale(scale)
	}

	transform (matrix) {
	  return new Vector2(
	    this.x * matrix.a + this.y * matrix.b, 
	    this.x * matrix.c + this.y * matrix.d
	  )
	}

	rotate (angle) {
	  return this.transform({ 
	    a: Math.cos(angle),
	    b: -Math.sin(angle),
	    c: Math.sin(angle),
	    d: Math.cos(angle)
	  })
	}
      }

      // UTILITIES
      const bound = (value, min=0.0, max=1.0) => {
	return value < min 
	  ? min 
	  : value > max 
	    ? max 
	    : value
      }
      
      const absoluteModulus = (value, increment) => {
	if (value < 0) {
	   value += Math.ceil(Math.abs(value) / Math.abs(increment)) * Math.abs(increment)
	}
	return value % increment
      }

      const parseFilename = (name) => name.split('/').pop().split('.').slice(0, -1).join('.')
      const tabTitle = (paths) => {
	let names = []
	for (path of paths) {
	  names.push(parseFilename(path))
	}
	return names.join(', ')
      }

      const mapStringToNumberArray = (s) => {
	return s.match(/[+-]?([0-9]*[.])?[0-9]+/g)
	  .map((element) => Number(element))
      }

      const parseQueryString = (url) => {
	const queryString = /\?/.test(url) && url.substring(url.search(/\?/) + 1)
	if (queryString) {
	  return queryString.split('&').reduce(
	    (query, pair) => {
	      const [param, input] = pair.split('=')
	      let value = input
	      if (param.includes('active')) {
		if (/(false|0)/.test(input)) {
		  value = false
		} else {
		  value = new Boolean(input)
		}
	      } else if (!param.includes('image') && /[+-]?([0-9]*[.])?[0-9]+/g.test(input)) {
		value = mapStringToNumberArray(value)
		value = value.length === 2 
		  ? { x: value[0], y: value[1] } 
		  : value.length === 1 
		  ? value[0] 
		  : value
	      }
	      query[param.replace(/-/g, '_').toUpperCase()] = value
	      return query
	    },
	    {}
	  )
	}
	return {}
      }

      const getCollection = (size, query) => {
	const collection = query ? query.collection : unsplashCollections[Math.floor((Math.random() * unsplashCollections.length))]
	return `https://source.unsplash.com/collection/${collection}/${size.x}x${size.y}`
      }

      const setWhiteboardState = (key, value) => { 
	if (value !== undefined) {
	  wState[key] = value
	}
	localStorage.setItem(
	  WHITEBOARD_STATE, 
	  JSON.stringify(wState)
	)
	return value
      }

      const applyState = (state) => {
	document.title = state[DOCUMENT_TITLE]

	for (element in dom) {	
	  if (dom[element].nodeName === 'DIV') {
	    [
	      dom[element].style.width, 
	      dom[element].style.height
	    ] = [
	      `${(state[BOARD_SIZE].x).toString()}px`, 
	      `${(state[BOARD_SIZE].y).toString()}px`
	    ]
	  } else {
	    [
	      dom[element].width, 
	      dom[element].height
	    ] = [
	      state[BOARD_SIZE].x, 
	      state[BOARD_SIZE].y
	    ]
	  }
	}
	setImage(WALLPAPER, state[WALLPAPER_IMAGE])
	setColor(state[OVERLAY_COLOR], dom[OVERLAY])
	setColor(state[GRID_COLOR], layers[GRID])
	setGrid(state[GRID_TYPE])
	for (let layer of [GRID, TOOLS]) {
	  layers[layer].setAttribute('width', state[BOARD_SIZE].x.toString())
	  layers[layer].setAttribute('height', (state[BOARD_SIZE].y).toString())
	  layers[layer].setAttribute('viewBox', `0 0 ${state[BOARD_SIZE].x} ${state[BOARD_SIZE].y}`)
	  layers[layer].setAttribute('xmlns', svgNameSpace)
	}
	
	// initialize planner headers
	Object.assign(daysElement.style, {
	  color: state[GRID_COLOR].getRgba(),
	  background: state[TOOLS_COLOR].getRgba()
	})
	Object.assign(hoursElement.style, {
	  color: state[GRID_COLOR].getRgba(),
	  background: state[TOOLS_COLOR].getRgba(),
	  height: `${wState[BOARD_SIZE].y  - 40}px`
	})
	for (let day of weekdays) {
	  const span = document.createElement('span')
	  span.innerHTML = day
	  daysElement.appendChild(span)
	}
	for (let hour = 0; hour < 24; hour ++) {
	  const p1 = document.createElement('p')
	  const p2 = document.createElement('p')
	  p1.innerHTML = `${((hour + 6) % 24).toString().padStart(2, '0')}:00`
	  p2.innerHTML = `${((hour + 6) % 24).toString().padStart(2, '0')}:30`
	  hoursElement.appendChild(p1)
	  hoursElement.appendChild(p2)
	}
	setGrid()
	setBrushWidth(state[BRUSHES][state[BRUSH]].width)
	setFontHeight(state[FONT_HEIGHT])
	setColor(state[BRUSHES][state[BRUSH]].color, layers[MARKS])
      }

      const readPalette = (pixelLocation, c, sideLength=colorWheelSideLength) => {
	const color = new Color(c)
	const prop = {}
	const wheelCenter = new Vector2(
	  sideLength * 7 / 16, 
	  sideLength * 7 / 16
	)
	const distance = pixelLocation.getMagnitude(wheelCenter)
	let { hue, sat, lum, alpha } = color
	if (distance <= sideLength * 7 / 16) {
	  if(distance > sideLength * 1 / 16) {
	    hue = 360 - (pixelLocation.getAngle(wheelCenter) * 180 / Math.PI)
	  }
	  prop.sat = sat = bound((distance - (sideLength * 1 / 16)) * 4 / sideLength)
	} else if (
	  (pixelLocation.x > wheelCenter.x || pixelLocation.y > wheelCenter.y) 
	    && distance > sideLength * 7 / 16
	) {
	  if (pixelLocation.x < pixelLocation.y) {
	    prop.alpha = alpha = bound((((pixelLocation.x - (sideLength * 3 / 16)) / 2) * 4 / sideLength))
	  } else {
	    prop.lum = lum = bound((((sideLength / 2) - (pixelLocation.y - (sideLength * 3 / 16))) / 2) * 4 / sideLength)
	  }
	}
	return {
	  color: new Color(`hsla(${hue}, ${sat * 100}%, ${lum * 100}%, ${alpha})`),
	  prop: prop
	}
      }

      const displayImg = (context, obj) => {
	if (!obj.complete){
	  setTimeout(() => {
	    displayImg(context, obj);
	  }, 50);
	  return;
	}

	/* if (wState[ZOOM] < 2) {
	   let scale;
	   let z = [
	   wState[SCREEN_SIZE].y / wState[SCREEN_SIZE].x > obj.naturalHeight / obj.naturalWidth,
	   wState[SCREEN_SIZE].y / wState[SCREEN_SIZE].x < obj.naturalHeight / obj.naturalWidth
	   ][wState[ZOOM]]
	   if (z) {
	   scale = wState[SCREEN_SIZE].x / obj.naturalWidth
	   } else {
	   scale = wState[SCREEN_SIZE].y / obj.naturalHeight
	   }
	   
	   context.drawImage(obj,
	   (wState[SCREEN_SIZE].x - obj.naturalWidth * scale) / 2,
	   (wState[SCREEN_SIZE].y - obj.naturalHeight * scale) / 2,
	   obj.naturalWidth * scale,
	   obj.naturalHeight * scale
	   )
	   } else {
	   let scale = wState[SCREEN_SIZE].y / wState[SCREEN_SIZE].x < obj.naturalHeight / obj.naturalWidth 
	   ? wState[SCREEN_SIZE].x / obj.naturalWidth 
	   : wState[SCREEN_SIZE].y / obj.naturalHeight
	   if (wState[ZOOM] > 2) {
	   scale = 1
	   }
	   for (let layer in canvas) {
	   canvas[layer].width = wState[SCREEN_SIZE].x = obj.naturalWidth * scale
	   canvas[layer].height = wState[SCREEN_SIZE].y = obj.naturalHeight * scale
	   } */
	  context.drawImage(obj, 0, 0, wState[BOARD_SIZE].x, wState[BOARD_SIZE].y)
      }

      const setImage = (layer, src, style) => {
	if (dom[layer].nodeName === 'DIV') {
	  if (layer === WALLPAPER) {
	    dom[WALLPAPER].style.background = `url(${src})`
	    dom[WALLPAPER].style.backgroundAttachment = 'fixed'
	    dom[WALLPAPER].style.backgroundRepeat = 'no-repeat'
	    dom[WALLPAPER].style.backgroundSize = `${wState[SCREEN_SIZE].x}px ${wState[SCREEN_SIZE].y}px`
	  } else {
	    img = document.createElement('img')
	    img.src = src
	    if (style) {
	      Object.assign(img.style, style)
	    } else {
	      img.width = wState[SCREEN_SIZE].x
	    }
	    dom[layer].appendChild(img)
	  }
	} else {
	  imageURL = src
	  if (typeof src === 'object' && src.data.includes('data:image/png;base64')) {
	    console.log(`marks-image: ${src.name}`)
	  } else if (src.includes('collection')) {
	    if (navigator.onLine) {
	      console.log(`collection: ${src.split('/')[4]}`)
	    } else {
	      setColor('#7F7F7F', dom[WALLPAPER])
	      console.log('currently offline')
	      return
	    }
	  }
	  clearLayer(layer)
	  let img = new Image()
	  img.src = src
	  displayImg(layers[layer], img)
	  layers[layer].drawImage(img, 0, 0, wState[BOARD_SIZE].x, wState[BOARD_SIZE].y)
	}
      }

      const toggleWallpaperStyle = () => {
	if (dom[WALLPAPER].style.backgroundAttachment === 'fixed') {
	  dom[WALLPAPER].style.backgroundAttachment = 'scroll'
	} else {
	  dom[WALLPAPER].style.backgroundAttachment = 'fixed'
	}
	if (dom[WALLPAPER].style.backgroundSize === `${wState[SCREEN_SIZE].x}px ${wState[SCREEN_SIZE].y}px`) {
	  dom[WALLPAPER].style.backgroundSize = 'cover'
	} else {
	  dom[WALLPAPER].style.backgroundSize = `${wState[SCREEN_SIZE].x}px ${wState[SCREEN_SIZE].y}px`
	}
      }

      const clearLayer = (input, removeMeasurement) => {
	const layer = typeof input === 'string' ?  layers[input] : input
	if (layer.nodeName === 'svg') {
	  let measured = document.getElementById('measurement')
	  layer.innerHTML = ''
	  if (input === TOOLS && !removeMeasurement && measured) {
	    layers[TOOLS].appendChild(measured)
	  }
	} else if (layer.nodeName !== 'DIV') {
	  layer.clearRect(
	    0, 
	    0, 
	    wState[BOARD_SIZE].x, 
	    wState[BOARD_SIZE].y
	  )
	}
      }

      const logMarksData = () => {
	const names = []
	for (let name in wState[SAVED_MARKS_DATA]) {
	  names.push(name)
	}
	return names
      }
      
      const clearMarksData = (name) => {
	if (name) {
	  delete wState[SAVED_MARKS_DATA][name]
	  setWhiteboardState(SAVED_MARKS_DATA)
	} else {
	  setWhiteboardState(SAVED_MARKS_DATA, {})
	}
      }

      // STATIC VARIABLES
      // MAGIC STRINGS
      const WHITEBOARD_STATE = 'WHITEBOARD_STATE'
      const PAINT_BRUSH = 'PAINT_BRUSH' // p
      const ELLIPSE = 'ELLIPSE' // e
      const RECTANGLE = 'RECTANGLE' // r
      const LINE = 'LINE' // l
      const ARC = 'ARC' // a
      const TEXT = 'TEXT' // t
      const ERASER = 'ERASER' // spacebar (held)
      const BOX_ERASER = 'BOX_ERASER' // x
      const MEASURE = 'MEASURE' // m
      const ZOOM = 'ZOOM'// z
      const PALETTE = 'PALETTE' // `, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 (held)
      const SELECT = 'SELECT'
      
      const WALLPAPER = 'WALLPAPER'
      const OVERLAY = 'OVERLAY'
      const GRID = 'GRID'
      const PROBLEM = 'PROBLEM'
      const TOOLS = 'TOOLS'
      const DAYS = 'DAYS'
      const HOURS = 'HOURS'
      const TIME_PADDING = 'TIME_PADDING'
      const CALENDAR_OFFSET = 'CALENDAR_OFFSET'
      const PLANNER_OFFSET = 'PLANNER_OFFSET'
      const CLOCK_ANGLES = 'CLOCK_ANGLES'
      const MARKS = 'MARKS'
      const SENSOR = 'SENSOR'

      const DOCUMENT_TITLE = 'DOCUMENT_TITLE' // String
      const SCREEN_SIZE = 'SCREEN_SIZE' // Vector2 *
      const BOARD_SIZE = 'BOARD_SIZE' // Vector2 *
      const BOARD_SCALE = 'BOARD_SCALE' // Vector2 *
      const WALLPAPER_IMAGE = 'WALLPAPER_IMAGE' // String, not stored
      const OVERLAY_COLOR = 'OVERLAY_COLOR' // Color *
      const GRID_TYPE = 'GRID_TYPE'
      const RECTANGULAR_OFFSET = 'RECTANGULAR_OFFSET'
      const HEX_MAGNITUDE = 'HEX_MAGNITUDE'
      const HEX_ANGLE = 'HEX_ANGLE'
      const GRID_COLOR = 'GRID_COLOR'
      const GRID_WIDTH = 'GRID_WIDTH'
      const PROBLEM_IMAGE = 'PROBLEM_IMAGE' // String
      const VANISHING_POINT = 'VANISHING_POINT' // Vector2 *
      const TOOL = 'TOOL' // String, not stored
      const TOOLS_COLOR = 'TOOLS_COLOR'
      const MARKS_IMAGE = 'MARKS_IMAGE' // String, not stored
      const BRUSH = 'BRUSH' // Number
      const BRUSHES = 'BRUSHES' // Object { width: Number, color: Color * }
      const FONT = 'FONT' // string
      const FONT_HEIGHT = 'FONT_HEIGHT' // number
      const FONT_WIDTH = 'FONT_WIDTH' // number
      const LINE_SPACING = 'LINE_SPACING' // number
      const FILL_ACTIVE = 'FILL_ACTIVE' // Boolean
      const ANGLE = 'ANGLE' // Number
      const ERASE_RADIUS = 'ERASE_RADIUS' // Number
      const MOUSE_DOWN_LOCATION = 'MOUSE_DOWN_LOCATION' // Vector2 *
      const MOUSE_MOVE_LOCATION = 'MOUSE_MOVE_LOCATION' // Vector2 *
      const MOUSE_UP_LOCATION = 'MOUSE_UP_LOCATION' // Vector2 *
      const PRINT_HEAD_LOCATION = 'PRINT_HEAD_LOCATION' // Vector2 *
      const MEASUREMENT = 'MEASUREMENT' // Vector2 *
      const FUNCTIONS = 'FUNCTIONS' // temporary array
      const MARKS_DATA = 'MARKS_DATA' // String
      const SAVED_MARKS_DATA = 'SAVED_MARKS_DATA' // Object: { <name>: <dataURI> }
      const MARKS_HISTORY_LENGTH = 'MARKS_HISTORY_LENGTH'

      const NONE = 'NONE'
      const VANISHING = 'VANISHING'
      const HORIZONTAL = 'HORIZONTAL'
      const VERTICAL = 'VERTICAL'
      const PARALLEL = 'PARALLEL'
      const PERPENDICULAR = 'PERPENDICULAR'
      const DOZENAL = 'DOZENAL'
      const VERTICAL_HORIZONTAL  = 'VERTICAL_HORIZONTAL '
      const HEXAGONAL = 'HEXAGONAL'
      const DIAGONAL = 'DIAGONAL'
      const COMMITTED = 'COMMITTED'
      const COMMIT_RADIUS = 'COMMIT_RADIUS'

      const dom = {}
      dom[WALLPAPER] = document.getElementById(WALLPAPER)
      dom[OVERLAY] = document.getElementById(OVERLAY)
      dom[GRID] = document.getElementById(GRID)
      dom[PROBLEM] = document.getElementById(PROBLEM)
      dom[PALETTE] = document.getElementById(PALETTE)
      dom[TOOLS] = document.getElementById(TOOLS)
      daysElement = document.getElementById(DAYS)
      hoursElement = document.getElementById(HOURS)
      dom[MARKS] = document.getElementById(MARKS)
      dom[SENSOR] = document.getElementById(SENSOR)
      
      const layers = {}
      layers[PALETTE] = dom[PALETTE].getContext('2d')
      layers[MARKS] = dom[MARKS].getContext('2d')
      const svgNameSpace = 'http://www.w3.org/2000/svg'
      layers[GRID] = document.createElementNS(svgNameSpace, 'svg')
      dom[GRID].appendChild(layers[GRID])
      layers[TOOLS] = document.createElementNS(svgNameSpace, 'svg')
      dom[TOOLS].appendChild(layers[TOOLS])

      const constraints = {}
      constraints[COMMITTED] = constraints[NONE] = (toolLocation) => toolLocation
      constraints[VANISHING] = (toolLocation) => constrainLine(wState[VANISHING_POINT], wState[MOUSE_DOWN_LOCATION], toolLocation)
      constraints[ARC] = (toolLocation) => constrainArc(wState[VANISHING_POINT], wState[MOUSE_DOWN_LOCATION], toolLocation)
      constraints[HORIZONTAL] = (toolLocation) => new Vector2(toolLocation.x, wState[MOUSE_DOWN_LOCATION].y)
      constraints[VERTICAL] = (toolLocation) => new Vector2(wState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
      constraints[PARALLEL] = (toolLocation) => constrainLine(
	wState[MOUSE_DOWN_LOCATION].add(new Vector2(
	  Math.cos(wState[ANGLE]), 
	  Math.sin(wState[ANGLE])
	)),
	wState[MOUSE_DOWN_LOCATION],
	toolLocation
      )
      constraints[PERPENDICULAR] = (toolLocation) => constrainLine(
	wState[MOUSE_DOWN_LOCATION].add(new Vector2(
	  Math.sin(wState[ANGLE]), 
	  -Math.cos(wState[ANGLE])
	)),
	wState[MOUSE_DOWN_LOCATION],
	toolLocation
      )
      constraints[DOZENAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case (angle > Math.PI * 23 / 24) || (angle <= Math.PI / 24):
	  return new Vector2(toolLocation.x, wState[MOUSE_DOWN_LOCATION].y)
	  break
	case (angle > Math.PI / 24) && (angle <= Math.PI * 3 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 12 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 3 / 24) && (angle <= Math.PI * 5 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 6 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 5 / 24) && (angle <= Math.PI * 7 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 4 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 7 / 24) && (angle <= Math.PI * 9 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI / 3 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 9 / 24) && (angle <= Math.PI * 11 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 5 / 12 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 11 / 24) && (angle <= Math.PI * 13 / 24):
	  return new Vector2(wState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
	  break
	case (angle > Math.PI * 13 / 24) && (angle <= Math.PI * 15 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 7 / 12 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 15 / 24) && (angle <= Math.PI * 17 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 2 / 3 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 17 / 24) && (angle <= Math.PI * 19 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 3 / 4 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 19 / 24) && (angle <= Math.PI * 21 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 5 / 6 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case (angle > Math.PI * 21 / 24) && (angle <= Math.PI * 23 / 24):
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2({ angle: Math.PI * 11 / 12 })), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	}
      }

      constraints[VERTICAL_HORIZONTAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case (angle > Math.PI * 3 / 4) || (angle <= Math.PI / 4):
	  return new Vector2(toolLocation.x, wState[MOUSE_DOWN_LOCATION].y)
	  break
	case (angle > Math.PI / 4) && (angle <= Math.PI * 3 / 4):
	  return new Vector2(wState[MOUSE_DOWN_LOCATION].x, toolLocation.y)
	  break
	}
      }

      constraints[HEXAGONAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI
	return constrainLine(
	  wState[MOUSE_DOWN_LOCATION].add(new Vector2({ 
	    angle: (Math.round(((toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI) - wState[HEX_ANGLE]) * 3 / Math.PI) * Math.PI / 3) + wState[HEX_ANGLE]
	  })),
	  wState[MOUSE_DOWN_LOCATION],
	  toolLocation
	)
      }

      constraints[DIAGONAL] = (toolLocation) => {
	const angle = toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]) % Math.PI
	switch (true) {
	case angle < Math.PI / 2:
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2(1, 1)), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	case angle > Math.PI / 2:
	  return constrainLine(wState[MOUSE_DOWN_LOCATION].add(new Vector2(-1, 1)), wState[MOUSE_DOWN_LOCATION], toolLocation)
	  break
	}
      }

      const drawMeasureText = (mouseDown, toolLocation, gridType) => {
	// console.log('mouseDown, toolLocation, gridType: ', mouseDown, toolLocation, gridType)
	if (wState[FILL_ACTIVE]) {
	  let content
	  switch (gridType.x) {
	  case 0:
	    content = `${toolLocation.getMagnitude(mouseDown).toFixed(0)}px`
	    break
	  case 1:
	    content = `(${(toolLocation.getRectangularOffset().x - mouseDown.getRectangularOffset().x).toFixed(2)}, ${(mouseDown.getRectangularOffset().y - toolLocation.getRectangularOffset().y).toFixed(2)})`
	    break
	  case 2:
	    content = `${(toolLocation.getHexOffset().getMagnitude(mouseDown.getHexOffset())).toFixed(2)}, ${(((Math.PI * 2) - toolLocation.getAngle(mouseDown)) * 180 / Math.PI).toFixed(0)}°`
	    break
	  case 3:
	    switch (gridType.y) {
	    case 0:
	      content = `${Math.abs(toolLocation.getCalendarDays().x - mouseDown.getCalendarDays().x + ((toolLocation.getCalendarDays().y - mouseDown.getCalendarDays().y) * 7))} days`
	      break
	    case 1:
	      const hours = Math.abs(((toolLocation.getPlannerHours().x - mouseDown.getPlannerHours().x) * 24) + toolLocation.getPlannerHours().y - mouseDown.getPlannerHours().y)
	      content = `${Math.floor(hours).toString().padStart(2, '0')}:${(Math.round((hours % 1) * 60)).toString().padStart(2, '0')}`
	      break
	    case 2:
	      const minutes = (toolLocation.getClockTime() - mouseDown.getClockTime() + 60) % 60
	      content = `${Math.floor(minutes).toString().padStart(2, '0')}:${(Math.round((minutes % 1) * 60)).toString().padStart(2, '0')}`
	      break
	    }
	    break
	  }
	  
	  const offset = {}
	  if ((gridType.x === 3) && (gridType.y === 2)) {
	    offset.angle = toolLocation.getAngle(getCenter())
	    offset.location = new Vector2({
	      angle: toolLocation.getAngle(getCenter()),
	      magnitude: mouseDown.getMagnitude(getCenter())
	    }).add(getCenter())
	  } else {
	    offset.angle = toolLocation.getAngle(mouseDown)
	    offset.location = toolLocation
	  }

	  drawText(
	    TOOLS,
	    content,
	    offset.location
	      .add(new Vector2({
		angle: offset.angle,
		magnitude: (Math.abs(Math.cos(offset.angle)) + Math.abs(Math.sin(offset.angle)) * 0.4) * content.length * 5 + 10
	      })).add(new Vector2(-content.length * 5, 8)),
	    wState[TOOLS_COLOR],
	    16
	  )
	}
      }
      
      const tools = {}
      tools[PAINT_BRUSH] = {
	mouseDown: (toolLocation) => {},
	mouseMove: (toolLocation) => {
	  const offset = new Vector2(toolLocation.x, toolLocation.y)
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    if (spaceIsDown) {
	      layers[MARKS].save()
	      layers[MARKS].moveTo(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	      layers[MARKS].arc(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y, wState[ERASE_RADIUS], 0, Math.PI*2, 2)
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else {
	      layers[MARKS].lineJoin = layers[MARKS].lineCap = 'round';
	      layers[MARKS].beginPath();
	      layers[MARKS].moveTo(wState[PRINT_HEAD_LOCATION].x, wState[PRINT_HEAD_LOCATION].y);
	      layers[MARKS].lineTo(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	      layers[MARKS].stroke();
	    }
	    wState[PRINT_HEAD_LOCATION].setCoordinates(constraints[constraint](toolLocation).x, constraints[constraint](toolLocation).y)
	  }
	},
	mouseUp: (toolLocation) => {
	  updateMarksHistory()
	}
      }

      tools[COMMITTED] = {
	mouseDown: (toolLocation) => {
	  wState[ANGLE] = null
	},
	mouseMove: (toolLocation) => {
	  const offset = new Vector2(toolLocation.x, toolLocation.y)
	  if (mouseIsDown 
	    && toolLocation.getMagnitude(wState[MOUSE_DOWN_LOCATION]) > wState[COMMIT_RADIUS]
	    && constraints[constraint](toolLocation)) {
	    if (wState[ANGLE] === null) {
	      setWhiteboardState(ANGLE, toolLocation.getAngle(wState[MOUSE_DOWN_LOCATION]))
	    }
	    const printHeadLocation = constrainLine(
	      wState[MOUSE_DOWN_LOCATION]
		.add(new Vector2({ angle: wState[ANGLE] })), 
	      wState[MOUSE_DOWN_LOCATION], 
	      toolLocation)
	    if (spaceIsDown) {
	      layers[MARKS].save()
	      layers[MARKS].moveTo(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	      layers[MARKS].arc(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y, wState[ERASE_RADIUS], 0, Math.PI*2, 2)
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else {
	      layers[MARKS].lineJoin = layers[MARKS].lineCap = 'round';
	      layers[MARKS].beginPath();
	      layers[MARKS].moveTo(wState[PRINT_HEAD_LOCATION].x, wState[PRINT_HEAD_LOCATION].y);
	      layers[MARKS].lineTo(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	      layers[MARKS].stroke();
	    }
	    wState[PRINT_HEAD_LOCATION].setCoordinates(constraints[PARALLEL](toolLocation).x, constraints[PARALLEL](toolLocation).y)
	  }
	},
	mouseUp: (toolLocation) => {
	  updateMarksHistory()
	}
      }

      tools[ELLIPSE] = {
	mouseDown: (toolLocation) => {
	  clearLayer(TOOLS)
	  const horizontal = (toolLocation.x - wState[MOUSE_DOWN_LOCATION].x) / 2
	  const vertical = (toolLocation.y - wState[MOUSE_DOWN_LOCATION].y) / 2  
	  const ellipse = document.createElementNS(svgNameSpace, 'ellipse')
	  ellipse.setAttribute('id', 'ellipse')
	  ellipse.setAttribute('stroke', wState[FILL_ACTIVE] || spaceIsDown ? 'none' : wState[TOOLS_COLOR].getRgba())
	  ellipse.setAttribute('fill', wState[FILL_ACTIVE] || spaceIsDown ? wState[TOOLS_COLOR].getRgba() : 'none')
	  ellipse.setAttribute('stroke-width', wState[BRUSHES][wState[BRUSH]].width)
	  ellipse.setAttribute('cx', wState[MOUSE_DOWN_LOCATION].x + horizontal)
	  ellipse.setAttribute('cy', wState[MOUSE_DOWN_LOCATION].y + vertical)
	  ellipse.setAttribute('rx', Math.abs(horizontal))
	  ellipse.setAttribute('ry', Math.abs(vertical))
	  layers[TOOLS].appendChild(ellipse)
	},
	mouseMove: (toolLocation) => {
	  if (mouseIsDown && constraints[constraint](toolLocation) && ellipse) {
	    const ellipse = document.getElementById('ellipse')
	    clearLayer(TOOLS)
	    const horizontal = (constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x) / 2
	    const vertical = (constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y) / 2  
	    ellipse.setAttribute('stroke', wState[FILL_ACTIVE] || spaceIsDown ? 'none' : wState[TOOLS_COLOR].getRgba())
	    ellipse.setAttribute('fill', wState[FILL_ACTIVE] || spaceIsDown ? wState[TOOLS_COLOR].getRgba() : 'none')
	    ellipse.setAttribute('cx', wState[MOUSE_DOWN_LOCATION].x + horizontal)
	    ellipse.setAttribute('cy', wState[MOUSE_DOWN_LOCATION].y + vertical)
	    ellipse.setAttribute('rx', Math.abs(horizontal))
	    ellipse.setAttribute('ry', Math.abs(vertical))
	    layers[TOOLS].appendChild(ellipse)    
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    clearLayer(TOOLS)
	    const horizontal = (constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x) / 2
	    const vertical = (constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y) / 2
	    if (spaceIsDown) {
	      layers[MARKS].save()
	    }
	    layers[MARKS].beginPath()
	    layers[MARKS].ellipse(
	      wState[MOUSE_DOWN_LOCATION].x + horizontal,
	      wState[MOUSE_DOWN_LOCATION].y + vertical,
	      Math.abs(horizontal),
	      Math.abs(vertical),
	      0,
	      0,
	      Math.PI * 2
	    )
	    if (spaceIsDown) {
	      layers[MARKS].clip()
	      clearLayer(MARKS)
	      layers[MARKS].restore()
	    } else if (wState[FILL_ACTIVE]) {
	      layers[MARKS].fill()
	    } else {
	      layers[MARKS].stroke()
	    }
	  }
	  updateMarksHistory()
	}
      }

      tools[RECTANGLE] = {
	mouseDown: (toolLocation) => {
	  clearLayer(TOOLS)
	  const rectangle = document.createElementNS(svgNameSpace, 'rect')
	  rectangle.setAttribute('id', 'rectangle')
	  rectangle.setAttribute('stroke', wState[FILL_ACTIVE] || spaceIsDown ? 'none' : wState[TOOLS_COLOR].getRgba())
	  rectangle.setAttribute('fill', wState[FILL_ACTIVE] || spaceIsDown ? wState[TOOLS_COLOR].getRgba() : 'none')
	  rectangle.setAttribute('stroke-width', wState[BRUSHES][wState[BRUSH]].width)
	  rectangle.setAttribute('x', Math.min(toolLocation.x, wState[MOUSE_DOWN_LOCATION].x))
	  rectangle.setAttribute('y', Math.min(toolLocation.y, wState[MOUSE_DOWN_LOCATION].y))
	  rectangle.setAttribute('width', Math.abs(toolLocation.x - wState[MOUSE_DOWN_LOCATION].x))
	  rectangle.setAttribute('height', Math.abs(toolLocation.y - wState[MOUSE_DOWN_LOCATION].y))
	  layers[TOOLS].appendChild(rectangle)
	},
	mouseMove: (toolLocation) => {
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    const rectangle = document.getElementById('rectangle')
	    clearLayer(TOOLS)
	    const width = Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_MOVE_LOCATION].x)
	    const height = Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_MOVE_LOCATION].y)
	    rectangle.setAttribute('stroke', wState[FILL_ACTIVE] || spaceIsDown ? 'none' : wState[TOOLS_COLOR].getRgba())
	    rectangle.setAttribute('fill', wState[FILL_ACTIVE] || spaceIsDown ? wState[TOOLS_COLOR].getRgba() : 'none')
	    rectangle.setAttribute('x', Math.min(constraints[constraint](toolLocation).x, wState[MOUSE_DOWN_LOCATION].x))
	    rectangle.setAttribute('y', Math.min(constraints[constraint](toolLocation).y, wState[MOUSE_DOWN_LOCATION].y))
	    rectangle.setAttribute('width', Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x))
	    rectangle.setAttribute('height', Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y))
	    layers[TOOLS].appendChild(rectangle)
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    clearLayer(TOOLS)
	    const rectangle = [
	      Math.min(constraints[constraint](toolLocation).x, wState[MOUSE_DOWN_LOCATION].x), 
	      Math.min(constraints[constraint](toolLocation).y, wState[MOUSE_DOWN_LOCATION].y), 
	      Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x),
	      Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y)
	    ]
	    if (spaceIsDown) {
	      layers[MARKS].clearRect(...rectangle)
	    } else if (wState[FILL_ACTIVE]) {
	      layers[MARKS].fillRect(...rectangle)
	    } else {
	      layers[MARKS].strokeRect(...rectangle)
	    }
	  }
	  updateMarksHistory()
	}
      }

      tools[LINE] = {
	mouseDown: (toolLocation) => {
	  clearLayer(TOOLS)
	},
	mouseMove: (toolLocation) => {
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    clearLayer(TOOLS)
	    if (wState[FILL_ACTIVE]) {
	      drawArrow(
		TOOLS,
		wState[MOUSE_DOWN_LOCATION],
		constraints[constraint](toolLocation),
		wState[TOOLS_COLOR],
		wState[BRUSHES][wState[BRUSH]].width
	      )
	    } else { 
	      drawLine(
		TOOLS,
		wState[MOUSE_DOWN_LOCATION],
		constraints[constraint](toolLocation),
		wState[TOOLS_COLOR],
		wState[BRUSHES][wState[BRUSH]].width
	      )
	    }
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    clearLayer(TOOLS)
	    if (wState[FILL_ACTIVE]) {
	      drawArrow(
		MARKS,
		wState[MOUSE_DOWN_LOCATION],
		constraints[constraint](toolLocation),
		wState[BRUSHES][wState[BRUSH]].color,
		wState[BRUSHES][wState[BRUSH]].width
	      )
	    } else {
	      drawLine(
		MARKS,
		wState[MOUSE_DOWN_LOCATION],
		constraints[constraint](toolLocation),
		wState[BRUSHES][wState[BRUSH]].color,
		wState[BRUSHES][wState[BRUSH]].width
	      )
	    }
	    setWhiteboardState(ANGLE, constraints[constraint](toolLocation).getAngle(wState[MOUSE_DOWN_LOCATION]))
	  }
	  updateMarksHistory()
	}
      }

      tools[TEXT] = {
	mouseDown: (toolLocation) => {
	  drawTextCursor()
	},
	mouseMove: (toolLocation) => {},
	mouseUp: (toolLocation) => {}
      }
      
      tools[MEASURE] = {
	mouseDown: (toolLocation) => {
	  const measurementElement = document.createElementNS(svgNameSpace, 'line')
	  measurementElement.setAttribute('id', 'measurement')
	  measurementElement.setAttribute('x1', wState[MOUSE_DOWN_LOCATION].x.toString())
	  measurementElement.setAttribute('y1', wState[MOUSE_DOWN_LOCATION].y.toString())
	  measurementElement.setAttribute('x2', toolLocation.x.toString())
	  measurementElement.setAttribute('y2', toolLocation.y.toString())
	  measurementElement.setAttribute('stroke', wState[TOOLS_COLOR].getRgba())
	  measurementElement.setAttribute('stroke-width', '6px')
	  layers[TOOLS].appendChild(measurementElement)
	},
	mouseMove: (toolLocation) => {
	  clearLayer(TOOLS, true)
	  if (wState[GRID_TYPE].x === 3 && wState[GRID_TYPE].y === 2) {
	    const center = getCenter()
	    const radius = wState[MOUSE_DOWN_LOCATION].getMagnitude(center)
	    const end = constrainArc(center, wState[MOUSE_DOWN_LOCATION], toolLocation)
	    const measurementElement = document.createElementNS(svgNameSpace, 'path')
	    const bigArc = (toolLocation.getAngle(center) - wState[MOUSE_DOWN_LOCATION].getAngle(center) + (Math.PI * 2)) % (Math.PI * 2) > Math.PI ? 1 : 0
	    measurementElement.setAttribute('id', 'measurement')
	    measurementElement.setAttribute('fill', 'none')
	    measurementElement.setAttribute('d', `M${wState[MOUSE_DOWN_LOCATION].x},${wState[MOUSE_DOWN_LOCATION].y} A ${radius} ${radius} 0 ${bigArc} 1 ${end.x} ${end.y}`)
	    measurementElement.setAttribute('stroke', wState[TOOLS_COLOR].getRgba())
	    measurementElement.setAttribute('stroke-width', '6px')
	    layers[TOOLS].appendChild(measurementElement)
	  } else {
	    const measurementElement = document.createElementNS(svgNameSpace, 'line')
	    measurementElement.setAttribute('id', 'measurement')
	    measurementElement.setAttribute('x1', wState[MOUSE_DOWN_LOCATION].x.toString())
	    measurementElement.setAttribute('y1', wState[MOUSE_DOWN_LOCATION].y.toString())
	    measurementElement.setAttribute('x2', toolLocation.x.toString())
	    measurementElement.setAttribute('y2', toolLocation.y.toString())
	    measurementElement.setAttribute('stroke', wState[TOOLS_COLOR].getRgba())
	    measurementElement.setAttribute('stroke-width', '6px')
	    layers[TOOLS].appendChild(measurementElement)
	  }
	  drawMeasureText(wState[MOUSE_DOWN_LOCATION], toolLocation, wState[GRID_TYPE])
	},
	mouseUp: (toolLocation) => {
	  const mouseDownVector = new Vector2(wState[MOUSE_DOWN_LOCATION])
	  const mouseUpVector = new Vector2(wState[MOUSE_UP_LOCATION])
	  const angle = wState[MOUSE_UP_LOCATION].scale({ x: 1, y: -1}).getAngle(wState[MOUSE_DOWN_LOCATION].scale({ x: 1, y: -1}))
	  const upOffset = [
	    wState[MOUSE_UP_LOCATION],
	    wState[MOUSE_UP_LOCATION].getRectangularOffset(),
	    wState[MOUSE_UP_LOCATION].getHexOffset(),
	    [
	      wState[MOUSE_UP_LOCATION].getCalendarDays(),
	      wState[MOUSE_UP_LOCATION].getPlannerHours(),
	      wState[MOUSE_UP_LOCATION].getClockTime()
	    ][wState[GRID_TYPE].y]
	  ][wState[GRID_TYPE].x]
	  const downOffset = [
	    wState[MOUSE_DOWN_LOCATION],
	    wState[MOUSE_DOWN_LOCATION].getRectangularOffset(),
	    wState[MOUSE_DOWN_LOCATION].getHexOffset(),
	    [
	      wState[MOUSE_DOWN_LOCATION].getCalendarDays(),
	      wState[MOUSE_DOWN_LOCATION].getPlannerHours(),
	      wState[MOUSE_DOWN_LOCATION].getClockTime()
	    ][wState[GRID_TYPE].y]
	  ][wState[GRID_TYPE].x]
	  if (wState[GRID_TYPE].x !== 3) {
	    const distance = downOffset.getMagnitude(upOffset)
	    console.log(`measurements:\n  angle: ${(angle * 180 / Math.PI).toFixed(0)}°\n  distance: ${distance.toFixed(2)}`)
	  } else {
	    switch (wState[GRID_TYPE].y) {
	    case 0: 
	      const days = Math.abs(upOffset.x - downOffset.x + ((upOffset.y - downOffset.y) * 7))
	      console.log(`measurement:\n  days: ${days}`)
	      break
	    case 1:
	      const hours = Math.abs(((upOffset.x - downOffset.x) * 24) + upOffset.y - downOffset.y)
	      console.log(`measurement:\n  hours: ${Math.floor(hours)}\n  minutes: ${Math.round((hours % 1) * 60)}`)
	      break
	    case 2:
	      const minutes = (upOffset - downOffset + 60) % 60
	      console.log(`measurement:\n  minutes: ${Math.floor(minutes)}\n  seconds: ${Math.round((minutes % 1) * 60)}`)
	      break
	    }
	  }
	  drawMeasureText(wState[MOUSE_DOWN_LOCATION], toolLocation, wState[GRID_TYPE])
	  setWhiteboardState(MEASUREMENT, {
	    mouseUp: wState[MOUSE_UP_LOCATION].copy(),
	    mouseDown: wState[MOUSE_DOWN_LOCATION].copy(),
	    gridType: wState[GRID_TYPE].copy()
	  })
	}
      }

      tools[ZOOM] = {
	mouseDown: (toolLocation) => {
	  previousVanishingPoint.setCoordinates(wState[VANISHING_POINT])
	},
	mouseMove: (toolLocation) => {
	  if (mouseIsDown) {
	    if (shiftIsDown) {
	      wState[VANISHING_POINT].setCoordinates(
		previousVanishingPoint.add(toolLocation.add(wState[MOUSE_DOWN_LOCATION].scale(-1)))
	      )
	      setGrid()
	    } else {
	      const zoomScale = (window.innerHeight + wState[MOUSE_DOWN_LOCATION].y - toolLocation.y) / window.innerHeight
	      wState[VANISHING_POINT].setCoordinates(
		wState[VANISHING_POINT]
		  .add(wState[MOUSE_DOWN_LOCATION].scale(-1)).scale(zoomScale)
		  .add(wState[MOUSE_DOWN_LOCATION])
	      )
	      if (wState[GRID_TYPE].x === 1) {
		wState[RECTANGULAR_OFFSET].setCoordinates(wState[RECTANGULAR_OFFSET].scale(zoomScale))
	      } else if (wState[GRID_TYPE].x === 2) {
		wState[HEX_MAGNITUDE] *= zoomScale
	      }
	      setGrid()
	    }
	  }
	},
	mouseUp: (toolLocation) => {}
      }

      tools[SELECT] = {
	mouseDown: (toolLocation) => {
	  clearLayer(TOOLS)
	  const selection = document.createElementNS(svgNameSpace, 'rect')
	  selection.setAttribute('id', 'selection')
	  selection.setAttribute('stroke', wState[TOOLS_COLOR].getRgba())
	  selection.setAttribute('stroke-dasharray', '5,5')
	  selection.setAttribute('fill', 'none')
	  selection.setAttribute('stroke-width', 1)
	  selection.setAttribute('x', Math.min(toolLocation.x, wState[MOUSE_DOWN_LOCATION].x))
	  selection.setAttribute('y', Math.min(toolLocation.y, wState[MOUSE_DOWN_LOCATION].y))
	  selection.setAttribute('width', Math.abs(toolLocation.x - wState[MOUSE_DOWN_LOCATION].x))
	  selection.setAttribute('height', Math.abs(toolLocation.y - wState[MOUSE_DOWN_LOCATION].y))
	  layers[TOOLS].appendChild(selection)
	},
	mouseMove: (toolLocation) => {  
	  if (mouseIsDown && constraints[constraint](toolLocation)) {
	    const selection = document.getElementById('selection')
	    clearLayer(TOOLS)
	    const width = Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_MOVE_LOCATION].x)
	    const height = Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_MOVE_LOCATION].y)
	    selection.setAttribute('stroke', wState[TOOLS_COLOR].getRgba())
	    selection.setAttribute('stroke-dasharray', '5,5')
	    selection.setAttribute('fill', 'none')
	    selection.setAttribute('x', Math.min(constraints[constraint](toolLocation).x, wState[MOUSE_DOWN_LOCATION].x))
	    selection.setAttribute('y', Math.min(constraints[constraint](toolLocation).y, wState[MOUSE_DOWN_LOCATION].y))
	    selection.setAttribute('width', Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x))
	    selection.setAttribute('height', Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y))
	    layers[TOOLS].appendChild(selection)
	  }
	},
	mouseUp: (toolLocation) => {
	  if (constraints[constraint](toolLocation)) {
	    selectBox = {
	      x: Math.min(constraints[constraint](toolLocation).x, wState[MOUSE_DOWN_LOCATION].x),
	      y: Math.min(constraints[constraint](toolLocation).y, wState[MOUSE_DOWN_LOCATION].y),
	      width: Math.abs(constraints[constraint](toolLocation).x - wState[MOUSE_DOWN_LOCATION].x),
	      height: Math.abs(constraints[constraint](toolLocation).y - wState[MOUSE_DOWN_LOCATION].y)
	    }
	  }
	}
      }

      tools[PALETTE] = {}
      tools[PALETTE].mouseDown = tools[PALETTE].mouseMove = (toolLocation) => {
	toolLocation = toolLocation.add(new Vector2(-window.scrollX, -window.scrollY))
	if (
	  mouseIsDown 
	    && toolLocation.x <= colorWheelSideLength * 3 
	    && toolLocation.y <= colorWheelSideLength
	) {
	  picked = readPalette(
	    new Vector2(
	      toolLocation.x % colorWheelSideLength,
	      toolLocation.y
	    ),
	    [
	      wState[BRUSHES][wState[BRUSH]].color,
	      wState[OVERLAY_COLOR],
	      wState[GRID_COLOR]
	    ][Math.floor(toolLocation.x / colorWheelSideLength)],
	    colorWheelSideLength
	  )
	  /* if (shiftIsDown && toolLocation.x < colorWheelSideLength) {
	     let factor
	     for (let p in picked.prop) {
	     factor = picked.prop[p] / wState[BRUSHES][wState[BRUSH]].color[p]
	     let brush
	     while (brush < 11) {
	     if (brush !== wState[BRUSH]) {
	     wState[BRUSHES][brush].color[p] *= factor
	     wState[BRUSHES][brush].color = new Color(wState[BRUSHES][brush].getHsla())
	     }
	     }
	     }
	     } */
	  setColor(
	    picked.color, 
	    [layers[MARKS], dom[OVERLAY], layers[GRID]][Math.floor(toolLocation.x / colorWheelSideLength)]
	  )
	}
      }
      tools[PALETTE].mouseUp = (toolLocation) => {}

      tools[GRID] = {
	mouseDown: (toolLocation) => {},
	mouseMove: (toolLocation) => {
	  if (toolLocation.getMagnitude(wState[VANISHING_POINT]) > 10) {
	    const offset = {
	      rectangular: new Vector2(
		(toolLocation.x - wState[VANISHING_POINT].x) / (wState[MOUSE_DOWN_LOCATION].x - wState[VANISHING_POINT].x),
		(toolLocation.y - wState[VANISHING_POINT].y) / (wState[MOUSE_DOWN_LOCATION].y - wState[VANISHING_POINT].y)
	      ),
	      hex: {
		magnitude: toolLocation.getMagnitude(wState[VANISHING_POINT]) / wState[MOUSE_DOWN_LOCATION].getMagnitude(wState[VANISHING_POINT]),
		angle: toolLocation.getAngle(wState[VANISHING_POINT]) - wState[MOUSE_DOWN_LOCATION].getAngle(wState[VANISHING_POINT])
	      }
	    }
	    clearLayer(GRID)
	    drawGrid(wState[GRID_TYPE], {
	      rectangular: wState[RECTANGULAR_OFFSET].scale(offset.rectangular),
	      hex: { 
		magnitude: wState[HEX_MAGNITUDE] * offset.hex.magnitude, 
		angle: absoluteModulus(wState[HEX_ANGLE] + offset.hex.angle, Math.PI)
	      }
	    })
	    drawCircle(
	      wState[VANISHING_POINT], 
	      5, 
	      wState[GRID_COLOR]
	    )
	  }
	},
	mouseUp: (toolLocation) => {
	  if (toolLocation.getMagnitude(wState[VANISHING_POINT]) > 10) {
	    const offset = {
	      rectangular: new Vector2(
		(toolLocation.x - wState[VANISHING_POINT].x) / (wState[MOUSE_DOWN_LOCATION].x - wState[VANISHING_POINT].x),
		(toolLocation.y - wState[VANISHING_POINT].y) / (wState[MOUSE_DOWN_LOCATION].y - wState[VANISHING_POINT].y)
	      ),
	      hex: {
		magnitude: toolLocation.getMagnitude(wState[VANISHING_POINT]) / wState[MOUSE_DOWN_LOCATION].getMagnitude(wState[VANISHING_POINT]),
		angle: toolLocation.getAngle(wState[VANISHING_POINT]) - wState[MOUSE_DOWN_LOCATION].getAngle(wState[VANISHING_POINT])
	      }
	    }
	    if (wState[GRID_TYPE].x === 1) {
	      setWhiteboardState(RECTANGULAR_OFFSET, wState[RECTANGULAR_OFFSET].scale(offset.rectangular))
	    } else if (wState[GRID_TYPE].x === 2) {
	      setWhiteboardState(HEX_MAGNITUDE, wState[HEX_MAGNITUDE] * offset.hex.magnitude)
	      setWhiteboardState(HEX_ANGLE, absoluteModulus(wState[HEX_ANGLE] + offset.hex.angle, Math.PI))
	    }
	    setGrid()
	  }
	}
      }

      // CONFIGURATION
      const unsplashCollections = [
	1242150,
	1457745,
	289662,
	1976082,
	920773,
	1886495,
	1772170,
	416021,
	548245,
	923267,
	827751,
	145238,
	179297,
	869015,
	397119,
	562095,
	1240111,
	782123,
	827743,
	2254180,
	1424240,
	162468,
	1223439,
	357786,
	1538150,
	256443,
	1166960,
	1405010,
	463870,
	545337,
	1463948,
	1346770,
	410546,
	193055,
	1525589,
	332024,
	167880,
	181581,
	3178572,
	175083,
	540518,
	573009,
	225,
	2227966, 
	1136512, 
	256789, 
	770373, 
	1340426, 
	786426, 
	1093185, 
	2073541, 
	631014, 
	311432, 
	401930, 
	1558570, 
	634016, 
	1753486, 
	525374, 
	402648, 
	944309, 
	1223029, 
	1045960, 
	136192, 
	139523, 
	490159, 
	1319676, 
	603534, 
	1705422, 
	421702, 
	1201283, 
	1280629, 
	250310, 
	1079579, 
	159185, 
	357250, 
	461372, 
	222193, 
	981639, 
	389015, 
	427860, 
	1922955, 
	550831, 
	1566993, 
	228211, 
	637183, 
	1348126, 
	860813, 
	279087, 
	893395, 
	1445644, 
	1364697, 
	266986, 
	1130937, 
	1030539, 
	441643, 
	1301636, 
	1078224, 
	346831, 
	217461, 
	195845, 
	291422, 
	326234, 
	1301396, 
	159106, 
	2222015, 
	993107, 
	1661394, 
	1563872, 
	789653, 
	139449, 
	395791, 
	168902, 
	1363567, 
	774640, 
	668423, 
	1091443, 
	631110, 
	589982, 
	251528, 
	158665, 
	1281908, 
	1025599, 
	403132, 
	542909, 
	1695735, 
	345761, 
	2241198, 
	2213392, 
	303466, 
	1266354, 
	932809, 
	525557, 
	1111575, 
	1698281, 
	325867, 
	992061,  
	1394721, 
	1949, 
	220388, 
	343012, 
	151521, 
	137627,  
	335992, 
	1494572, 
	148642, 
	311958, 
	460827, 
	1179044, 
	320872, 
	345744, 
	151899, 
	345758, 
	1163715, 
	256466, 
	926827, 
	1725806, 
	1152757, 
	981639, 
	647, 
	138884, 
	1477100, 
	1301689, 
	1664497,  
	1677633, 
	2020767, 
	924999, 
	147383, 
	934875, 
	1708734, 
	1751890, 
	668443, 
	1137170, 
	1134892, 
	1004394, 
	1366113,  
	632964, 
	142371, 
	536034, 
	923414, 
	490, 
	630848, 
	241614, 
	1117100, 
	896618, 
	525483, 
	444531, 
	1896376,
	1515841, 
	1270392, 
	635672, 
	560743, 
	158642, 
	212915, 
	236531
      ]
    
      const colorWheelSideLength = 400

      const periodicTable = () => 'https://www.cmu.edu/news/stories/archives/2016/january/images/periodic_table_large.png'
      const randomImage = (size) => `https://source.unsplash.com/random/${size.x}x${size.y}`
      const slideshow = []
      const globalOrigin = new Vector2(0, 0)
      const hpScreenDimenstions = new Vector2(1366, 768)
      const fontSizes = [8, 9, 10, 11, 12, 14, 18, 24, 30, 36, 48, 60, 72, 96]

      const defaultState = {}
      defaultState[DOCUMENT_TITLE] = 'Whiteboard'
      defaultState[SCREEN_SIZE] = new Vector2(1366, 768)
      defaultState[BOARD_SCALE] = new Vector2(1, 2)
      defaultState[ZOOM] = 1
      defaultState[OVERLAY_COLOR] = new Color('rgba(255, 255, 255, 0.0)')
      defaultState[RECTANGULAR_OFFSET] = new Vector2(60, 60) // Grid separated to four variables, for easy query strings.
      defaultState[HEX_MAGNITUDE] = 60
      defaultState[HEX_ANGLE] = Math.PI / 6
      defaultState[GRID_TYPE] = new Vector2(0, 0)
      defaultState[GRID_WIDTH] = 2
      defaultState[GRID_COLOR] = new Color('rgba(0, 0, 0, 0.4)')
      defaultState[TIME_PADDING] = new Vector2(80, 40)
      defaultState[TOOL] = PAINT_BRUSH
      defaultState[TOOLS_COLOR] = new Color('rgba(128, 128, 128, 0.6)')
      defaultState[BRUSH] = 0
      defaultState[BRUSHES] = [
	{ width: 2, color: new Color('hsla(0, 0%, 0%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(30, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(60, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(120, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(180, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(240, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(300, 100%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(30, 100%, 30%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 0%, 50%, 1.0)') },
	{ width: 2, color: new Color('hsla(0, 0%, 100%, 1.0)') }
      ]
      defaultState[FILL_ACTIVE] = false
      defaultState[FONT] = 'Courier New'
      defaultState[FONT_HEIGHT] = 10
      defaultState[FONT_WIDTH] = 30
      defaultState[LINE_SPACING] = 60
      defaultState[ANGLE] = 1.2277723863741932
      defaultState[COMMIT_RADIUS] = 120
      defaultState[ERASE_RADIUS] = 12
      defaultState[MOUSE_DOWN_LOCATION] = globalOrigin.copy()
      defaultState[MOUSE_MOVE_LOCATION] = globalOrigin.copy()
      defaultState[MOUSE_UP_LOCATION] = globalOrigin.copy()
      defaultState[PRINT_HEAD_LOCATION] = globalOrigin.copy()
      defaultState[MEASUREMENT] = globalOrigin.copy()
      defaultState[MARKS_DATA] = 'untitled'
      defaultState[SAVED_MARKS_DATA] = {}
      defaultState[MARKS_HISTORY_LENGTH] = 50

      const updateMarksHistory = (dataURL=dom[MARKS].toDataURL('image/png')) => {
	if (marksHistory.length < wState[MARKS_HISTORY_LENGTH]) {
	  historyIndex += 1
	} else {
	  marksHistory.shift()
	}
	marksHistory = marksHistory.slice(0, historyIndex)
	marksHistory.push(dataURL)
      }
      
      // Prepare Objects for Grid
      const drawLine = function(layer, fv, tv, color, width) {
	if (layers[layer].nodeName === 'svg') {
	  const line = document.createElementNS(svgNameSpace, 'line')
	  line.setAttribute('x1', fv.x.toString())
	  line.setAttribute('y1', fv.y.toString())
	  line.setAttribute('x2', tv.x.toString())
	  line.setAttribute('y2', tv.y.toString())
	  line.setAttribute('stroke', color ? color.getRgba() : wState[`${layer}_COLOR`].getRgba())
	  line.setAttribute('stroke-width', width || wState[`${layer}_WIDTH`])
	  layers[layer].appendChild(line)
	} else { // draw line on canvas
	  if (color === undefined) {
	    color = wState[BRUSHES][wState[BRUSH]].color.getRgba()
	  }
	  layers[layer].strokeStyle = color.getRgba()
	  layers[layer].lineWidth = width
	  layers[layer].beginPath()
	  layers[layer].moveTo(fv.x, fv.y)
	  layers[layer].lineTo(tv.x, tv.y)
	  layers[layer].stroke()
	  layers[layer].strokeStyle = wState[BRUSHES][wState[BRUSH]].color.getRgba()
	  layers[layer].lineWidth = wState[BRUSHES][wState[BRUSH]].width
	}
      }

      const drawArrow = function (layer, fv, tv, color, width=2) {
	const angle = tv.getAngle(fv)
	const leftBarb = new Vector2({ angle: Math.atan(1 / 3) + angle + Math.PI, magnitude: width * Math.sqrt(20) }).add(tv)
	const rightBarb = new Vector2({ angle: Math.atan(-1 / 3) + angle + Math.PI, magnitude: width * Math.sqrt(20) }).add(tv)
	const base = new Vector2({ angle: angle + Math.PI, magnitude: width * 3 }).add(tv)
	if (layers[layer].nodeName === 'svg') {
	  const polygon = document.createElementNS(svgNameSpace, 'polygon')
	  polygon.setAttribute('points', `${tv.x},${tv.y} ${leftBarb.x},${leftBarb.y} ${base.x},${base.y} ${rightBarb.x},${rightBarb.y}`)
	  polygon.setAttribute('fill', color ? color.getRgba() : wState[`${layer}_COLOR`].getRgba())
	  polygon.setAttribute('stroke', color ? color.getRgba() : wState[`${layer}_COLOR`].getRgba())
	  polygon.setAttribute('stroke-width', 0)
	  layers[layer].appendChild(polygon)
	} else { // draw line on canvas
	  if (color === undefined) {
	    color = wState[BRUSHES][wState[BRUSH]].color.getRgba()
	  }
	  layers[layer].fillStyle = color.getRgba()
	  layers[layer].beginPath()
	  layers[layer].moveTo(tv.x, tv.y)
	  layers[layer].lineTo(leftBarb.x, leftBarb.y)
	  layers[layer].lineTo(base.x, base.y)
	  layers[layer].lineTo(rightBarb.x, rightBarb.y)
	  layers[layer].closePath()
	  layers[layer].fill()
	  layers[layer].fillStyle = wState[BRUSHES][wState[BRUSH]].color.getRgba()
	}
	drawLine(layer, fv, base, color, width)
      }

      const drawText = function(layer, content, position, color, size) {
	if (layers[layer].nodeName === 'svg') { 
	  const text = document.createElementNS(svgNameSpace, 'text')
	  text.setAttribute('x', position.x.toString())
	  text.setAttribute('y', position.y.toString())
	  text.setAttribute('fill', color ? color.getRgba() : wState[`${layer}_COLOR`])
	  text.setAttribute('font-family', wState[FONT])
	  text.setAttribute('font-size', `${size || fontSizes[wState[FONT_HEIGHT]]}px`)
	  text.innerHTML = content
	  layers[layer].appendChild(text)
	} else { // draw text on canvas
	  if (color !== undefined) {
	    layers[layer].fillStyle = color.getRgba()
	  }
	  if (size !== undefined) {
	    layers[layer].font = `${size}px ${wState[FONT]}`
	  }
	  layers[layer].fillText(content, position.x, position.y)
	  layers[layer].fillStyle = wState[BRUSHES][wState[BRUSH]].color.getRgba()
	  layers[layer].font = `${fontSizes[wState[FONT_HEIGHT]]}px ${wState[FONT]}`
	}
      }
      
      const drawCircle = (center, radius, color, filled=false) => {
	const circle = document.createElementNS(svgNameSpace, 'circle')
	circle.setAttribute('cx', center.x.toString())
	circle.setAttribute('cy', center.y.toString())
	circle.setAttribute('r', radius.toString())
	circle.setAttribute('stroke', color.getRgba())
	circle.setAttribute('stroke-width', wState[GRID_WIDTH].toString())
	if (!filled) {
	  circle.setAttribute('fill', 'transparent')
	} else {
	  circle.setAttribute('fill', color.getRgba())
	}
	layers[GRID].appendChild(circle)
	return circle
      }
      

      // draw cursor for typing
      const drawTextCursor = () => {
	if (isTyping) {
	  clearLayer(TOOLS)
	  const rectangle = document.createElementNS(svgNameSpace, 'rect')
	  rectangle.setAttribute('id', 'rectangle')
	  rectangle.setAttribute('stroke', 'none')
	  rectangle.setAttribute('fill', wState[TOOLS_COLOR].getRgba())
	  rectangle.setAttribute('x', wState[PRINT_HEAD_LOCATION].x)
	  rectangle.setAttribute('y', wState[PRINT_HEAD_LOCATION].y - fontSizes[wState[FONT_HEIGHT]])
	  rectangle.setAttribute('width', wState[FONT_WIDTH])
	  rectangle.setAttribute('height', fontSizes[wState[FONT_HEIGHT]])
	  layers[TOOLS].appendChild(rectangle)
	}
      }

      // DRAW COLOR WHEEL
      const drawColorWheel = (c, offset, sideLength=colorWheelSideLength) => {
	color = new Color(c)
	// populate pixels array
	let pickerArray = []
	const pixelLocation = new Vector2(0, 0)
	while (pixelLocation.y < sideLength) {
	  pixelLocation.setCoordinates({ x: 0 })
	
	  while (pixelLocation.x < sideLength) {
	    const pixelData = readPalette(pixelLocation, color).color.getPixelData()
	    pickerArray.push(...pixelData)
	    pixelLocation.setCoordinates({ x: pixelLocation.x + 1 })
	  }
	  pixelLocation.setCoordinates({ y: pixelLocation.y + 1 })
	}
	pickerArray = new Uint8ClampedArray(pickerArray)
	const pickerData = new ImageData(pickerArray, sideLength)
	layers[PALETTE].putImageData(pickerData, offset.x, offset.y)
      }

      // DRAW GRIDS
      const drawRectangularDotsGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[RECTANGULAR_OFFSET]
	} = options
	let head = new Vector2(
	  origin.x % offset.x,
	  origin.y % offset.y
	)
	while (head.y < wState[BOARD_SIZE].y) {
	  while (head.x < wState[BOARD_SIZE].x) {
	    drawCircle(
	      head, 
	      wState[GRID_WIDTH] / 2, 
	      wState[GRID_COLOR], 
	      true
	    )
	    head.x += offset.x
	  }
	  head.x = origin.x % offset.x
	  head.y += offset.y
	}
      }
      
      const drawLinedGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[RECTANGULAR_OFFSET]
	} = options
      
	let head = origin.y % offset.y
	while (head < wState[BOARD_SIZE].y) {
	  drawLine(
	    GRID, 
	    new Vector2(0, head), 
	    new Vector2(wState[BOARD_SIZE].x, head)
	  )
	  head += offset.y
	}
      }

      const drawRectangularGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[RECTANGULAR_OFFSET]
	} = options
      
	let head = new Vector2(
	  origin.x % offset.x,
	  origin.y % offset.y
	)
	while (head.x < wState[BOARD_SIZE].x) {
	  drawLine(
	    GRID, 
	    new Vector2(head.x, 0), 
	    new Vector2(head.x, wState[BOARD_SIZE].y)
	  )
	  head.x += offset.x
	}
	while (head.y < wState[BOARD_SIZE].y) {
	  drawLine(
	    GRID, 
	    new Vector2(0, head.y), 
	    new Vector2(wState[BOARD_SIZE].x, head.y)
	  )
	  head.y += offset.y
	}
      }
      
      const drawTriangleDotsGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=new Vector2({
	    magnitude: wState[HEX_MAGNITUDE], 
	    angle: wState[HEX_ANGLE] 
	  })
	} = options
	const headIntervals = new Vector2 (
	  offset.getMagnitude() * Math.sqrt(3),
	  offset.getMagnitude()
	)
	let head = new Vector2(
	  (origin.x % headIntervals.x) - headIntervals.x,
	  (origin.y % headIntervals.y) - headIntervals.y
	)
	while (head.y < wState[BOARD_SIZE].y + headIntervals.y) {
	  while (head.x < wState[BOARD_SIZE].x + headIntervals.x) {
	    drawCircle(
	      head, 
	      wState[GRID_WIDTH] / 2, 
	      wState[GRID_COLOR], 
	      true
	    )
	    drawCircle(
	      new Vector2(
		head.x + headIntervals.x / 2,
		head.y + headIntervals.y / 2
	      ),
	      wState[GRID_WIDTH] / 2, 
	      wState[GRID_COLOR], 
	      true
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (origin.x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      const drawHexGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=new Vector2({
	    magnitude: wState[HEX_MAGNITUDE], 
	    angle: wState[HEX_ANGLE] 
	  })
	} = options
      
	const headIntervals = new Vector2(
	  offset.getMagnitude() * Math.sqrt(3),
	  offset.getMagnitude() * 3
	)
	let head = new Vector2(
	  (origin.x % headIntervals.x) - headIntervals.x,
	  (origin.y % headIntervals.y) - headIntervals.y
	)
	while (head.y < wState[BOARD_SIZE].y + headIntervals.y * 2 / 3) {
	  while (head.x < wState[BOARD_SIZE].x + headIntervals.x / 2) {
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y * 2 / 3), 
	      new Vector2(head.x, head.y - headIntervals.y / 3)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y / 3),
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 6)
	    )
	    drawLine(
	      GRID,
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 6),
	      new Vector2(head.x, head.y - headIntervals.y / 3)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 6),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y + headIntervals.y / 3),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y + headIntervals.y / 3),
	      new Vector2(head.x + headIntervals.x / 2, head.y + headIntervals.y / 6)
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (origin.x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      const getLinesGrid = (
	angle, 
	spacing=wState[HEX_MAGNITUDE] * Math.sin(Math.PI / 3),
	offset=wState[VANISHING_POINT]
      ) => {
	const lines = []
	const board = wState[BOARD_SIZE]
	let head
	if (angle % Math.PI === 0) {
	  head = (offset.y % spacing) - spacing
	  while (head <= board.y + spacing) {
	    lines.push({ 
	      start: new Vector2(0, head),
	      end: new Vector2(board.x, head)
	    })
	    head += spacing
	  }
	  return { lines, spacing }
	} else if (angle % Math.PI === Math.PI / 2) {
	  head = offset.x % spacing
	  while (head <= board.x) {
	    lines.push({ 
	      start: new Vector2(head, -spacing),
	      end: new Vector2(head, board.y + spacing)
	    })
	    head += spacing
	  }
	  return { lines, spacing }
	}
	const slope = Math.tan(angle)
	const yInterval = spacing / Math.cos(angle)
	const slopeIsPositive = Math.sign(slope) > 0
	if (slopeIsPositive) {
	  offset = offset.y + ((board.x - offset.x) * slope)
	} else {
	  offset = board.y - offset.y - ((board.x - offset.x) * slope)
	}
	offset = offset % yInterval
	head = (Math.sign(slope) || 1) * offset - board.x * slope + (slopeIsPositive ? -yInterval : board.y + yInterval)
	while ((slopeIsPositive ? head <= board.y + yInterval : head >= -yInterval)) {
	  const lowerXIntercept = (-head - yInterval) / slope
	  const higherXIntercept = (board.y + yInterval - head) / slope
	  const rightYIntercept = slope * board.x + head
	  lines.push({ 
	    start: new Vector2(
	      Math.max(0, (slopeIsPositive ? lowerXIntercept : higherXIntercept)),
	      (slopeIsPositive ? Math.max(-yInterval, head) : Math.min(board.y + yInterval, head))
	    ), 
	    end: new Vector2(
	      Math.min((slopeIsPositive ? higherXIntercept : lowerXIntercept), board.x),
	      (slopeIsPositive ? Math.min(board.y + yInterval, rightYIntercept) : Math.max(-yInterval, rightYIntercept))
	    )
	  })
	  head += Math.sign(slope) * yInterval
	}
	return { lines, spacing }
      }

      const testLines = (lines) => {
	for (let line of lines) {
	  
	  drawLine(
	    GRID,
	    line.start,
	    line.end,
	    wState[GRID_COLOR],
	    wState[GRID_WIDTH]
	  )
	  drawCircle(
	    line.start,
	    7, 
	    wState[GRID_COLOR]
	  )
	  drawCircle(
	    line.end,
	    7, 
	    wState[GRID_COLOR]
	  )
	}
      }

      const getDots = (
	lines,
	magnitude=wState[HEX_MAGNITUDE],
	offset=0
      ) => {
	const allDots = []
	for (let line of lines.lines) {
	  const dots = []
	  const angle = line.end.getAngle(line.start)
	  const unitVector = new Vector2({ angle, magnitude })
	  let projection
	  let head
	  if (angle % Math.PI === Math.PI / 2) {
	    projection = new Vector2(
	      line.start.x, 
	      wState[VANISHING_POINT].y
	    )
	  } else if (angle % Math.PI === 0) {
	    projection = new Vector2(
	      wState[VANISHING_POINT].x,
	      line.start.y
	    )
	  } else {
	    projection = wState[VANISHING_POINT].project(
	      line.end.getAngle(line.start),
	      line.start
	    )
	  }
	  head = projection.copy()
	    .add(unitVector.scale((Math.round((projection.getMagnitude(wState[VANISHING_POINT]) / lines.spacing)) % 2) / 2))
	    .add(unitVector.scale(offset))

	  if (
	    Math.round(head.getAngle(line.start), Math.PI) 
	    !== Math.round(angle, Math.PI)
	  ) {
	    head = head
	      .add(unitVector.scale(Math.floor(
		head.getMagnitude(line.start) / magnitude
	      )))
	  } else {
	    head = head
	      .add(unitVector.scale(-Math.ceil(
		head.getMagnitude(line.start) / magnitude
	      )))
	  }

	  while (head.getMagnitude(line.start) <= (line.end.getMagnitude(line.start) + magnitude * 2)) {
	    dots.push(head)
	    head = head.add(unitVector)
	  }
	  allDots.push(dots)
	}
	return allDots
      }

      testDots = (allDots) => {
	for (let dots of allDots) {
	  for (let dot of dots) {
	    drawCircle(
	      dot,
	      7, 
	      wState[GRID_COLOR]
	    )
	  }
	}
      }

      newTriangleDots = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=new Vector2({
	    magnitude: wState[HEX_MAGNITUDE], 
	    angle: wState[HEX_ANGLE] 
	  })
	} = options
	
	const lines = getLinesGrid(offset.getAngle(), Math.sin(Math.PI / 3) * offset.getMagnitude())
	const allDots = getDots(lines, offset.getMagnitude())
	for (let dots of allDots) {
	  for (let dot of dots) {
	    drawCircle(
	      dot,
	      wState[GRID_WIDTH] / 2, 
	      wState[GRID_COLOR]
	    )
	  }
	}
      }

      newHex = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=new Vector2({
	    magnitude: wState[HEX_MAGNITUDE], 
	    angle: wState[HEX_ANGLE] 
	  })
	} = options
	const lines = getLinesGrid(offset.getAngle(), Math.sin(Math.PI / 3) * offset.getMagnitude())
	const allDots = getDots(lines, offset.getMagnitude() * 3, 2 / 3)
	for (let i in lines.lines) {
	  for (let dot of allDots[i]) {
	    drawLine(
	      GRID,
	      dot.add(offset.scale(-1)),
	      dot
	    )
	    drawLine(
	      GRID,
	      dot,
	      dot.add(offset.rotate(Math.PI / 3))
	    )
	    drawLine(
	      GRID,
	      dot,
	      dot.add(offset.rotate(-Math.PI / 3))
	    )
	  }
	}
      }

      newTriangle = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=new Vector2({
	    magnitude: wState[HEX_MAGNITUDE], 
	    angle: wState[HEX_ANGLE] 
	  })
	} = options
	const lines = getLinesGrid(offset.getAngle(), Math.sin(Math.PI / 3) * offset.getMagnitude())
	const allDots = getDots(lines, offset.getMagnitude())
	for (let i in lines.lines) {
	  for (let dot of allDots[i]) {
	    drawLine(
	      GRID,
	      dot.add(offset.scale(-1)),
	      dot
	    )
	    drawLine(
	      GRID,
	      dot,
	      dot.add(offset.rotate(Math.PI * 2 / 3))
	    )
	    drawLine(
	      GRID,
	      dot,
	      dot.add(offset.rotate(-Math.PI * 2 / 3))
	    )
	  }
	}
      }

      const drawTriangleGrid = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=new Vector2({
	    magnitude: wState[HEX_MAGNITUDE], 
	    angle: wState[HEX_ANGLE] 
	  })
	} = options
      
	const headIntervals = new Vector2(
	  offset.getMagnitude() * Math.sqrt(3),
	  offset.getMagnitude()
	)
	let head = new Vector2(
	  (origin.x % headIntervals.x) - headIntervals.x,
	  (origin.y % headIntervals.y) - headIntervals.y
	)
	while (head.y < wState[BOARD_SIZE].y + headIntervals.y * 2 / 3) {
	  while (head.x < wState[BOARD_SIZE].x + headIntervals.x / 2) {
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x, head.y - headIntervals.y)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x, head.y - headIntervals.y),
	      new Vector2(head.x + headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      head,
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 2)
	    )
	    drawLine(
	      GRID, 
	      new Vector2(head.x - headIntervals.x / 2, head.y - headIntervals.y / 2),
	      new Vector2(head.x - headIntervals.x / 2, head.y + headIntervals.y / 2)
	    )
	    head.x += headIntervals.x
	  }
	  head.x = (origin.x % headIntervals.x) - headIntervals.x
	  head.y += headIntervals.y
	}
      }

      const weekdays = [
	'Sunday',
	'Monday',
	'Tuesday',
	'Wednesday',
	'Thursday',
	'Friday',
	'Saturday'
      ]

      const drawPlanner = (options) => {
	const {
	  origin=wState[VANISHING_POINT], 
	  offset=wState[PLANNER_OFFSET]
	} = options
	Object.assign(daysElement.style, {
	  width: `${wState[BOARD_SIZE].x - wState[TIME_PADDING].x}px`,
	  top: '0px',
	  left: `${wState[TIME_PADDING].x}px`,
	  display: 'flex'
	})
	hoursElement.style.display = 'flex'
	head = new Vector2(0, 0)
	let pixels = origin.copy()
	while (head.y < (wState[BOARD_SIZE].y / offset.y)) {
	  pixels.y = head.y * offset.y + origin.y
	  drawLine(
	    GRID, 
	    new Vector2(0, pixels.y), 
	    new Vector2(wState[BOARD_SIZE].x, pixels.y),
	    wState[GRID_COLOR],
	    head.y % 12 === 0 
	      ? 6 
	      : head.y % 2 === 0
	      ? 2
	      : 0.5
	  )
	  head.y += 1
	}
	while (head.x < (wState[BOARD_SIZE].x / offset.x)) {
	  pixels.x = head.x * offset.x + origin.x
	  drawLine(
	    GRID, 
	    new Vector2(pixels.x, 0), 
	    new Vector2(pixels.x, wState[BOARD_SIZE].y),
	    wState[GRID_COLOR],
	    2
	  )
	  head.x += 1
	}
      }

      drawCalendar = () => {
	const today = new Date()
	const hasLeapDay = (dt) => {
	  if (dt.getMonth() === 1) {
	    const year = dt.getFullYear()
	    switch (true) {
	    case (year % 400 === 0):
	      return 1
	      break
	    case (year % 100 === 0):
	      return 0
	      break
	    case (year % 4 === 0):
	      return 1
	      break
	    default:
	      return 0
	    }
	  } else {
	    return 0
	  }
	} 
	const months = [
	  { name: 'January', days: 31 },
	  { name: 'February', days: 28 },
	  { name: 'March', days: 31 },
	  { name: 'April', days: 30 },
	  { name: 'May', days: 31 },
	  { name: 'June', days: 30 },
	  { name: 'July', days: 31 },
	  { name: 'August', days: 31 },
	  { name: 'September', days: 30 },
	  { name: 'October', days: 31 },
	  { name: 'November', days: 30 },
	  { name: 'December', days: 31 }
	]
	const theseDays = months[today.getMonth()].days + hasLeapDay(today)
	let daysOffset = (8 + today.getDay() - (today.getDate() % 7)) % 7
	const rows = Math.ceil((daysOffset + theseDays) / 7)
	wState[CALENDAR_OFFSET].setCoordinates(
	  (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 2) / 7,
	  (wState[SCREEN_SIZE].y - wState[TIME_PADDING].y * 5) / rows
	)
	const printHead = new Vector2(
	  wState[TIME_PADDING].x,
	  wState[TIME_PADDING].y * 3
	)
	
	drawLine(
	  GRID,
	  new Vector2(
	    wState[TIME_PADDING].x,
	    printHead.y
	  ),
	  new Vector2(
	    wState[BOARD_SIZE].x - wState[TIME_PADDING].x,
	    printHead.y
	  ),
	  wState[GRID_COLOR],
	  6
	)
	printHead.y += wState[TIME_PADDING].y
	while (printHead.y < wState[SCREEN_SIZE].y) {
	  drawLine(
	    GRID,
	    new Vector2(
	      wState[TIME_PADDING].x,
	      printHead.y
	    ),
	    new Vector2(
	      wState[BOARD_SIZE].x - wState[TIME_PADDING].x,
	      printHead.y
	    ),
	    wState[GRID_COLOR],
	    2
	  )
	  printHead.y += wState[CALENDAR_OFFSET].y
	}
	
	while (printHead.x < wState[BOARD_SIZE].x) {
	  drawLine(
	    GRID,
	    new Vector2(
	      printHead.x,
	      wState[TIME_PADDING].y * 3
	    ),
	    new Vector2(
	      printHead.x,
	      wState[SCREEN_SIZE].y - wState[TIME_PADDING].y
	    ),
	    wState[GRID_COLOR],
	    2
	  )
	  printHead.x += wState[CALENDAR_OFFSET].x
	}
	
	drawText(
	  GRID, 
	  `${months[today.getMonth()].name}, ${today.getFullYear()}`,
	  new Vector2(
	    wState[TIME_PADDING].x + 5,
	    wState[TIME_PADDING].y + 50
	  ),
	  wState[GRID_COLOR],
	  50
	)
	
	weekdays.forEach((weekday, index) => {
	  drawText(
	    GRID, 
	    weekday,
	    new Vector2(
	      wState[TIME_PADDING].x + (index * wState[CALENDAR_OFFSET].x) + (wState[CALENDAR_OFFSET].x / 2) - (weekday.length * 10 * 0.59),
	      wState[TIME_PADDING].y * 4 - 10
	    ),
	    wState[GRID_COLOR],
	    20
	  )  
	})
	
	printHead.setCoordinates(
	  wState[TIME_PADDING].x + (wState[CALENDAR_OFFSET].x * daysOffset),
	  wState[TIME_PADDING].y * 4
	)
	let thisDate = 1
	let halfSpace
	while (thisDate <= theseDays) {
	  halfSpace = thisDate < 10 ? 5.5 : 0
	  drawText(
	    GRID, 
	    thisDate,
	    new Vector2(
	      printHead.x + halfSpace + 10,
	      printHead.y + 24
	    ),
	    wState[GRID_COLOR],
	    16
	  )
	  if ((thisDate + daysOffset) % 7 === 0) {
	    printHead.setCoordinates(
	      wState[TIME_PADDING].x,
	      printHead.y + wState[CALENDAR_OFFSET].y
	    )
	  } else {
	    printHead.x += wState[CALENDAR_OFFSET].x
	  }
	  thisDate ++
	}
      }

      drawClock = () => {
	daysElement.style.display = hoursElement.style.display = 'none'
	const clockCenter = wState[SCREEN_SIZE].scale(1 / 2)
	const clockRadius = (wState[SCREEN_SIZE].y - wState[TIME_PADDING].y * 2) / 2
	setInterval(() => {
	  if (wState[GRID_TYPE].x === 3 && wState[GRID_TYPE].y === 2) {
	    clearLayer(GRID)
	    drawCircle(
	      wState[VANISHING_POINT], 
	      5, 
	      wState[GRID_COLOR]
	    )
	    drawCircle(
	      clockCenter,
	      clockRadius,
	      wState[GRID_COLOR],
	      false
	    )
	    date = new Date
	    const hourAngle = (Math.PI * (((date.getHours() % 12) / 6) + (date.getMinutes() / 360))) - Math.PI / 2
	    const minuteAngle = (Math.PI * (((date.getMinutes()) / 30) + (date.getSeconds() / 1800))) - Math.PI / 2
	    const secondAngle = (Math.PI * date.getSeconds() / 30) - Math.PI / 2
	    drawLine(
	      GRID,
	      new Vector2({ magnitude: 30, angle: hourAngle + Math.PI }).add(clockCenter),
	      new Vector2({ magnitude: clockRadius / 2, angle: hourAngle }).add(clockCenter),
	      wState[GRID_COLOR],
	      8
	    )
	    drawLine(
	      GRID,
	      new Vector2({ magnitude: 30, angle: minuteAngle + Math.PI }).add(clockCenter),
	      new Vector2({ magnitude: clockRadius * 4 / 5, angle: minuteAngle }).add(clockCenter),
	      wState[GRID_COLOR],
	      8
	    )
	    drawLine(
	      GRID,
	      new Vector2({ magnitude: 40, angle: secondAngle + Math.PI }).add(clockCenter),
	      new Vector2({ magnitude: clockRadius * 4 / 6, angle: secondAngle }).add(clockCenter),
	      wState[GRID_COLOR],
	      2
	    )
	  }


	}, 1000);
      }
    
      // REDUNDANT BRUSH WIDTH
      const setBrushWidth = (newBrushWidth) => {
	wState[BRUSHES][wState[BRUSH]].width = newBrushWidth
	layers[MARKS].lineWidth = wState[BRUSHES][wState[BRUSH]].width	
	wState[ERASE_RADIUS] = 10 + layers[MARKS].lineWidth
      }

      const setColor = (c, layer=layers[MARKS]) => {
	color = new Color(c)
	switch (layer) {
	case dom[OVERLAY]:
	  dom[OVERLAY].style.background = color.getRgba()
	  setWhiteboardState(OVERLAY_COLOR, color)
	  setWhiteboardState(TOOLS_COLOR, new Color(`hsla(0, 0%, ${100 * (1 - Math.round(color.lum))}%, 0.5)`))
	  drawColorWheel(color, new Vector2(colorWheelSideLength, 0))
	  break
	case layers[GRID]:
	  setWhiteboardState(GRID_COLOR, color)
	  setGrid()
	  drawColorWheel(color, new Vector2(colorWheelSideLength * 2, 0))
	  break
	case layers[MARKS]:
	  layers[MARKS].strokeStyle = color.getRgba()
	  layers[MARKS].fillStyle = color.getRgba()
	  layers[MARKS].globalAlpha = color.alpha
	  const brushes = [...wState[BRUSHES]]
	  brushes[wState[BRUSH]].color = color
	  setWhiteboardState(BRUSHES, brushes)
	  drawColorWheel(color, new Vector2(0, 0))
	}
      }

      const setLightness = (factor) => {
	for (let brush of wState[BRUSHES]) {
	 brush.color.modify({ lum: bound(brush.color.lum * factor) })
	}
	setWhiteboardState(BRUSHES, wState[BRUSHES])
      }

      const getGridCoefficient = (pixels, factor=3) => Math.pow(10, 1 - Math.floor(Math.log10(pixels / factor)))
      
      const drawGrid = (type, offset) => {
	if (type.x === 0) {
	  return
	}
	if (storedFunctions.length > 0) {
	  for (let storedFunction of storedFunctions) {
	    plotFunction(storedFunction.f, storedFunction.style, offset, true)
	  }
	}
	return [
	  [
	    drawRectangularDotsGrid,
	    drawLinedGrid,
	    drawRectangularGrid,
	  ],
	  [
	    newTriangleDots, // drawTriangleDotsGrid,
	    newHex, // drawHexGrid,
	    newTriangle, // drawTriangleGrid
	  ],
	  [
	    drawCalendar,
	    drawPlanner,
	    drawClock
	  ]
	][type.x - 1][type.y]([
	  {
	    origin: wState[VANISHING_POINT],
	    offset: new Vector2(
	      offset.rectangular.x * getGridCoefficient(offset.rectangular.x), 
	      offset.rectangular.y * getGridCoefficient(offset.rectangular.y)
	    )},
	  { 
	    origin: wState[VANISHING_POINT],
	    offset: new Vector2 ({
	      magnitude: offset.hex.magnitude * getGridCoefficient(offset.hex.magnitude, 4),
	      angle: absoluteModulus(offset.hex.angle + Math.PI / 6, Math.PI / 3) - Math.PI / 6
	    })
	  },
	  {
	    origin: new Vector2(
	      wState[TIME_PADDING].x,
	      wState[TIME_PADDING].y
	    ),
	    offset: new Vector2(
	      (wState[BOARD_SIZE].x - wState[TIME_PADDING].x) / 7,
	      (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 48
	    )
	  }
	][type.x - 1])
      }

      const setGrid = (type=wState[GRID_TYPE]) => {
	clearLayer(GRID)	
	if (!isTyping) {
	  if (type.x === 0) {
	    hoursElement.style.display = daysElement.style.display = 'none'
	    wState[GRID_TYPE].setCoordinates(0, type.y)
	    setWhiteboardState(GRID_TYPE)
	  } else {
	    drawGrid(type, {
	      rectangular: wState[RECTANGULAR_OFFSET],
	      hex: { 
		magnitude: wState[HEX_MAGNITUDE],
		angle: wState[HEX_ANGLE]
	      },
	      time: [
		// getCalendarCell(),
		new Vector2(
		  (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 3) / 7,
		  (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 24,
		),
		new Vector2(
		  (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 3) / 7,
		  (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 24,
		),
		new Vector2(
		  (wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 3) / 7,
		  (wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 24,
		)
		// wState[HEX_MAGNITUDE]
	      ][type.y]
	    })
	    wState[GRID_TYPE].setCoordinates(type)
	    setWhiteboardState(GRID_TYPE)
	    drawCircle(
	      wState[VANISHING_POINT], 
	      5, 
	      wState[GRID_COLOR]
	    )
	  }
	}
      }
      
      const setRectangularOffset = (xOffset=wState[RECTANGULAR_OFFSET].getMagnitude() / Math.sqrt(2), yOffset) => {
	setWhiteboardState(
	  RECTANGULAR_OFFSET,
	  new Vector2(xOffset, yOffset || xOffset)
	)
	setGrid()
      }
      
      const setHexagonalOffset = (
	angle=Math.round(wState[HEX_ANGLE] * 6 / Math.PI) * Math.PI / 6,
	magnitude=wState[HEX_MAGNITUDE]
      ) => {
	if (typeof angle === 'object') {
	  magnitude = angle.getMagnitude()
	  angle = angle.getAngle()
	}
	setWhiteboardState(HEX_ANGLE, absoluteModulus(angle, Math.PI))
	setWhiteboardState(HEX_MAGNITUDE, magnitude)
	setGrid()
      }

      const setVanishingPoint = (x, y) => {
	clearLayer(GRID)
	wState[VANISHING_POINT].setCoordinates(x, y)
	setGrid()
	console.log(`vanish: (${wState[VANISHING_POINT].x}, ${wState[VANISHING_POINT].y})`)
	setWhiteboardState(VANISHING_POINT, wState[VANISHING_POINT])
	setGrid()
      }

      const getCenter = (size='SCREEN') => {
	return new Vector2(wState[`${size}_SIZE`].scale(1 / 2))
      }

      const addAngle = (degrees) => {
	setWhiteboardState(ANGLE, wState[ANGLE] + (degrees * Math.PI / 180))
      }

      const plotFunction = (
	cb, 
	brush=wState[BRUSHES][wState[BRUSH]], 
	offset={
	  rectangular: wState[RECTANGULAR_OFFSET],
	  hex: { 
	    magnitude: wState[HEX_MAGNITUDE],
	    angle: wState[HEX_ANGLE]
	  }
	},
	fromStoredFunctions=false
      ) => {
	if (!fromStoredFunctions) {
	  storedFunctions.push({ f:cb, style: { ...brush } })
	}
	let plotHeadLocation
	let previousPlotHeadLocation
	switch (wState[GRID_TYPE].x) {
	case 1:
	  let nextPlotHeadX
	  plotHeadLocation = new Vector2(
	    - wState[VANISHING_POINT].x / offset.rectangular.x,
	    cb(wState[VANISHING_POINT].x / offset.rectangular.x)
	  )
	  previousPlotHeadLocation = plotHeadLocation.copy()
	  while (plotHeadLocation.x <= wState[BOARD_SIZE].add(wState[VANISHING_POINT].scale(-1)).getRectangularOffset().x) {
	    drawLine(
	      GRID,
	      previousPlotHeadLocation
		.scale({ x: offset.rectangular.x, y: -offset.rectangular.y })
		.add(wState[VANISHING_POINT]),
	      plotHeadLocation
		.scale({ x: offset.rectangular.x, y: -offset.rectangular.y })
		.add(wState[VANISHING_POINT]),
	      brush.color,
	      brush.width
	    )
	    previousPlotHeadLocation.setCoordinates(plotHeadLocation)
	    nextPlotHeadX = plotHeadLocation.x + (1 / offset.rectangular.x)
	    plotHeadLocation.setCoordinates({ 
	      x: nextPlotHeadX,
	      y: cb(nextPlotHeadX)
	    })
	  }

	  const coefficients = new Vector2(
	    getGridCoefficient(offset.rectangular.x),
	    getGridCoefficient(offset.rectangular.y)
	  )

	  const labelIntervals = offset.rectangular.scale(coefficients)

	  // console.log('getGridCoefficient(offset.rectangular.x): ', getGridCoefficient(offset.rectangular.x))
	  plotHeadLocation.setCoordinates(
	    wState[VANISHING_POINT].x % labelIntervals.x,
	    wState[VANISHING_POINT].y % labelIntervals.y
	  )
	  while (plotHeadLocation.x < wState[BOARD_SIZE].x) {
	    const content = coefficients.x >= 1 
	      ? Math.round((plotHeadLocation.x - wState[VANISHING_POINT].x) / wState[RECTANGULAR_OFFSET].x, coefficients.x)
	      : ((plotHeadLocation.x - wState[VANISHING_POINT].x) / wState[RECTANGULAR_OFFSET].x).toFixed(-Math.log10(coefficients.x))
	    drawText(
	      GRID, 
	      content,
	      new Vector2(plotHeadLocation.x + 10 * content.toString.length, wState[VANISHING_POINT].y + 16),
	      wState[GRID_COLOR],
	      16
	    )
	   plotHeadLocation.x += labelIntervals.x
	  }
	  while (plotHeadLocation.y < wState[BOARD_SIZE].y) {
	    const content = coefficients.y >= 1 
	      ? Math.round((wState[VANISHING_POINT].y - plotHeadLocation.y) / wState[RECTANGULAR_OFFSET].y, coefficients.y)
	      : ((wState[VANISHING_POINT].y - plotHeadLocation.y) / wState[RECTANGULAR_OFFSET].y).toFixed(-Math.log10(coefficients.y))
	    drawText(
	      GRID, 
	      content,
	      new Vector2(
		wState[VANISHING_POINT].x - 10 * content.toString().length - 6, 
		plotHeadLocation.y - 6),
	      wState[GRID_COLOR],
	      16
	    )
	    plotHeadLocation.y += labelIntervals.y
	  }

	  break
	case 2:
	  let radians = 0
	  plotHeadLocation = new Vector2({ 
	    angle: radians, 
	    magnitude: cb(radians)
	  })
	  while (radians < Math.PI * 2) {
	    if (radians > Math.PI / 180) {
	      drawLine(
		GRID,
		previousPlotHeadLocation
		  .scale({ x: offset.hex.magnitude, y: -offset.hex.magnitude })
		  .add(wState[VANISHING_POINT]),
		plotHeadLocation
		  .scale({ x: offset.hex.magnitude, y: -offset.hex.magnitude })
		  .add(wState[VANISHING_POINT]),
		brush.color,
		brush.width
	      )
	    }
	    previousPlotHeadLocation = plotHeadLocation.copy()
	    radians += Math.PI / 180
	    plotHeadLocation = new Vector2({ 
	      angle: radians, 
	      magnitude: cb(radians)
	    })
	  }
	  break
	}
      }
      const clearFunctions = () => {
	storedFunctions = []
	setGrid()
      }

      // Typing
      function typingFunction (e) {
	if (![
	  'Shift', 
	  'Enter', 
	  'Control', 
	  'Alt', 
	  'ArrowUp', 
	  'ArrowRight', 
	  'ArrowDown', 
	  'ArrowLeft',
	  'Backspace',
	  'CapsLock',
	  'Escape',
	  'Delete'
	].includes(e.key)) {
	  layers[MARKS].fillText(e.key, wState[PRINT_HEAD_LOCATION].x, wState[PRINT_HEAD_LOCATION].y)
	  wState[PRINT_HEAD_LOCATION].x += wState[FONT_WIDTH]
	  updateMarksHistory()
	  drawTextCursor()
	}
      }

      const setFontHeight = (heightIndex, font) => {
	setWhiteboardState(FONT_HEIGHT, heightIndex)
	if (font !== undefined) {
	  setWhiteboardState(FONT, font)
	}
	const heightInPixels = fontSizes[heightIndex]
	wState[FONT_WIDTH] = heightInPixels * 0.62
	wState[LINE_SPACING] = heightInPixels * 1.25
	layers[MARKS].font = `${heightInPixels}px ${wState[FONT]}`
      }
      
      const offset = globalOrigin.copy()

      const constrainLine = (a, b, c) => {
	if (a.x === b.x) {
	  return new Vector2(a.x, c.y)
	} else if (a.y === b.y) {
	  return new Vector2(c.x, a.y)
	}
	const slope = {
	  b: (b.y - a.y) / (b.x - a.x),
	  c: (b.x - a.x) / (b.y - a.y) // the slope of the second line is the negative inverse of the first, but this is left positive to simplify thewState[MOUSE_DOWN_LOCATION] equation.
	}
	const xOffset = ((c.y - a.y) + ((c.x - a.x) * slope.c)) / (slope.b + slope.c)
	return new Vector2(
	  xOffset + a.x,
	  (xOffset * slope.b) + a.y
	)
      }

      const constrainArc = (a, b, c) => {
	const scale = a.getMagnitude(b)/a.getMagnitude(c)
	return new Vector2(
	  (c.x - a.x) * scale + a.x,
 	  (c.y - a.y) * scale + a.y
	)
      }
      
      // EVENT LISTENERS
      let mouseIsDown = false
      let keyIsDown = false
      let shiftIsDown = false
      let spaceIsDown = false
      let controlIsDown = false 

      dom[SENSOR].addEventListener('mousedown', (e) => {
	mouseIsDown = true
	wState[MOUSE_DOWN_LOCATION].setCoordinates(currentMouseLocation)
	setWhiteboardState(MOUSE_DOWN_LOCATION, wState[MOUSE_DOWN_LOCATION])
	wState[PRINT_HEAD_LOCATION].setCoordinates(currentMouseLocation)
	tools[wState[TOOL]].mouseDown(currentMouseLocation)
      })
      dom[SENSOR].addEventListener('mousemove', (e) => {
	currentMouseLocation.setCoordinates(e.offsetX, e.offsetY)
	wState[MOUSE_MOVE_LOCATION].setCoordinates(currentMouseLocation)
	if (mouseIsDown) {
	  tools[wState[TOOL]].mouseMove(currentMouseLocation)
	}
      })
      dom[SENSOR].addEventListener('mouseup', (e) => {
	mouseIsDown = false
	wState[MOUSE_UP_LOCATION].setCoordinates(currentMouseLocation)
	tools[wState[TOOL]].mouseUp(currentMouseLocation)
      })

      document.body.addEventListener("touchstart", function (e) {
	if (e.target.id === SENSOR) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  mouseIsDown = true
	  wState[MOUSE_DOWN_LOCATION].setCoordinates(touchLocation)
	  setWhiteboardState(MOUSE_DOWN_LOCATION, wState[MOUSE_DOWN_LOCATION])
	  wState[PRINT_HEAD_LOCATION].setCoordinates(touchLocation)
	  tools[wState[TOOL]].mouseDown(touchLocation)
	}
      }, { passive: false })
      document.body.addEventListener("touchmove", function (e) {
	if (e.target === dom[SENSOR]) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  wState[MOUSE_MOVE_LOCATION].setCoordinates(touchLocation)
	  if (mouseIsDown) {
	    tools[wState[TOOL]].mouseMove(touchLocation)
	  }
	}
      }, { passive: false });
      document.body.addEventListener("touchend", function (e) {
	if (e.target === dom[SENSOR]) {
	  e.preventDefault()
	  const touchLocation = new Vector2(e.pageX, e.pageY)
	  mouseIsDown = false
	  wState[MOUSE_UP_LOCATION].setCoordinates(touchLocation)
	  tools[wState[TOOL]].mouseUp(touchLocation)
	}
      }, { passive: false })

      dom[SENSOR].addEventListener('mouseup', (event) => {
	mouseIsDown = false;
	isDrawing = false
	let mouse = new Vector2(wState[MOUSE_MOVE_LOCATION].x, wState[MOUSE_MOVE_LOCATION].y)
	let width = mouse.x -wState[MOUSE_DOWN_LOCATION].x
	let height = mouse.y -wState[MOUSE_DOWN_LOCATION].y
      })

      

      dom[SENSOR].addEventListener('mouseout', () => {
	isDrawing = false
	mouseIsDown = false
      })

      dom[SENSOR].addEventListener('contextmenu', (e) => {
	e.preventDefault()
	isDrawing = false
	mouseIsDown = false
	const name = prompt('Please name this data', wState[MARKS_DATA])
	clearLayer(TOOLS)
	if (name !== null) {
	  wState[SAVED_MARKS_DATA][name] = dom[MARKS].toDataURL('image/png')
	  setWhiteboardState(SAVED_MARKS_DATA, wState[SAVED_MARKS_DATA])
	  console.log(`Saved ${name}`)
	}
      })

      window.addEventListener('scroll', (e) => {
	hoursElement.style.top = `${-window.pageYOffset + 40}px`
	daysElement.style.left = `${-window.pageXOffset + 80}px`
      })

      document.addEventListener('keydown', (event) => {
	if (isTyping) {
	  typingFunction(event)
	}
	if (!keyIsDown) {
	  switch (event.key) {
	    case 'h':
	       if (!isTyping) {
		 alert('TOOLS:\n  P - paintbrush\n  R - rectangle\n  E - ellipse\n  L - line\n  T - text\n  M - measure\n  Z - zoom\n  S - select\n\nOTHER CONTROLS:\n  Backtick, 0 - 9: choose brush, hold to set color\n    the color palettes are arranged as follows:\n      Left - paintbrush color\n      Center - overlay color\n      Right - grid color\n  "-", "=" - adjust brush width\n  "[", "]" - adjust font size\n  F - toggle fill for shapes and arrows\n  V - place vanishing point, hold to scale grid units\n  G - choose grid type\n  J - choose grid cell type\n  I - reset Unsplash image\n  Right-Click - save marks-data')
		 alert('Ctrl:\n  constrains paintbrush to grid axes\n  constrains shapes to 1x1 aspect ratio\n  constrains line to 15 degree increments\n  Ctrl+Z - undo\n  Ctrl+Y - redo\n  Ctrl+C - copy selection\n  Ctrl+X - cut selection\n  Ctrl+V - paste selection\n\nArrow Keys:\n  Up - constrains paintbrush to vertical\n  Left - constrains paintbrush to horizontal\n  Down - constrains paintbrush to lines intersecting vanishing point\n  Right - constrains paintbrush to arcs about vanishing point\n  Forward Slash - constrains brush to parallel\n  Apostrophe - constrainst brush to perpendicular\n\nQUERY PARAMETERS:\n  document-title\n  screen-size, board-size\n  problem-image, wallpaper-image\n  marks-data')
	       }
	       break
	  case 't':
	  case 'T':
	    if (!isTyping) {
	      lastTool = wState[TOOL]
	      setWhiteboardState(TOOL, TEXT)
	      isTyping = true
	      drawTextCursor()
	    }
	    break;
	  case 'g':
	  case 'G':
	    wState[GRID_TYPE].setCoordinates((wState[GRID_TYPE].x + 1) % 4, wState[GRID_TYPE].y)
	    setGrid()
	    break
	  case 'j':
	  case 'J':
	    wState[GRID_TYPE].setCoordinates(wState[GRID_TYPE].x, (wState[GRID_TYPE].y + 1) % 3)
	    setGrid()
	    break;
	  case 'i':
	  case 'I':
	    if (!isTyping) {
	      wState[WALLPAPER_IMAGE] = getCollection(wState[SCREEN_SIZE])
	      setImage(WALLPAPER, wState[WALLPAPER_IMAGE])
	    }
	    break
	  case 's':
	  case 'S':
	    if (!isTyping) {
	      clearLayer(TOOLS)
	      setWhiteboardState(TOOL, SELECT)
	      lastTool = SELECT
	    }
	    break
	  case '.':
	    if (!isTyping) {
	      slide++
		clearLayer(WALLPAPER)
	      setImage(WALLPAPER, slideshow[slide % slideshow.length])
	      document.title = parseFilename(slideshow[slide % slideshow.length])
	    }
	    break
	  case ',':
	    if (!isTyping) {
	      slide--
		clearLayer(WALLPAPER)
	      setImage(WALLPAPER, slideshow[slide % slideshow.length])
	      document.title = parseFilename(slideshow[slide % slideshow.length])
	    }
	    break
	  case '-':
	    if (!isTyping && layers[MARKS].lineWidth > 1) {
	      setBrushWidth(parseInt(wState[BRUSHES][wState[BRUSH]].width) - 1)
	      setWhiteboardState(BRUSHES, wState[BRUSHES])
	      setWhiteboardState(ERASE_RADIUS, wState[ERASE_RADIUS])
	    } 
	    break;
	  case '=':
	    if (!isTyping) {
	      setBrushWidth(parseInt(wState[BRUSHES][wState[BRUSH]].width) + 1)
	      setWhiteboardState(BRUSHES, wState[BRUSHES])
	      setWhiteboardState(ERASE_RADIUS, wState[ERASE_RADIUS])
	    }
	    break;
	  case '[':
	    if (!isTyping && wState[FONT_HEIGHT] > 0) {
	      setFontHeight(wState[FONT_HEIGHT] - 1)
	    }
	    break
	  case ']':
	    if (!isTyping && wState[FONT_HEIGHT] < 13) {
	      setFontHeight(wState[FONT_HEIGHT] + 1)
	    }
	    break
	  case '`':
	    if (!isTyping) {
	      lastTool = wState[TOOL]
	      wState[TOOL] = PALETTE
	      if (wState[BRUSH] !== 10) {
		setWhiteboardState(BRUSH, 10)
		layers[MARKS].lineWidth = wState[BRUSHES][wState[BRUSH]].width
		setColor(wState[BRUSHES][wState[BRUSH]].color, layers[MARKS])
	      }
	      [isPickingColor, dom[PALETTE].style.display] = [true, 'initial']
	    }
	    break
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    if (!isTyping) {
	      lastTool = wState[TOOL]
	      wState[TOOL] = PALETTE
	      if (parseInt(event.key) !== wState[BRUSH]) {
		setWhiteboardState(BRUSH, parseInt(event.key))
		layers[MARKS].lineWidth = wState[BRUSHES][wState[BRUSH]].width
		setColor(wState[BRUSHES][wState[BRUSH]].color, layers[MARKS])
	      }
	      [isPickingColor, dom[PALETTE].style.display] = [true, 'initial']
	    }
	    break
	  case 'v':
	  case 'V':
	    if (!isTyping) {
	      setVanishingPoint(wState[MOUSE_MOVE_LOCATION].x, wState[MOUSE_MOVE_LOCATION].y)
	      wState[TOOL] = GRID
	    }
	    break
	  }
	
	}	
	keyIsDown = true
      })

      window.addEventListener("keydown", function (event) {
	if (event.defaultPrevented) {
	  return; // Do nothing if the event was already processed
	}
	switch (event.key) {
	case 'ArrowRight':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = ARC
	  }else { 
	    wState[PRINT_HEAD_LOCATION].x += wState[FONT_WIDTH]
	    drawTextCursor()
	  } 
	  break
	case 'ArrowUp':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = VERTICAL
	  } else { 
	   wState[PRINT_HEAD_LOCATION].y -= wState[LINE_SPACING]
	    drawTextCursor()
	  }
	  break
	case 'ArrowLeft':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = HORIZONTAL
	  } else { 
	   wState[PRINT_HEAD_LOCATION].x -= wState[FONT_WIDTH]
	    drawTextCursor()
	  }
	  break
	case 'ArrowDown':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = VANISHING
	  } else { 
	   wState[PRINT_HEAD_LOCATION].y += wState[LINE_SPACING]
	    drawTextCursor()
	  }
	  break
	case 'Control':
	  if (!isTyping) {
	    constraint = [
	      COMMITTED, 
	      VERTICAL_HORIZONTAL,
	      HEXAGONAL,
	      VERTICAL_HORIZONTAL,
	      DIAGONAL, 
	      DOZENAL
	    ][
	      [RECTANGLE, ELLIPSE].includes(wState[TOOL]) 
		? 4
		: wState[TOOL] === LINE 
		  ? 5
		  : wState[GRID_TYPE].x
	    ]
	    if (constraint === COMMITTED) {
	      wState[TOOL] = COMMITTED
	    }
	    controlIsDown = true
	  }
	  break
	case 'Shift':
	  if (!isTyping) {
	    shiftIsDown = true
	  }
	  break
	case '/':
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = PARALLEL
	  } 
	  break
	case "'":
	  event.preventDefault()
	  if (!isTyping) {
	    constraint = PERPENDICULAR
	  } 
	  break
	case 'p':
	case 'P':
	  if (!isTyping) {
	    clearLayer(TOOLS)
	    setWhiteboardState(TOOL, PAINT_BRUSH)
	    lastTool = PAINT_BRUSH
	  }
	  break
	case 'r':
	case 'R':
	  if (!isTyping) {
	    clearLayer(TOOLS)
	    setWhiteboardState(TOOL, RECTANGLE)
	    lastTool = RECTANGLE
	  }
	  break
	case 'e':
	case 'E':
	  if (!isTyping) {
	    clearLayer(TOOLS)
	    setWhiteboardState(TOOL, ELLIPSE)
	    lastTool = ELLIPSE
	  }
	  break
	case 'l':
	case 'L':
	  if (!isTyping) {
	    clearLayer(TOOLS)
	    setWhiteboardState(TOOL, LINE)
	    lastTool = LINE
	  }
	  break
	case 'm':
	case 'M':
	  if (!isTyping) {
	    clearLayer(TOOLS)
	    setWhiteboardState(TOOL, MEASURE)
	    lastTool = MEASURE
	  }
	  break
	case 'z':
	case 'Z':
	  if (!isTyping) {
	    clearLayer(TOOLS)
	    setWhiteboardState(TOOL, ZOOM)
	    lastTool = ZOOM
	  }
	  break
	case 'f':
	case 'F':
	  clearLayer(TOOLS)
	  setWhiteboardState(FILL_ACTIVE, !wState[FILL_ACTIVE])
	  drawMeasureText(
	    wState[MEASUREMENT].mouseDown,
	    wState[MEASUREMENT].mouseUp,
	    wState[MEASUREMENT].gridType
	  )
	  break
	case ' ':
	  event.preventDefault()
	  if (!isTyping) {
	    spaceIsDown = true;
	  }
	  break
	case 'Escape':
	  mouseIsDown = false
	  isDrawing = false
	  isDrawingRectangle = false
	  isDrawingEllipse = false
	  isDrawingLine = false
	  isErasing = false
	  isTyping = false
	  if (lastTool !== undefined) {
	    wState[TOOL] = lastTool
	  } else {
	    wState[TOOL] = defaultState[TOOL]
	  }
	  clearLayer(TOOLS, true)
	  break
	case 'Backspace':
	  if (!isTyping) {
	    clearLayer(MARKS)
	  } else {
	   wState[PRINT_HEAD_LOCATION].x -= wState[FONT_WIDTH]
	    layers[MARKS].clearRect(
	     wState[PRINT_HEAD_LOCATION].x, 
	     wState[PRINT_HEAD_LOCATION].y - fontSizes[wState[FONT_HEIGHT]], 
	      wState[FONT_WIDTH], 
	      fontSizes[wState[FONT_HEIGHT]] * 1.21
	    )
	    drawTextCursor()
	  }
	  break
	case 'Enter':
	  if (isTyping) {
	   wState[PRINT_HEAD_LOCATION].x = wState[MOUSE_DOWN_LOCATION].x
	   wState[PRINT_HEAD_LOCATION].y += wState[LINE_SPACING]
	    drawTextCursor()
	  }
	}
      });

      window.addEventListener("keyup", function (event) {
	if (event.defaultPrevented) {
	  return; // Do nothing if the event was already processed
	}

	switch (event.key) {
	case ' ':
	  if (!isTyping) {
	    spaceIsDown = false
	    break
	  }
	case 'ArrowRight':
	case 'ArrowUp':
	case 'ArrowLeft':
	case 'ArrowDown':
	case '/':
	case "'":
	case 'Control':
	  if (!isTyping) {
	    if (constraint === COMMITTED) {
	      wState[TOOL] = lastTool
	    }
	    constraint = NONE
	  }
	  controlIsDown = false
	  break
	case '`':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (!isTyping) {
	    wState[TOOL] = lastTool
	    isPickingColor = false
	    dom[PALETTE].style.display = 'none'
	    break
	  }
	case 'Shift':
	  if (!isTyping) {
	    shiftIsDown = false
	  }
	  break
	case 'z':
	case 'Z':
	  if (!isTyping && controlIsDown && historyIndex > 0) {
	    historyIndex -= 1
	    setImage(MARKS, marksHistory[historyIndex])
	  }
	  break
	case 'x':
	case 'X':
	  if (!isTyping && controlIsDown) {
	    clearLayer(TOOLS)
	    clipboard = layers[MARKS].getImageData(
	      selectBox.x, 
	      selectBox.y,
	      selectBox.width,
	      selectBox.height
	    )
	    layers[MARKS].clearRect(
	      selectBox.x, 
	      selectBox.y,
	      selectBox.width,
	      selectBox.height
	    )
	    updateMarksHistory()
	  }
	  break
	case 'c':
	case 'C':
	  if (!isTyping && controlIsDown) {
	    clearLayer(TOOLS)
	    clipboard = layers[MARKS].getImageData(
	      selectBox.x,
	      selectBox.y,
	      selectBox.width,
	      selectBox.height
	    )
	  }
	  break
	case 'v':
	case 'V':
	  if (!isTyping) { 
	    if (controlIsDown) {
	      const originalMarks = layers[MARKS].getImageData(
		currentMouseLocation.x, 
		currentMouseLocation.y, 
		clipboard.width, 
		clipboard.height
	      )
	      let newImageData = []
	      for (let i = 0; i < clipboard.data.length; i += 4) {
		let rOld = originalMarks.data[i]
		let rNew = clipboard.data[i]
		let gOld = originalMarks.data[i + 1]
		let gNew = clipboard.data[i + 1]
		let bOld = originalMarks.data[i + 2]
		let bNew = clipboard.data[i + 2]
		let aOld = originalMarks.data[i + 3]
		let aNew = clipboard.data[i + 3]
		newImageData.push(Math.min(255, rNew * (aNew / 255) + rOld * (aOld / 255) * (1 - (aNew / 255))))
		newImageData.push(Math.min(255, gNew * (aNew / 255) + gOld * (aOld / 255) * (1 - (aNew / 255))))
		newImageData.push(Math.min(255, bNew * (aNew / 255) + bOld * (aOld / 255) * (1 - (aNew / 255))))
		newImageData.push(Math.min(255, aOld + aNew))
	      }
	      const newClipboard = new ImageData(Uint8ClampedArray.from(newImageData), clipboard.width, clipboard.height)
	      layers[MARKS].putImageData(newClipboard, currentMouseLocation.x, currentMouseLocation.y)
	      updateMarksHistory()
	    } else {
	      wState[TOOL] = lastTool
	    }
	  } 
	  break
	case 'y':
	case 'Y':
	  if (!isTyping && controlIsDown && historyIndex < marksHistory.length - 1) {
	    historyIndex += 1
	    setImage(MARKS, marksHistory[historyIndex])
	  }
	  break
	}
	keyIsDown = false
      })

      // INITIALIZATION
      let isDrawing = false
      let isErasing = false
      let isBoxErasing = false
      let isCopying = false
      let isPickingColor = false
      let clipboard
      let selectBox
      let measurementElement
      let isDrawingRectangle = false
      let isDrawingLine = false
      let isTyping = false
      let constraint = NONE
      let storedFunctions = []
      let previousVanishingPoint = globalOrigin.copy()
      let previousOffsetMagnitude
      let historyIndex = 0
      let currentMouseLocation = globalOrigin.copy()
      let marksHistory

      const query = parseQueryString(window.location.href)
      const wState = {}
      Object.assign(
	wState, 
	{
	  ...defaultState,
	  ...JSON.parse(localStorage.getItem(WHITEBOARD_STATE)),
	  ...wState,
	  ...query
	}
      )
      wState[SCREEN_SIZE] = query[SCREEN_SIZE] 
	? new Vector2(query[SCREEN_SIZE]) 
	: new Vector2(window.screen.width, window.screen.height)
      wState[BOARD_SIZE] = query[BOARD_SIZE]
	? new Vector2(query[BOARD_SIZE]) 
	: new Vector2(
	  wState[SCREEN_SIZE].x * defaultState[BOARD_SCALE].x,
	  wState[SCREEN_SIZE].y * defaultState[BOARD_SCALE].y
	)
      wState[WALLPAPER_IMAGE] = query[WALLPAPER_IMAGE] || getCollection(wState[SCREEN_SIZE])
      wState[ANGLE] = Number(wState[ANGLE])
      wState[BRUSH] = Number(wState[BRUSH])
      wState[ERASE_RADIUS] = Number(wState[ERASE_RADIUS])
      wState[GRID_WIDTH] = Number(wState[GRID_WIDTH])
      wState[ZOOM] = Number(wState[ZOOM])
      if (wState.hasOwnProperty(VANISHING_POINT)) {
	wState[VANISHING_POINT] = new Vector2(wState[VANISHING_POINT])
      } else {
	wState[VANISHING_POINT] = new Vector2(
	  wState[SCREEN_SIZE].x / 2,
	  wState[SCREEN_SIZE].y / 2
	)
      }
      wState[MOUSE_DOWN_LOCATION] = new Vector2(wState[MOUSE_DOWN_LOCATION])
      wState[MOUSE_MOVE_LOCATION] = new Vector2(wState[MOUSE_MOVE_LOCATION])
      wState[MOUSE_UP_LOCATION] = new Vector2(wState[MOUSE_UP_LOCATION])
      wState[PRINT_HEAD_LOCATION] = new Vector2(wState[PRINT_HEAD_LOCATION])
      wState[MEASUREMENT] = new Vector2(wState[MEASUREMENT])
      wState[OVERLAY_COLOR] = new Color(wState[OVERLAY_COLOR])
      wState[GRID_COLOR] = new Color(wState[GRID_COLOR])
      wState[GRID_TYPE] = new Vector2(wState[GRID_TYPE])
      wState[TIME_PADDING] = new Vector2(wState[TIME_PADDING])
      wState[RECTANGULAR_OFFSET] = new Vector2(wState[RECTANGULAR_OFFSET])
      wState[CALENDAR_OFFSET] = wState[RECTANGULAR_OFFSET].copy()
      wState[PLANNER_OFFSET] = new Vector2(
	(wState[BOARD_SIZE].x - wState[TIME_PADDING].x * 2) / 7,
	(wState[BOARD_SIZE].y - wState[TIME_PADDING].y) / 48
      )
      wState[TIME_PADDING] = new Vector2(wState[TIME_PADDING])
      wState[BRUSHES].forEach((brush) => {
	brush.color = new Color(brush.color)
      })
      wState[TOOLS_COLOR] = new Color(wState[TOOLS_COLOR])
      let lastTool 
      if (wState[TOOL] === PALETTE
	|| wState[TOOL] === GRID
	|| wState[TOOL] === COMMITTED) {
	setWhiteboardState(TOOL, PAINT_BRUSH)
      }
      lastTool= wState[TOOL]

      dom[PROBLEM].style.display = 'none'
      dom[PALETTE].style.display = 'none'
      layers[MARKS].lineJoin = 'round'
      layers[MARKS].lineCap = 'round'

      applyState(wState)

      document.title = query[DOCUMENT_TITLE] || query[MARKS_DATA] || 'Whiteboard' 
      query[MARKS_IMAGE] && setImage(MARKS, query[MARKS_IMAGE])      
      console.log(`Wallpaper Image: ${wState[WALLPAPER_IMAGE]}`)
      if (query[PROBLEM_IMAGE]) {
	setImage(PROBLEM, query[PROBLEM_IMAGE], { margin: '2rem'})
	dom[PROBLEM].style.display = 'initial'
      }
      if (wState[TOOL] === TEXT) {
	drawTextCursor()
	isTyping = true
      }
      if (wState[SAVED_MARKS_DATA][query[MARKS_DATA]]) {
	marksHistory = [wState[SAVED_MARKS_DATA][query[MARKS_DATA]]]
	setImage(MARKS, wState[SAVED_MARKS_DATA][query[MARKS_DATA]])
      } else {
	marksHistory = [dom[MARKS].toDataURL('image/png')]
      }
    </script>
  </body>
</html>
